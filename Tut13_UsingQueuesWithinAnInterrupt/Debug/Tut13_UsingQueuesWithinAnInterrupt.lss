
Tut13_UsingQueuesWithinAnInterrupt.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002bfa  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000000e  00800060  00002bfa  00002c8e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000002e7  0080006e  0080006e  00002c9c  2**0
                  ALLOC
  3 .stab         00004c5c  00000000  00000000  00002c9c  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00002b67  00000000  00000000  000078f8  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 5b 05 	jmp	0xab6	; 0xab6 <__vector_1>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 64 08 	jmp	0x10c8	; 0x10c8 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ea ef       	ldi	r30, 0xFA	; 250
      68:	fb e2       	ldi	r31, 0x2B	; 43
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	ae 36       	cpi	r26, 0x6E	; 110
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	13 e0       	ldi	r17, 0x03	; 3
      78:	ae e6       	ldi	r26, 0x6E	; 110
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a5 35       	cpi	r26, 0x55	; 85
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 0c 05 	call	0xa18	; 0xa18 <main>
      8a:	0c 94 fb 15 	jmp	0x2bf6	; 0x2bf6 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
      92:	df 93       	push	r29
      94:	cf 93       	push	r28
      96:	cd b7       	in	r28, 0x3d	; 61
      98:	de b7       	in	r29, 0x3e	; 62
      9a:	27 97       	sbiw	r28, 0x07	; 7
      9c:	0f b6       	in	r0, 0x3f	; 63
      9e:	f8 94       	cli
      a0:	de bf       	out	0x3e, r29	; 62
      a2:	0f be       	out	0x3f, r0	; 63
      a4:	cd bf       	out	0x3d, r28	; 61
      a6:	9d 83       	std	Y+5, r25	; 0x05
      a8:	8c 83       	std	Y+4, r24	; 0x04
      aa:	6e 83       	std	Y+6, r22	; 0x06
      ac:	4f 83       	std	Y+7, r20	; 0x07
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
      ae:	8a e1       	ldi	r24, 0x1A	; 26
      b0:	90 e0       	ldi	r25, 0x00	; 0
      b2:	0e 94 21 03 	call	0x642	; 0x642 <pvPortMalloc>
      b6:	9a 83       	std	Y+2, r25	; 0x02
      b8:	89 83       	std	Y+1, r24	; 0x01
	if( pxCoRoutine )
      ba:	89 81       	ldd	r24, Y+1	; 0x01
      bc:	9a 81       	ldd	r25, Y+2	; 0x02
      be:	00 97       	sbiw	r24, 0x00	; 0
      c0:	09 f4       	brne	.+2      	; 0xc4 <xCoRoutineCreate+0x32>
      c2:	6f c0       	rjmp	.+222    	; 0x1a2 <xCoRoutineCreate+0x110>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
      c4:	80 91 6e 00 	lds	r24, 0x006E
      c8:	90 91 6f 00 	lds	r25, 0x006F
      cc:	00 97       	sbiw	r24, 0x00	; 0
      ce:	41 f4       	brne	.+16     	; 0xe0 <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
      d0:	89 81       	ldd	r24, Y+1	; 0x01
      d2:	9a 81       	ldd	r25, Y+2	; 0x02
      d4:	90 93 6f 00 	sts	0x006F, r25
      d8:	80 93 6e 00 	sts	0x006E, r24
			prvInitialiseCoRoutineLists();
      dc:	0e 94 b0 02 	call	0x560	; 0x560 <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
      e0:	8e 81       	ldd	r24, Y+6	; 0x06
      e2:	82 30       	cpi	r24, 0x02	; 2
      e4:	10 f0       	brcs	.+4      	; 0xea <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
      e6:	81 e0       	ldi	r24, 0x01	; 1
      e8:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
      ea:	e9 81       	ldd	r30, Y+1	; 0x01
      ec:	fa 81       	ldd	r31, Y+2	; 0x02
      ee:	11 8e       	std	Z+25, r1	; 0x19
      f0:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
      f2:	e9 81       	ldd	r30, Y+1	; 0x01
      f4:	fa 81       	ldd	r31, Y+2	; 0x02
      f6:	8e 81       	ldd	r24, Y+6	; 0x06
      f8:	86 8b       	std	Z+22, r24	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
      fa:	e9 81       	ldd	r30, Y+1	; 0x01
      fc:	fa 81       	ldd	r31, Y+2	; 0x02
      fe:	8f 81       	ldd	r24, Y+7	; 0x07
     100:	87 8b       	std	Z+23, r24	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
     102:	e9 81       	ldd	r30, Y+1	; 0x01
     104:	fa 81       	ldd	r31, Y+2	; 0x02
     106:	8c 81       	ldd	r24, Y+4	; 0x04
     108:	9d 81       	ldd	r25, Y+5	; 0x05
     10a:	91 83       	std	Z+1, r25	; 0x01
     10c:	80 83       	st	Z, r24

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
     10e:	89 81       	ldd	r24, Y+1	; 0x01
     110:	9a 81       	ldd	r25, Y+2	; 0x02
     112:	02 96       	adiw	r24, 0x02	; 2
     114:	0e 94 fb 03 	call	0x7f6	; 0x7f6 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
     118:	89 81       	ldd	r24, Y+1	; 0x01
     11a:	9a 81       	ldd	r25, Y+2	; 0x02
     11c:	0c 96       	adiw	r24, 0x0c	; 12
     11e:	0e 94 fb 03 	call	0x7f6	; 0x7f6 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
     122:	e9 81       	ldd	r30, Y+1	; 0x01
     124:	fa 81       	ldd	r31, Y+2	; 0x02
     126:	89 81       	ldd	r24, Y+1	; 0x01
     128:	9a 81       	ldd	r25, Y+2	; 0x02
     12a:	91 87       	std	Z+9, r25	; 0x09
     12c:	80 87       	std	Z+8, r24	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
     12e:	e9 81       	ldd	r30, Y+1	; 0x01
     130:	fa 81       	ldd	r31, Y+2	; 0x02
     132:	89 81       	ldd	r24, Y+1	; 0x01
     134:	9a 81       	ldd	r25, Y+2	; 0x02
     136:	93 8b       	std	Z+19, r25	; 0x13
     138:	82 8b       	std	Z+18, r24	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
     13a:	8e 81       	ldd	r24, Y+6	; 0x06
     13c:	28 2f       	mov	r18, r24
     13e:	30 e0       	ldi	r19, 0x00	; 0
     140:	83 e0       	ldi	r24, 0x03	; 3
     142:	90 e0       	ldi	r25, 0x00	; 0
     144:	82 1b       	sub	r24, r18
     146:	93 0b       	sbc	r25, r19
     148:	e9 81       	ldd	r30, Y+1	; 0x01
     14a:	fa 81       	ldd	r31, Y+2	; 0x02
     14c:	95 87       	std	Z+13, r25	; 0x0d
     14e:	84 87       	std	Z+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
     150:	e9 81       	ldd	r30, Y+1	; 0x01
     152:	fa 81       	ldd	r31, Y+2	; 0x02
     154:	96 89       	ldd	r25, Z+22	; 0x16
     156:	80 91 70 00 	lds	r24, 0x0070
     15a:	89 17       	cp	r24, r25
     15c:	28 f4       	brcc	.+10     	; 0x168 <xCoRoutineCreate+0xd6>
     15e:	e9 81       	ldd	r30, Y+1	; 0x01
     160:	fa 81       	ldd	r31, Y+2	; 0x02
     162:	86 89       	ldd	r24, Z+22	; 0x16
     164:	80 93 70 00 	sts	0x0070, r24
     168:	e9 81       	ldd	r30, Y+1	; 0x01
     16a:	fa 81       	ldd	r31, Y+2	; 0x02
     16c:	86 89       	ldd	r24, Z+22	; 0x16
     16e:	28 2f       	mov	r18, r24
     170:	30 e0       	ldi	r19, 0x00	; 0
     172:	c9 01       	movw	r24, r18
     174:	88 0f       	add	r24, r24
     176:	99 1f       	adc	r25, r25
     178:	88 0f       	add	r24, r24
     17a:	99 1f       	adc	r25, r25
     17c:	88 0f       	add	r24, r24
     17e:	99 1f       	adc	r25, r25
     180:	82 0f       	add	r24, r18
     182:	93 1f       	adc	r25, r19
     184:	ac 01       	movw	r20, r24
     186:	49 58       	subi	r20, 0x89	; 137
     188:	5f 4f       	sbci	r21, 0xFF	; 255
     18a:	89 81       	ldd	r24, Y+1	; 0x01
     18c:	9a 81       	ldd	r25, Y+2	; 0x02
     18e:	9c 01       	movw	r18, r24
     190:	2e 5f       	subi	r18, 0xFE	; 254
     192:	3f 4f       	sbci	r19, 0xFF	; 255
     194:	ca 01       	movw	r24, r20
     196:	b9 01       	movw	r22, r18
     198:	0e 94 0b 04 	call	0x816	; 0x816 <vListInsertEnd>

		xReturn = pdPASS;
     19c:	81 e0       	ldi	r24, 0x01	; 1
     19e:	8b 83       	std	Y+3, r24	; 0x03
     1a0:	02 c0       	rjmp	.+4      	; 0x1a6 <xCoRoutineCreate+0x114>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     1a2:	8f ef       	ldi	r24, 0xFF	; 255
     1a4:	8b 83       	std	Y+3, r24	; 0x03
	}
	
	return xReturn;	
     1a6:	8b 81       	ldd	r24, Y+3	; 0x03
}
     1a8:	27 96       	adiw	r28, 0x07	; 7
     1aa:	0f b6       	in	r0, 0x3f	; 63
     1ac:	f8 94       	cli
     1ae:	de bf       	out	0x3e, r29	; 62
     1b0:	0f be       	out	0x3f, r0	; 63
     1b2:	cd bf       	out	0x3d, r28	; 61
     1b4:	cf 91       	pop	r28
     1b6:	df 91       	pop	r29
     1b8:	08 95       	ret

000001ba <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
     1ba:	df 93       	push	r29
     1bc:	cf 93       	push	r28
     1be:	00 d0       	rcall	.+0      	; 0x1c0 <vCoRoutineAddToDelayedList+0x6>
     1c0:	00 d0       	rcall	.+0      	; 0x1c2 <vCoRoutineAddToDelayedList+0x8>
     1c2:	00 d0       	rcall	.+0      	; 0x1c4 <vCoRoutineAddToDelayedList+0xa>
     1c4:	cd b7       	in	r28, 0x3d	; 61
     1c6:	de b7       	in	r29, 0x3e	; 62
     1c8:	9c 83       	std	Y+4, r25	; 0x04
     1ca:	8b 83       	std	Y+3, r24	; 0x03
     1cc:	7e 83       	std	Y+6, r23	; 0x06
     1ce:	6d 83       	std	Y+5, r22	; 0x05
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
     1d0:	20 91 71 00 	lds	r18, 0x0071
     1d4:	30 91 72 00 	lds	r19, 0x0072
     1d8:	8b 81       	ldd	r24, Y+3	; 0x03
     1da:	9c 81       	ldd	r25, Y+4	; 0x04
     1dc:	82 0f       	add	r24, r18
     1de:	93 1f       	adc	r25, r19
     1e0:	9a 83       	std	Y+2, r25	; 0x02
     1e2:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     1e4:	80 91 6e 00 	lds	r24, 0x006E
     1e8:	90 91 6f 00 	lds	r25, 0x006F
     1ec:	02 96       	adiw	r24, 0x02	; 2
     1ee:	0e 94 c3 04 	call	0x986	; 0x986 <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
     1f2:	e0 91 6e 00 	lds	r30, 0x006E
     1f6:	f0 91 6f 00 	lds	r31, 0x006F
     1fa:	89 81       	ldd	r24, Y+1	; 0x01
     1fc:	9a 81       	ldd	r25, Y+2	; 0x02
     1fe:	93 83       	std	Z+3, r25	; 0x03
     200:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
     202:	20 91 71 00 	lds	r18, 0x0071
     206:	30 91 72 00 	lds	r19, 0x0072
     20a:	89 81       	ldd	r24, Y+1	; 0x01
     20c:	9a 81       	ldd	r25, Y+2	; 0x02
     20e:	82 17       	cp	r24, r18
     210:	93 07       	cpc	r25, r19
     212:	70 f4       	brcc	.+28     	; 0x230 <vCoRoutineAddToDelayedList+0x76>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     214:	80 91 9d 00 	lds	r24, 0x009D
     218:	90 91 9e 00 	lds	r25, 0x009E
     21c:	20 91 6e 00 	lds	r18, 0x006E
     220:	30 91 6f 00 	lds	r19, 0x006F
     224:	2e 5f       	subi	r18, 0xFE	; 254
     226:	3f 4f       	sbci	r19, 0xFF	; 255
     228:	b9 01       	movw	r22, r18
     22a:	0e 94 57 04 	call	0x8ae	; 0x8ae <vListInsert>
     22e:	0d c0       	rjmp	.+26     	; 0x24a <vCoRoutineAddToDelayedList+0x90>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     230:	80 91 9b 00 	lds	r24, 0x009B
     234:	90 91 9c 00 	lds	r25, 0x009C
     238:	20 91 6e 00 	lds	r18, 0x006E
     23c:	30 91 6f 00 	lds	r19, 0x006F
     240:	2e 5f       	subi	r18, 0xFE	; 254
     242:	3f 4f       	sbci	r19, 0xFF	; 255
     244:	b9 01       	movw	r22, r18
     246:	0e 94 57 04 	call	0x8ae	; 0x8ae <vListInsert>
	}

	if( pxEventList )
     24a:	8d 81       	ldd	r24, Y+5	; 0x05
     24c:	9e 81       	ldd	r25, Y+6	; 0x06
     24e:	00 97       	sbiw	r24, 0x00	; 0
     250:	61 f0       	breq	.+24     	; 0x26a <vCoRoutineAddToDelayedList+0xb0>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
     252:	80 91 6e 00 	lds	r24, 0x006E
     256:	90 91 6f 00 	lds	r25, 0x006F
     25a:	9c 01       	movw	r18, r24
     25c:	24 5f       	subi	r18, 0xF4	; 244
     25e:	3f 4f       	sbci	r19, 0xFF	; 255
     260:	8d 81       	ldd	r24, Y+5	; 0x05
     262:	9e 81       	ldd	r25, Y+6	; 0x06
     264:	b9 01       	movw	r22, r18
     266:	0e 94 57 04 	call	0x8ae	; 0x8ae <vListInsert>
	}
}
     26a:	26 96       	adiw	r28, 0x06	; 6
     26c:	0f b6       	in	r0, 0x3f	; 63
     26e:	f8 94       	cli
     270:	de bf       	out	0x3e, r29	; 62
     272:	0f be       	out	0x3f, r0	; 63
     274:	cd bf       	out	0x3d, r28	; 61
     276:	cf 91       	pop	r28
     278:	df 91       	pop	r29
     27a:	08 95       	ret

0000027c <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
     27c:	df 93       	push	r29
     27e:	cf 93       	push	r28
     280:	00 d0       	rcall	.+0      	; 0x282 <prvCheckPendingReadyList+0x6>
     282:	cd b7       	in	r28, 0x3d	; 61
     284:	de b7       	in	r29, 0x3e	; 62
     286:	3a c0       	rjmp	.+116    	; 0x2fc <prvCheckPendingReadyList+0x80>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
     288:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
     28a:	e0 91 a4 00 	lds	r30, 0x00A4
     28e:	f0 91 a5 00 	lds	r31, 0x00A5
     292:	86 81       	ldd	r24, Z+6	; 0x06
     294:	97 81       	ldd	r25, Z+7	; 0x07
     296:	9a 83       	std	Y+2, r25	; 0x02
     298:	89 83       	std	Y+1, r24	; 0x01
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     29a:	89 81       	ldd	r24, Y+1	; 0x01
     29c:	9a 81       	ldd	r25, Y+2	; 0x02
     29e:	0c 96       	adiw	r24, 0x0c	; 12
     2a0:	0e 94 c3 04 	call	0x986	; 0x986 <vListRemove>
		}
		portENABLE_INTERRUPTS();
     2a4:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
     2a6:	89 81       	ldd	r24, Y+1	; 0x01
     2a8:	9a 81       	ldd	r25, Y+2	; 0x02
     2aa:	02 96       	adiw	r24, 0x02	; 2
     2ac:	0e 94 c3 04 	call	0x986	; 0x986 <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
     2b0:	e9 81       	ldd	r30, Y+1	; 0x01
     2b2:	fa 81       	ldd	r31, Y+2	; 0x02
     2b4:	96 89       	ldd	r25, Z+22	; 0x16
     2b6:	80 91 70 00 	lds	r24, 0x0070
     2ba:	89 17       	cp	r24, r25
     2bc:	28 f4       	brcc	.+10     	; 0x2c8 <prvCheckPendingReadyList+0x4c>
     2be:	e9 81       	ldd	r30, Y+1	; 0x01
     2c0:	fa 81       	ldd	r31, Y+2	; 0x02
     2c2:	86 89       	ldd	r24, Z+22	; 0x16
     2c4:	80 93 70 00 	sts	0x0070, r24
     2c8:	e9 81       	ldd	r30, Y+1	; 0x01
     2ca:	fa 81       	ldd	r31, Y+2	; 0x02
     2cc:	86 89       	ldd	r24, Z+22	; 0x16
     2ce:	28 2f       	mov	r18, r24
     2d0:	30 e0       	ldi	r19, 0x00	; 0
     2d2:	c9 01       	movw	r24, r18
     2d4:	88 0f       	add	r24, r24
     2d6:	99 1f       	adc	r25, r25
     2d8:	88 0f       	add	r24, r24
     2da:	99 1f       	adc	r25, r25
     2dc:	88 0f       	add	r24, r24
     2de:	99 1f       	adc	r25, r25
     2e0:	82 0f       	add	r24, r18
     2e2:	93 1f       	adc	r25, r19
     2e4:	ac 01       	movw	r20, r24
     2e6:	49 58       	subi	r20, 0x89	; 137
     2e8:	5f 4f       	sbci	r21, 0xFF	; 255
     2ea:	89 81       	ldd	r24, Y+1	; 0x01
     2ec:	9a 81       	ldd	r25, Y+2	; 0x02
     2ee:	9c 01       	movw	r18, r24
     2f0:	2e 5f       	subi	r18, 0xFE	; 254
     2f2:	3f 4f       	sbci	r19, 0xFF	; 255
     2f4:	ca 01       	movw	r24, r20
     2f6:	b9 01       	movw	r22, r18
     2f8:	0e 94 0b 04 	call	0x816	; 0x816 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     2fc:	80 91 9f 00 	lds	r24, 0x009F
     300:	88 23       	and	r24, r24
     302:	09 f0       	breq	.+2      	; 0x306 <prvCheckPendingReadyList+0x8a>
     304:	c1 cf       	rjmp	.-126    	; 0x288 <prvCheckPendingReadyList+0xc>
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
	}
}
     306:	0f 90       	pop	r0
     308:	0f 90       	pop	r0
     30a:	cf 91       	pop	r28
     30c:	df 91       	pop	r29
     30e:	08 95       	ret

00000310 <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
     310:	df 93       	push	r29
     312:	cf 93       	push	r28
     314:	00 d0       	rcall	.+0      	; 0x316 <prvCheckDelayedList+0x6>
     316:	00 d0       	rcall	.+0      	; 0x318 <prvCheckDelayedList+0x8>
     318:	cd b7       	in	r28, 0x3d	; 61
     31a:	de b7       	in	r29, 0x3e	; 62
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
     31c:	0e 94 ce 10 	call	0x219c	; 0x219c <xTaskGetTickCount>
     320:	20 91 73 00 	lds	r18, 0x0073
     324:	30 91 74 00 	lds	r19, 0x0074
     328:	82 1b       	sub	r24, r18
     32a:	93 0b       	sbc	r25, r19
     32c:	90 93 76 00 	sts	0x0076, r25
     330:	80 93 75 00 	sts	0x0075, r24
     334:	85 c0       	rjmp	.+266    	; 0x440 <prvCheckDelayedList+0x130>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
     336:	80 91 71 00 	lds	r24, 0x0071
     33a:	90 91 72 00 	lds	r25, 0x0072
     33e:	01 96       	adiw	r24, 0x01	; 1
     340:	90 93 72 00 	sts	0x0072, r25
     344:	80 93 71 00 	sts	0x0071, r24
		xPassedTicks--;
     348:	80 91 75 00 	lds	r24, 0x0075
     34c:	90 91 76 00 	lds	r25, 0x0076
     350:	01 97       	sbiw	r24, 0x01	; 1
     352:	90 93 76 00 	sts	0x0076, r25
     356:	80 93 75 00 	sts	0x0075, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
     35a:	80 91 71 00 	lds	r24, 0x0071
     35e:	90 91 72 00 	lds	r25, 0x0072
     362:	00 97       	sbiw	r24, 0x00	; 0
     364:	09 f0       	breq	.+2      	; 0x368 <prvCheckDelayedList+0x58>
     366:	64 c0       	rjmp	.+200    	; 0x430 <prvCheckDelayedList+0x120>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
     368:	80 91 9b 00 	lds	r24, 0x009B
     36c:	90 91 9c 00 	lds	r25, 0x009C
     370:	9a 83       	std	Y+2, r25	; 0x02
     372:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
     374:	80 91 9d 00 	lds	r24, 0x009D
     378:	90 91 9e 00 	lds	r25, 0x009E
     37c:	90 93 9c 00 	sts	0x009C, r25
     380:	80 93 9b 00 	sts	0x009B, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
     384:	89 81       	ldd	r24, Y+1	; 0x01
     386:	9a 81       	ldd	r25, Y+2	; 0x02
     388:	90 93 9e 00 	sts	0x009E, r25
     38c:	80 93 9d 00 	sts	0x009D, r24
     390:	4f c0       	rjmp	.+158    	; 0x430 <prvCheckDelayedList+0x120>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     392:	e0 91 9b 00 	lds	r30, 0x009B
     396:	f0 91 9c 00 	lds	r31, 0x009C
     39a:	05 80       	ldd	r0, Z+5	; 0x05
     39c:	f6 81       	ldd	r31, Z+6	; 0x06
     39e:	e0 2d       	mov	r30, r0
     3a0:	86 81       	ldd	r24, Z+6	; 0x06
     3a2:	97 81       	ldd	r25, Z+7	; 0x07
     3a4:	9c 83       	std	Y+4, r25	; 0x04
     3a6:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
     3a8:	eb 81       	ldd	r30, Y+3	; 0x03
     3aa:	fc 81       	ldd	r31, Y+4	; 0x04
     3ac:	22 81       	ldd	r18, Z+2	; 0x02
     3ae:	33 81       	ldd	r19, Z+3	; 0x03
     3b0:	80 91 71 00 	lds	r24, 0x0071
     3b4:	90 91 72 00 	lds	r25, 0x0072
     3b8:	82 17       	cp	r24, r18
     3ba:	93 07       	cpc	r25, r19
     3bc:	08 f4       	brcc	.+2      	; 0x3c0 <prvCheckDelayedList+0xb0>
     3be:	40 c0       	rjmp	.+128    	; 0x440 <prvCheckDelayedList+0x130>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
     3c0:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
     3c2:	8b 81       	ldd	r24, Y+3	; 0x03
     3c4:	9c 81       	ldd	r25, Y+4	; 0x04
     3c6:	02 96       	adiw	r24, 0x02	; 2
     3c8:	0e 94 c3 04 	call	0x986	; 0x986 <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
     3cc:	eb 81       	ldd	r30, Y+3	; 0x03
     3ce:	fc 81       	ldd	r31, Y+4	; 0x04
     3d0:	84 89       	ldd	r24, Z+20	; 0x14
     3d2:	95 89       	ldd	r25, Z+21	; 0x15
     3d4:	00 97       	sbiw	r24, 0x00	; 0
     3d6:	29 f0       	breq	.+10     	; 0x3e2 <prvCheckDelayedList+0xd2>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
     3d8:	8b 81       	ldd	r24, Y+3	; 0x03
     3da:	9c 81       	ldd	r25, Y+4	; 0x04
     3dc:	0c 96       	adiw	r24, 0x0c	; 12
     3de:	0e 94 c3 04 	call	0x986	; 0x986 <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
     3e2:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
     3e4:	eb 81       	ldd	r30, Y+3	; 0x03
     3e6:	fc 81       	ldd	r31, Y+4	; 0x04
     3e8:	96 89       	ldd	r25, Z+22	; 0x16
     3ea:	80 91 70 00 	lds	r24, 0x0070
     3ee:	89 17       	cp	r24, r25
     3f0:	28 f4       	brcc	.+10     	; 0x3fc <prvCheckDelayedList+0xec>
     3f2:	eb 81       	ldd	r30, Y+3	; 0x03
     3f4:	fc 81       	ldd	r31, Y+4	; 0x04
     3f6:	86 89       	ldd	r24, Z+22	; 0x16
     3f8:	80 93 70 00 	sts	0x0070, r24
     3fc:	eb 81       	ldd	r30, Y+3	; 0x03
     3fe:	fc 81       	ldd	r31, Y+4	; 0x04
     400:	86 89       	ldd	r24, Z+22	; 0x16
     402:	28 2f       	mov	r18, r24
     404:	30 e0       	ldi	r19, 0x00	; 0
     406:	c9 01       	movw	r24, r18
     408:	88 0f       	add	r24, r24
     40a:	99 1f       	adc	r25, r25
     40c:	88 0f       	add	r24, r24
     40e:	99 1f       	adc	r25, r25
     410:	88 0f       	add	r24, r24
     412:	99 1f       	adc	r25, r25
     414:	82 0f       	add	r24, r18
     416:	93 1f       	adc	r25, r19
     418:	ac 01       	movw	r20, r24
     41a:	49 58       	subi	r20, 0x89	; 137
     41c:	5f 4f       	sbci	r21, 0xFF	; 255
     41e:	8b 81       	ldd	r24, Y+3	; 0x03
     420:	9c 81       	ldd	r25, Y+4	; 0x04
     422:	9c 01       	movw	r18, r24
     424:	2e 5f       	subi	r18, 0xFE	; 254
     426:	3f 4f       	sbci	r19, 0xFF	; 255
     428:	ca 01       	movw	r24, r20
     42a:	b9 01       	movw	r22, r18
     42c:	0e 94 0b 04 	call	0x816	; 0x816 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     430:	e0 91 9b 00 	lds	r30, 0x009B
     434:	f0 91 9c 00 	lds	r31, 0x009C
     438:	80 81       	ld	r24, Z
     43a:	88 23       	and	r24, r24
     43c:	09 f0       	breq	.+2      	; 0x440 <prvCheckDelayedList+0x130>
     43e:	a9 cf       	rjmp	.-174    	; 0x392 <prvCheckDelayedList+0x82>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
     440:	80 91 75 00 	lds	r24, 0x0075
     444:	90 91 76 00 	lds	r25, 0x0076
     448:	00 97       	sbiw	r24, 0x00	; 0
     44a:	09 f0       	breq	.+2      	; 0x44e <prvCheckDelayedList+0x13e>
     44c:	74 cf       	rjmp	.-280    	; 0x336 <prvCheckDelayedList+0x26>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
     44e:	80 91 71 00 	lds	r24, 0x0071
     452:	90 91 72 00 	lds	r25, 0x0072
     456:	90 93 74 00 	sts	0x0074, r25
     45a:	80 93 73 00 	sts	0x0073, r24
}
     45e:	0f 90       	pop	r0
     460:	0f 90       	pop	r0
     462:	0f 90       	pop	r0
     464:	0f 90       	pop	r0
     466:	cf 91       	pop	r28
     468:	df 91       	pop	r29
     46a:	08 95       	ret

0000046c <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
     46c:	df 93       	push	r29
     46e:	cf 93       	push	r28
     470:	00 d0       	rcall	.+0      	; 0x472 <vCoRoutineSchedule+0x6>
     472:	cd b7       	in	r28, 0x3d	; 61
     474:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
     476:	0e 94 3e 01 	call	0x27c	; 0x27c <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
     47a:	0e 94 88 01 	call	0x310	; 0x310 <prvCheckDelayedList>
     47e:	0a c0       	rjmp	.+20     	; 0x494 <vCoRoutineSchedule+0x28>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
     480:	80 91 70 00 	lds	r24, 0x0070
     484:	88 23       	and	r24, r24
     486:	09 f4       	brne	.+2      	; 0x48a <vCoRoutineSchedule+0x1e>
     488:	66 c0       	rjmp	.+204    	; 0x556 <vCoRoutineSchedule+0xea>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
     48a:	80 91 70 00 	lds	r24, 0x0070
     48e:	81 50       	subi	r24, 0x01	; 1
     490:	80 93 70 00 	sts	0x0070, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     494:	80 91 70 00 	lds	r24, 0x0070
     498:	28 2f       	mov	r18, r24
     49a:	30 e0       	ldi	r19, 0x00	; 0
     49c:	c9 01       	movw	r24, r18
     49e:	88 0f       	add	r24, r24
     4a0:	99 1f       	adc	r25, r25
     4a2:	88 0f       	add	r24, r24
     4a4:	99 1f       	adc	r25, r25
     4a6:	88 0f       	add	r24, r24
     4a8:	99 1f       	adc	r25, r25
     4aa:	82 0f       	add	r24, r18
     4ac:	93 1f       	adc	r25, r19
     4ae:	fc 01       	movw	r30, r24
     4b0:	e9 58       	subi	r30, 0x89	; 137
     4b2:	ff 4f       	sbci	r31, 0xFF	; 255
     4b4:	80 81       	ld	r24, Z
     4b6:	88 23       	and	r24, r24
     4b8:	19 f3       	breq	.-58     	; 0x480 <vCoRoutineSchedule+0x14>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
     4ba:	80 91 70 00 	lds	r24, 0x0070
     4be:	28 2f       	mov	r18, r24
     4c0:	30 e0       	ldi	r19, 0x00	; 0
     4c2:	c9 01       	movw	r24, r18
     4c4:	88 0f       	add	r24, r24
     4c6:	99 1f       	adc	r25, r25
     4c8:	88 0f       	add	r24, r24
     4ca:	99 1f       	adc	r25, r25
     4cc:	88 0f       	add	r24, r24
     4ce:	99 1f       	adc	r25, r25
     4d0:	82 0f       	add	r24, r18
     4d2:	93 1f       	adc	r25, r19
     4d4:	89 58       	subi	r24, 0x89	; 137
     4d6:	9f 4f       	sbci	r25, 0xFF	; 255
     4d8:	9a 83       	std	Y+2, r25	; 0x02
     4da:	89 83       	std	Y+1, r24	; 0x01
     4dc:	e9 81       	ldd	r30, Y+1	; 0x01
     4de:	fa 81       	ldd	r31, Y+2	; 0x02
     4e0:	01 80       	ldd	r0, Z+1	; 0x01
     4e2:	f2 81       	ldd	r31, Z+2	; 0x02
     4e4:	e0 2d       	mov	r30, r0
     4e6:	82 81       	ldd	r24, Z+2	; 0x02
     4e8:	93 81       	ldd	r25, Z+3	; 0x03
     4ea:	e9 81       	ldd	r30, Y+1	; 0x01
     4ec:	fa 81       	ldd	r31, Y+2	; 0x02
     4ee:	92 83       	std	Z+2, r25	; 0x02
     4f0:	81 83       	std	Z+1, r24	; 0x01
     4f2:	e9 81       	ldd	r30, Y+1	; 0x01
     4f4:	fa 81       	ldd	r31, Y+2	; 0x02
     4f6:	21 81       	ldd	r18, Z+1	; 0x01
     4f8:	32 81       	ldd	r19, Z+2	; 0x02
     4fa:	89 81       	ldd	r24, Y+1	; 0x01
     4fc:	9a 81       	ldd	r25, Y+2	; 0x02
     4fe:	03 96       	adiw	r24, 0x03	; 3
     500:	28 17       	cp	r18, r24
     502:	39 07       	cpc	r19, r25
     504:	59 f4       	brne	.+22     	; 0x51c <vCoRoutineSchedule+0xb0>
     506:	e9 81       	ldd	r30, Y+1	; 0x01
     508:	fa 81       	ldd	r31, Y+2	; 0x02
     50a:	01 80       	ldd	r0, Z+1	; 0x01
     50c:	f2 81       	ldd	r31, Z+2	; 0x02
     50e:	e0 2d       	mov	r30, r0
     510:	82 81       	ldd	r24, Z+2	; 0x02
     512:	93 81       	ldd	r25, Z+3	; 0x03
     514:	e9 81       	ldd	r30, Y+1	; 0x01
     516:	fa 81       	ldd	r31, Y+2	; 0x02
     518:	92 83       	std	Z+2, r25	; 0x02
     51a:	81 83       	std	Z+1, r24	; 0x01
     51c:	e9 81       	ldd	r30, Y+1	; 0x01
     51e:	fa 81       	ldd	r31, Y+2	; 0x02
     520:	01 80       	ldd	r0, Z+1	; 0x01
     522:	f2 81       	ldd	r31, Z+2	; 0x02
     524:	e0 2d       	mov	r30, r0
     526:	86 81       	ldd	r24, Z+6	; 0x06
     528:	97 81       	ldd	r25, Z+7	; 0x07
     52a:	90 93 6f 00 	sts	0x006F, r25
     52e:	80 93 6e 00 	sts	0x006E, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
     532:	e0 91 6e 00 	lds	r30, 0x006E
     536:	f0 91 6f 00 	lds	r31, 0x006F
     53a:	40 81       	ld	r20, Z
     53c:	51 81       	ldd	r21, Z+1	; 0x01
     53e:	80 91 6e 00 	lds	r24, 0x006E
     542:	90 91 6f 00 	lds	r25, 0x006F
     546:	e0 91 6e 00 	lds	r30, 0x006E
     54a:	f0 91 6f 00 	lds	r31, 0x006F
     54e:	27 89       	ldd	r18, Z+23	; 0x17
     550:	62 2f       	mov	r22, r18
     552:	fa 01       	movw	r30, r20
     554:	09 95       	icall

	return;
}
     556:	0f 90       	pop	r0
     558:	0f 90       	pop	r0
     55a:	cf 91       	pop	r28
     55c:	df 91       	pop	r29
     55e:	08 95       	ret

00000560 <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
     560:	df 93       	push	r29
     562:	cf 93       	push	r28
     564:	0f 92       	push	r0
     566:	cd b7       	in	r28, 0x3d	; 61
     568:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
     56a:	19 82       	std	Y+1, r1	; 0x01
     56c:	13 c0       	rjmp	.+38     	; 0x594 <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
     56e:	89 81       	ldd	r24, Y+1	; 0x01
     570:	28 2f       	mov	r18, r24
     572:	30 e0       	ldi	r19, 0x00	; 0
     574:	c9 01       	movw	r24, r18
     576:	88 0f       	add	r24, r24
     578:	99 1f       	adc	r25, r25
     57a:	88 0f       	add	r24, r24
     57c:	99 1f       	adc	r25, r25
     57e:	88 0f       	add	r24, r24
     580:	99 1f       	adc	r25, r25
     582:	82 0f       	add	r24, r18
     584:	93 1f       	adc	r25, r19
     586:	89 58       	subi	r24, 0x89	; 137
     588:	9f 4f       	sbci	r25, 0xFF	; 255
     58a:	0e 94 d1 03 	call	0x7a2	; 0x7a2 <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
     58e:	89 81       	ldd	r24, Y+1	; 0x01
     590:	8f 5f       	subi	r24, 0xFF	; 255
     592:	89 83       	std	Y+1, r24	; 0x01
     594:	89 81       	ldd	r24, Y+1	; 0x01
     596:	82 30       	cpi	r24, 0x02	; 2
     598:	50 f3       	brcs	.-44     	; 0x56e <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
     59a:	89 e8       	ldi	r24, 0x89	; 137
     59c:	90 e0       	ldi	r25, 0x00	; 0
     59e:	0e 94 d1 03 	call	0x7a2	; 0x7a2 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
     5a2:	82 e9       	ldi	r24, 0x92	; 146
     5a4:	90 e0       	ldi	r25, 0x00	; 0
     5a6:	0e 94 d1 03 	call	0x7a2	; 0x7a2 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
     5aa:	8f e9       	ldi	r24, 0x9F	; 159
     5ac:	90 e0       	ldi	r25, 0x00	; 0
     5ae:	0e 94 d1 03 	call	0x7a2	; 0x7a2 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
     5b2:	89 e8       	ldi	r24, 0x89	; 137
     5b4:	90 e0       	ldi	r25, 0x00	; 0
     5b6:	90 93 9c 00 	sts	0x009C, r25
     5ba:	80 93 9b 00 	sts	0x009B, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
     5be:	82 e9       	ldi	r24, 0x92	; 146
     5c0:	90 e0       	ldi	r25, 0x00	; 0
     5c2:	90 93 9e 00 	sts	0x009E, r25
     5c6:	80 93 9d 00 	sts	0x009D, r24
}
     5ca:	0f 90       	pop	r0
     5cc:	cf 91       	pop	r28
     5ce:	df 91       	pop	r29
     5d0:	08 95       	ret

000005d2 <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
     5d2:	df 93       	push	r29
     5d4:	cf 93       	push	r28
     5d6:	00 d0       	rcall	.+0      	; 0x5d8 <xCoRoutineRemoveFromEventList+0x6>
     5d8:	00 d0       	rcall	.+0      	; 0x5da <xCoRoutineRemoveFromEventList+0x8>
     5da:	0f 92       	push	r0
     5dc:	cd b7       	in	r28, 0x3d	; 61
     5de:	de b7       	in	r29, 0x3e	; 62
     5e0:	9d 83       	std	Y+5, r25	; 0x05
     5e2:	8c 83       	std	Y+4, r24	; 0x04
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     5e4:	ec 81       	ldd	r30, Y+4	; 0x04
     5e6:	fd 81       	ldd	r31, Y+5	; 0x05
     5e8:	05 80       	ldd	r0, Z+5	; 0x05
     5ea:	f6 81       	ldd	r31, Z+6	; 0x06
     5ec:	e0 2d       	mov	r30, r0
     5ee:	86 81       	ldd	r24, Z+6	; 0x06
     5f0:	97 81       	ldd	r25, Z+7	; 0x07
     5f2:	9b 83       	std	Y+3, r25	; 0x03
     5f4:	8a 83       	std	Y+2, r24	; 0x02
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     5f6:	8a 81       	ldd	r24, Y+2	; 0x02
     5f8:	9b 81       	ldd	r25, Y+3	; 0x03
     5fa:	0c 96       	adiw	r24, 0x0c	; 12
     5fc:	0e 94 c3 04 	call	0x986	; 0x986 <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
     600:	8a 81       	ldd	r24, Y+2	; 0x02
     602:	9b 81       	ldd	r25, Y+3	; 0x03
     604:	9c 01       	movw	r18, r24
     606:	24 5f       	subi	r18, 0xF4	; 244
     608:	3f 4f       	sbci	r19, 0xFF	; 255
     60a:	8f e9       	ldi	r24, 0x9F	; 159
     60c:	90 e0       	ldi	r25, 0x00	; 0
     60e:	b9 01       	movw	r22, r18
     610:	0e 94 0b 04 	call	0x816	; 0x816 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
     614:	ea 81       	ldd	r30, Y+2	; 0x02
     616:	fb 81       	ldd	r31, Y+3	; 0x03
     618:	96 89       	ldd	r25, Z+22	; 0x16
     61a:	e0 91 6e 00 	lds	r30, 0x006E
     61e:	f0 91 6f 00 	lds	r31, 0x006F
     622:	86 89       	ldd	r24, Z+22	; 0x16
     624:	98 17       	cp	r25, r24
     626:	18 f0       	brcs	.+6      	; 0x62e <xCoRoutineRemoveFromEventList+0x5c>
	{
		xReturn = pdTRUE;
     628:	81 e0       	ldi	r24, 0x01	; 1
     62a:	89 83       	std	Y+1, r24	; 0x01
     62c:	01 c0       	rjmp	.+2      	; 0x630 <xCoRoutineRemoveFromEventList+0x5e>
	}
	else
	{
		xReturn = pdFALSE;
     62e:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
     630:	89 81       	ldd	r24, Y+1	; 0x01
}
     632:	0f 90       	pop	r0
     634:	0f 90       	pop	r0
     636:	0f 90       	pop	r0
     638:	0f 90       	pop	r0
     63a:	0f 90       	pop	r0
     63c:	cf 91       	pop	r28
     63e:	df 91       	pop	r29
     640:	08 95       	ret

00000642 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     642:	df 93       	push	r29
     644:	cf 93       	push	r28
     646:	00 d0       	rcall	.+0      	; 0x648 <pvPortMalloc+0x6>
     648:	00 d0       	rcall	.+0      	; 0x64a <pvPortMalloc+0x8>
     64a:	cd b7       	in	r28, 0x3d	; 61
     64c:	de b7       	in	r29, 0x3e	; 62
     64e:	9c 83       	std	Y+4, r25	; 0x04
     650:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL; 
     652:	1a 82       	std	Y+2, r1	; 0x02
     654:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     656:	0e 94 38 10 	call	0x2070	; 0x2070 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
     65a:	80 91 a8 00 	lds	r24, 0x00A8
     65e:	90 91 a9 00 	lds	r25, 0x00A9
     662:	2b 81       	ldd	r18, Y+3	; 0x03
     664:	3c 81       	ldd	r19, Y+4	; 0x04
     666:	82 0f       	add	r24, r18
     668:	93 1f       	adc	r25, r19
     66a:	22 e0       	ldi	r18, 0x02	; 2
     66c:	88 35       	cpi	r24, 0x58	; 88
     66e:	92 07       	cpc	r25, r18
     670:	18 f5       	brcc	.+70     	; 0x6b8 <pvPortMalloc+0x76>
     672:	20 91 a8 00 	lds	r18, 0x00A8
     676:	30 91 a9 00 	lds	r19, 0x00A9
     67a:	8b 81       	ldd	r24, Y+3	; 0x03
     67c:	9c 81       	ldd	r25, Y+4	; 0x04
     67e:	28 0f       	add	r18, r24
     680:	39 1f       	adc	r19, r25
     682:	80 91 a8 00 	lds	r24, 0x00A8
     686:	90 91 a9 00 	lds	r25, 0x00A9
     68a:	82 17       	cp	r24, r18
     68c:	93 07       	cpc	r25, r19
     68e:	a0 f4       	brcc	.+40     	; 0x6b8 <pvPortMalloc+0x76>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
     690:	80 91 a8 00 	lds	r24, 0x00A8
     694:	90 91 a9 00 	lds	r25, 0x00A9
     698:	86 55       	subi	r24, 0x56	; 86
     69a:	9f 4f       	sbci	r25, 0xFF	; 255
     69c:	9a 83       	std	Y+2, r25	; 0x02
     69e:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;			
     6a0:	20 91 a8 00 	lds	r18, 0x00A8
     6a4:	30 91 a9 00 	lds	r19, 0x00A9
     6a8:	8b 81       	ldd	r24, Y+3	; 0x03
     6aa:	9c 81       	ldd	r25, Y+4	; 0x04
     6ac:	82 0f       	add	r24, r18
     6ae:	93 1f       	adc	r25, r19
     6b0:	90 93 a9 00 	sts	0x00A9, r25
     6b4:	80 93 a8 00 	sts	0x00A8, r24
		}	
	}
	xTaskResumeAll();
     6b8:	0e 94 44 10 	call	0x2088	; 0x2088 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif	

	return pvReturn;
     6bc:	89 81       	ldd	r24, Y+1	; 0x01
     6be:	9a 81       	ldd	r25, Y+2	; 0x02
}
     6c0:	0f 90       	pop	r0
     6c2:	0f 90       	pop	r0
     6c4:	0f 90       	pop	r0
     6c6:	0f 90       	pop	r0
     6c8:	cf 91       	pop	r28
     6ca:	df 91       	pop	r29
     6cc:	08 95       	ret

000006ce <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     6ce:	df 93       	push	r29
     6d0:	cf 93       	push	r28
     6d2:	00 d0       	rcall	.+0      	; 0x6d4 <vPortFree+0x6>
     6d4:	cd b7       	in	r28, 0x3d	; 61
     6d6:	de b7       	in	r29, 0x3e	; 62
     6d8:	9a 83       	std	Y+2, r25	; 0x02
     6da:	89 83       	std	Y+1, r24	; 0x01
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
     6dc:	0f 90       	pop	r0
     6de:	0f 90       	pop	r0
     6e0:	cf 91       	pop	r28
     6e2:	df 91       	pop	r29
     6e4:	08 95       	ret

000006e6 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
     6e6:	df 93       	push	r29
     6e8:	cf 93       	push	r28
     6ea:	cd b7       	in	r28, 0x3d	; 61
     6ec:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
     6ee:	10 92 a9 00 	sts	0x00A9, r1
     6f2:	10 92 a8 00 	sts	0x00A8, r1
}
     6f6:	cf 91       	pop	r28
     6f8:	df 91       	pop	r29
     6fa:	08 95       	ret

000006fc <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
     6fc:	df 93       	push	r29
     6fe:	cf 93       	push	r28
     700:	cd b7       	in	r28, 0x3d	; 61
     702:	de b7       	in	r29, 0x3e	; 62
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
     704:	20 91 a8 00 	lds	r18, 0x00A8
     708:	30 91 a9 00 	lds	r19, 0x00A9
     70c:	88 e5       	ldi	r24, 0x58	; 88
     70e:	92 e0       	ldi	r25, 0x02	; 2
     710:	82 1b       	sub	r24, r18
     712:	93 0b       	sbc	r25, r19
}
     714:	cf 91       	pop	r28
     716:	df 91       	pop	r29
     718:	08 95       	ret

0000071a <Init_External_Interrupt>:
 *      Author: mody
 */

#include "init_external_interrupt.h"
void Init_External_Interrupt (void)
{
     71a:	df 93       	push	r29
     71c:	cf 93       	push	r28
     71e:	cd b7       	in	r28, 0x3d	; 61
     720:	de b7       	in	r29, 0x3e	; 62

	DDRD &=~(1<<2);//set as an i/p
     722:	a1 e3       	ldi	r26, 0x31	; 49
     724:	b0 e0       	ldi	r27, 0x00	; 0
     726:	e1 e3       	ldi	r30, 0x31	; 49
     728:	f0 e0       	ldi	r31, 0x00	; 0
     72a:	80 81       	ld	r24, Z
     72c:	8b 7f       	andi	r24, 0xFB	; 251
     72e:	8c 93       	st	X, r24
	PORTD|=(1<<2);//make it high to take low signal
     730:	a2 e3       	ldi	r26, 0x32	; 50
     732:	b0 e0       	ldi	r27, 0x00	; 0
     734:	e2 e3       	ldi	r30, 0x32	; 50
     736:	f0 e0       	ldi	r31, 0x00	; 0
     738:	80 81       	ld	r24, Z
     73a:	84 60       	ori	r24, 0x04	; 4
     73c:	8c 93       	st	X, r24
	GICR=1<<INT0;//select the interrupt
     73e:	eb e5       	ldi	r30, 0x5B	; 91
     740:	f0 e0       	ldi	r31, 0x00	; 0
     742:	80 e4       	ldi	r24, 0x40	; 64
     744:	80 83       	st	Z, r24

	sei();//to enable interrupt
     746:	78 94       	sei
}
     748:	cf 91       	pop	r28
     74a:	df 91       	pop	r29
     74c:	08 95       	ret

0000074e <Init_io>:

#define DDR_PORT_OUT 	DDRA
#define PORT_OUT 		PORTA

void Init_io (void)
{
     74e:	df 93       	push	r29
     750:	cf 93       	push	r28
     752:	cd b7       	in	r28, 0x3d	; 61
     754:	de b7       	in	r29, 0x3e	; 62
	/*Set Port B as input*/
	DDR_PORT_IN=0x00;
     756:	e7 e3       	ldi	r30, 0x37	; 55
     758:	f0 e0       	ldi	r31, 0x00	; 0
     75a:	10 82       	st	Z, r1
	/*Make it high*/
	PORT_IN=0xFF;
     75c:	e8 e3       	ldi	r30, 0x38	; 56
     75e:	f0 e0       	ldi	r31, 0x00	; 0
     760:	8f ef       	ldi	r24, 0xFF	; 255
     762:	80 83       	st	Z, r24
	/*Set PORT A as an output*/
	DDR_PORT_OUT=0xFF;
     764:	ea e3       	ldi	r30, 0x3A	; 58
     766:	f0 e0       	ldi	r31, 0x00	; 0
     768:	8f ef       	ldi	r24, 0xFF	; 255
     76a:	80 83       	st	Z, r24
}
     76c:	cf 91       	pop	r28
     76e:	df 91       	pop	r29
     770:	08 95       	ret

00000772 <input>:

unsigned char input(void)
{
     772:	df 93       	push	r29
     774:	cf 93       	push	r28
     776:	cd b7       	in	r28, 0x3d	; 61
     778:	de b7       	in	r29, 0x3e	; 62
	return PIN_PORT_IN;
     77a:	e6 e3       	ldi	r30, 0x36	; 54
     77c:	f0 e0       	ldi	r31, 0x00	; 0
     77e:	80 81       	ld	r24, Z
}
     780:	cf 91       	pop	r28
     782:	df 91       	pop	r29
     784:	08 95       	ret

00000786 <output>:

void output (unsigned char write)
{
     786:	df 93       	push	r29
     788:	cf 93       	push	r28
     78a:	0f 92       	push	r0
     78c:	cd b7       	in	r28, 0x3d	; 61
     78e:	de b7       	in	r29, 0x3e	; 62
     790:	89 83       	std	Y+1, r24	; 0x01
	PORT_OUT=write;
     792:	eb e3       	ldi	r30, 0x3B	; 59
     794:	f0 e0       	ldi	r31, 0x00	; 0
     796:	89 81       	ldd	r24, Y+1	; 0x01
     798:	80 83       	st	Z, r24
}
     79a:	0f 90       	pop	r0
     79c:	cf 91       	pop	r28
     79e:	df 91       	pop	r29
     7a0:	08 95       	ret

000007a2 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     7a2:	df 93       	push	r29
     7a4:	cf 93       	push	r28
     7a6:	00 d0       	rcall	.+0      	; 0x7a8 <vListInitialise+0x6>
     7a8:	cd b7       	in	r28, 0x3d	; 61
     7aa:	de b7       	in	r29, 0x3e	; 62
     7ac:	9a 83       	std	Y+2, r25	; 0x02
     7ae:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     7b0:	89 81       	ldd	r24, Y+1	; 0x01
     7b2:	9a 81       	ldd	r25, Y+2	; 0x02
     7b4:	03 96       	adiw	r24, 0x03	; 3
     7b6:	e9 81       	ldd	r30, Y+1	; 0x01
     7b8:	fa 81       	ldd	r31, Y+2	; 0x02
     7ba:	92 83       	std	Z+2, r25	; 0x02
     7bc:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     7be:	e9 81       	ldd	r30, Y+1	; 0x01
     7c0:	fa 81       	ldd	r31, Y+2	; 0x02
     7c2:	8f ef       	ldi	r24, 0xFF	; 255
     7c4:	9f ef       	ldi	r25, 0xFF	; 255
     7c6:	94 83       	std	Z+4, r25	; 0x04
     7c8:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     7ca:	89 81       	ldd	r24, Y+1	; 0x01
     7cc:	9a 81       	ldd	r25, Y+2	; 0x02
     7ce:	03 96       	adiw	r24, 0x03	; 3
     7d0:	e9 81       	ldd	r30, Y+1	; 0x01
     7d2:	fa 81       	ldd	r31, Y+2	; 0x02
     7d4:	96 83       	std	Z+6, r25	; 0x06
     7d6:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     7d8:	89 81       	ldd	r24, Y+1	; 0x01
     7da:	9a 81       	ldd	r25, Y+2	; 0x02
     7dc:	03 96       	adiw	r24, 0x03	; 3
     7de:	e9 81       	ldd	r30, Y+1	; 0x01
     7e0:	fa 81       	ldd	r31, Y+2	; 0x02
     7e2:	90 87       	std	Z+8, r25	; 0x08
     7e4:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
     7e6:	e9 81       	ldd	r30, Y+1	; 0x01
     7e8:	fa 81       	ldd	r31, Y+2	; 0x02
     7ea:	10 82       	st	Z, r1
}
     7ec:	0f 90       	pop	r0
     7ee:	0f 90       	pop	r0
     7f0:	cf 91       	pop	r28
     7f2:	df 91       	pop	r29
     7f4:	08 95       	ret

000007f6 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
     7f6:	df 93       	push	r29
     7f8:	cf 93       	push	r28
     7fa:	00 d0       	rcall	.+0      	; 0x7fc <vListInitialiseItem+0x6>
     7fc:	cd b7       	in	r28, 0x3d	; 61
     7fe:	de b7       	in	r29, 0x3e	; 62
     800:	9a 83       	std	Y+2, r25	; 0x02
     802:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     804:	e9 81       	ldd	r30, Y+1	; 0x01
     806:	fa 81       	ldd	r31, Y+2	; 0x02
     808:	11 86       	std	Z+9, r1	; 0x09
     80a:	10 86       	std	Z+8, r1	; 0x08
}
     80c:	0f 90       	pop	r0
     80e:	0f 90       	pop	r0
     810:	cf 91       	pop	r28
     812:	df 91       	pop	r29
     814:	08 95       	ret

00000816 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     816:	df 93       	push	r29
     818:	cf 93       	push	r28
     81a:	00 d0       	rcall	.+0      	; 0x81c <vListInsertEnd+0x6>
     81c:	00 d0       	rcall	.+0      	; 0x81e <vListInsertEnd+0x8>
     81e:	00 d0       	rcall	.+0      	; 0x820 <vListInsertEnd+0xa>
     820:	cd b7       	in	r28, 0x3d	; 61
     822:	de b7       	in	r29, 0x3e	; 62
     824:	9c 83       	std	Y+4, r25	; 0x04
     826:	8b 83       	std	Y+3, r24	; 0x03
     828:	7e 83       	std	Y+6, r23	; 0x06
     82a:	6d 83       	std	Y+5, r22	; 0x05

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     82c:	eb 81       	ldd	r30, Y+3	; 0x03
     82e:	fc 81       	ldd	r31, Y+4	; 0x04
     830:	81 81       	ldd	r24, Z+1	; 0x01
     832:	92 81       	ldd	r25, Z+2	; 0x02
     834:	9a 83       	std	Y+2, r25	; 0x02
     836:	89 83       	std	Y+1, r24	; 0x01

	pxNewListItem->pxNext = pxIndex->pxNext;
     838:	e9 81       	ldd	r30, Y+1	; 0x01
     83a:	fa 81       	ldd	r31, Y+2	; 0x02
     83c:	82 81       	ldd	r24, Z+2	; 0x02
     83e:	93 81       	ldd	r25, Z+3	; 0x03
     840:	ed 81       	ldd	r30, Y+5	; 0x05
     842:	fe 81       	ldd	r31, Y+6	; 0x06
     844:	93 83       	std	Z+3, r25	; 0x03
     846:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
     848:	eb 81       	ldd	r30, Y+3	; 0x03
     84a:	fc 81       	ldd	r31, Y+4	; 0x04
     84c:	81 81       	ldd	r24, Z+1	; 0x01
     84e:	92 81       	ldd	r25, Z+2	; 0x02
     850:	ed 81       	ldd	r30, Y+5	; 0x05
     852:	fe 81       	ldd	r31, Y+6	; 0x06
     854:	95 83       	std	Z+5, r25	; 0x05
     856:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     858:	e9 81       	ldd	r30, Y+1	; 0x01
     85a:	fa 81       	ldd	r31, Y+2	; 0x02
     85c:	02 80       	ldd	r0, Z+2	; 0x02
     85e:	f3 81       	ldd	r31, Z+3	; 0x03
     860:	e0 2d       	mov	r30, r0
     862:	8d 81       	ldd	r24, Y+5	; 0x05
     864:	9e 81       	ldd	r25, Y+6	; 0x06
     866:	95 83       	std	Z+5, r25	; 0x05
     868:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     86a:	8d 81       	ldd	r24, Y+5	; 0x05
     86c:	9e 81       	ldd	r25, Y+6	; 0x06
     86e:	e9 81       	ldd	r30, Y+1	; 0x01
     870:	fa 81       	ldd	r31, Y+2	; 0x02
     872:	93 83       	std	Z+3, r25	; 0x03
     874:	82 83       	std	Z+2, r24	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     876:	8d 81       	ldd	r24, Y+5	; 0x05
     878:	9e 81       	ldd	r25, Y+6	; 0x06
     87a:	eb 81       	ldd	r30, Y+3	; 0x03
     87c:	fc 81       	ldd	r31, Y+4	; 0x04
     87e:	92 83       	std	Z+2, r25	; 0x02
     880:	81 83       	std	Z+1, r24	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     882:	ed 81       	ldd	r30, Y+5	; 0x05
     884:	fe 81       	ldd	r31, Y+6	; 0x06
     886:	8b 81       	ldd	r24, Y+3	; 0x03
     888:	9c 81       	ldd	r25, Y+4	; 0x04
     88a:	91 87       	std	Z+9, r25	; 0x09
     88c:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     88e:	eb 81       	ldd	r30, Y+3	; 0x03
     890:	fc 81       	ldd	r31, Y+4	; 0x04
     892:	80 81       	ld	r24, Z
     894:	8f 5f       	subi	r24, 0xFF	; 255
     896:	eb 81       	ldd	r30, Y+3	; 0x03
     898:	fc 81       	ldd	r31, Y+4	; 0x04
     89a:	80 83       	st	Z, r24
}
     89c:	26 96       	adiw	r28, 0x06	; 6
     89e:	0f b6       	in	r0, 0x3f	; 63
     8a0:	f8 94       	cli
     8a2:	de bf       	out	0x3e, r29	; 62
     8a4:	0f be       	out	0x3f, r0	; 63
     8a6:	cd bf       	out	0x3d, r28	; 61
     8a8:	cf 91       	pop	r28
     8aa:	df 91       	pop	r29
     8ac:	08 95       	ret

000008ae <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
     8ae:	df 93       	push	r29
     8b0:	cf 93       	push	r28
     8b2:	cd b7       	in	r28, 0x3d	; 61
     8b4:	de b7       	in	r29, 0x3e	; 62
     8b6:	28 97       	sbiw	r28, 0x08	; 8
     8b8:	0f b6       	in	r0, 0x3f	; 63
     8ba:	f8 94       	cli
     8bc:	de bf       	out	0x3e, r29	; 62
     8be:	0f be       	out	0x3f, r0	; 63
     8c0:	cd bf       	out	0x3d, r28	; 61
     8c2:	9e 83       	std	Y+6, r25	; 0x06
     8c4:	8d 83       	std	Y+5, r24	; 0x05
     8c6:	78 87       	std	Y+8, r23	; 0x08
     8c8:	6f 83       	std	Y+7, r22	; 0x07
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
     8ca:	ef 81       	ldd	r30, Y+7	; 0x07
     8cc:	f8 85       	ldd	r31, Y+8	; 0x08
     8ce:	80 81       	ld	r24, Z
     8d0:	91 81       	ldd	r25, Z+1	; 0x01
     8d2:	9a 83       	std	Y+2, r25	; 0x02
     8d4:	89 83       	std	Y+1, r24	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     8d6:	89 81       	ldd	r24, Y+1	; 0x01
     8d8:	9a 81       	ldd	r25, Y+2	; 0x02
     8da:	2f ef       	ldi	r18, 0xFF	; 255
     8dc:	8f 3f       	cpi	r24, 0xFF	; 255
     8de:	92 07       	cpc	r25, r18
     8e0:	39 f4       	brne	.+14     	; 0x8f0 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     8e2:	ed 81       	ldd	r30, Y+5	; 0x05
     8e4:	fe 81       	ldd	r31, Y+6	; 0x06
     8e6:	87 81       	ldd	r24, Z+7	; 0x07
     8e8:	90 85       	ldd	r25, Z+8	; 0x08
     8ea:	9c 83       	std	Y+4, r25	; 0x04
     8ec:	8b 83       	std	Y+3, r24	; 0x03
     8ee:	18 c0       	rjmp	.+48     	; 0x920 <vListInsert+0x72>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     8f0:	8d 81       	ldd	r24, Y+5	; 0x05
     8f2:	9e 81       	ldd	r25, Y+6	; 0x06
     8f4:	03 96       	adiw	r24, 0x03	; 3
     8f6:	9c 83       	std	Y+4, r25	; 0x04
     8f8:	8b 83       	std	Y+3, r24	; 0x03
     8fa:	06 c0       	rjmp	.+12     	; 0x908 <vListInsert+0x5a>
     8fc:	eb 81       	ldd	r30, Y+3	; 0x03
     8fe:	fc 81       	ldd	r31, Y+4	; 0x04
     900:	82 81       	ldd	r24, Z+2	; 0x02
     902:	93 81       	ldd	r25, Z+3	; 0x03
     904:	9c 83       	std	Y+4, r25	; 0x04
     906:	8b 83       	std	Y+3, r24	; 0x03
     908:	eb 81       	ldd	r30, Y+3	; 0x03
     90a:	fc 81       	ldd	r31, Y+4	; 0x04
     90c:	02 80       	ldd	r0, Z+2	; 0x02
     90e:	f3 81       	ldd	r31, Z+3	; 0x03
     910:	e0 2d       	mov	r30, r0
     912:	20 81       	ld	r18, Z
     914:	31 81       	ldd	r19, Z+1	; 0x01
     916:	89 81       	ldd	r24, Y+1	; 0x01
     918:	9a 81       	ldd	r25, Y+2	; 0x02
     91a:	82 17       	cp	r24, r18
     91c:	93 07       	cpc	r25, r19
     91e:	70 f7       	brcc	.-36     	; 0x8fc <vListInsert+0x4e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     920:	eb 81       	ldd	r30, Y+3	; 0x03
     922:	fc 81       	ldd	r31, Y+4	; 0x04
     924:	82 81       	ldd	r24, Z+2	; 0x02
     926:	93 81       	ldd	r25, Z+3	; 0x03
     928:	ef 81       	ldd	r30, Y+7	; 0x07
     92a:	f8 85       	ldd	r31, Y+8	; 0x08
     92c:	93 83       	std	Z+3, r25	; 0x03
     92e:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     930:	ef 81       	ldd	r30, Y+7	; 0x07
     932:	f8 85       	ldd	r31, Y+8	; 0x08
     934:	02 80       	ldd	r0, Z+2	; 0x02
     936:	f3 81       	ldd	r31, Z+3	; 0x03
     938:	e0 2d       	mov	r30, r0
     93a:	8f 81       	ldd	r24, Y+7	; 0x07
     93c:	98 85       	ldd	r25, Y+8	; 0x08
     93e:	95 83       	std	Z+5, r25	; 0x05
     940:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     942:	ef 81       	ldd	r30, Y+7	; 0x07
     944:	f8 85       	ldd	r31, Y+8	; 0x08
     946:	8b 81       	ldd	r24, Y+3	; 0x03
     948:	9c 81       	ldd	r25, Y+4	; 0x04
     94a:	95 83       	std	Z+5, r25	; 0x05
     94c:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
     94e:	8f 81       	ldd	r24, Y+7	; 0x07
     950:	98 85       	ldd	r25, Y+8	; 0x08
     952:	eb 81       	ldd	r30, Y+3	; 0x03
     954:	fc 81       	ldd	r31, Y+4	; 0x04
     956:	93 83       	std	Z+3, r25	; 0x03
     958:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     95a:	ef 81       	ldd	r30, Y+7	; 0x07
     95c:	f8 85       	ldd	r31, Y+8	; 0x08
     95e:	8d 81       	ldd	r24, Y+5	; 0x05
     960:	9e 81       	ldd	r25, Y+6	; 0x06
     962:	91 87       	std	Z+9, r25	; 0x09
     964:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     966:	ed 81       	ldd	r30, Y+5	; 0x05
     968:	fe 81       	ldd	r31, Y+6	; 0x06
     96a:	80 81       	ld	r24, Z
     96c:	8f 5f       	subi	r24, 0xFF	; 255
     96e:	ed 81       	ldd	r30, Y+5	; 0x05
     970:	fe 81       	ldd	r31, Y+6	; 0x06
     972:	80 83       	st	Z, r24
}
     974:	28 96       	adiw	r28, 0x08	; 8
     976:	0f b6       	in	r0, 0x3f	; 63
     978:	f8 94       	cli
     97a:	de bf       	out	0x3e, r29	; 62
     97c:	0f be       	out	0x3f, r0	; 63
     97e:	cd bf       	out	0x3d, r28	; 61
     980:	cf 91       	pop	r28
     982:	df 91       	pop	r29
     984:	08 95       	ret

00000986 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
     986:	df 93       	push	r29
     988:	cf 93       	push	r28
     98a:	00 d0       	rcall	.+0      	; 0x98c <vListRemove+0x6>
     98c:	00 d0       	rcall	.+0      	; 0x98e <vListRemove+0x8>
     98e:	cd b7       	in	r28, 0x3d	; 61
     990:	de b7       	in	r29, 0x3e	; 62
     992:	9c 83       	std	Y+4, r25	; 0x04
     994:	8b 83       	std	Y+3, r24	; 0x03
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     996:	eb 81       	ldd	r30, Y+3	; 0x03
     998:	fc 81       	ldd	r31, Y+4	; 0x04
     99a:	a2 81       	ldd	r26, Z+2	; 0x02
     99c:	b3 81       	ldd	r27, Z+3	; 0x03
     99e:	eb 81       	ldd	r30, Y+3	; 0x03
     9a0:	fc 81       	ldd	r31, Y+4	; 0x04
     9a2:	84 81       	ldd	r24, Z+4	; 0x04
     9a4:	95 81       	ldd	r25, Z+5	; 0x05
     9a6:	15 96       	adiw	r26, 0x05	; 5
     9a8:	9c 93       	st	X, r25
     9aa:	8e 93       	st	-X, r24
     9ac:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     9ae:	eb 81       	ldd	r30, Y+3	; 0x03
     9b0:	fc 81       	ldd	r31, Y+4	; 0x04
     9b2:	a4 81       	ldd	r26, Z+4	; 0x04
     9b4:	b5 81       	ldd	r27, Z+5	; 0x05
     9b6:	eb 81       	ldd	r30, Y+3	; 0x03
     9b8:	fc 81       	ldd	r31, Y+4	; 0x04
     9ba:	82 81       	ldd	r24, Z+2	; 0x02
     9bc:	93 81       	ldd	r25, Z+3	; 0x03
     9be:	13 96       	adiw	r26, 0x03	; 3
     9c0:	9c 93       	st	X, r25
     9c2:	8e 93       	st	-X, r24
     9c4:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
     9c6:	eb 81       	ldd	r30, Y+3	; 0x03
     9c8:	fc 81       	ldd	r31, Y+4	; 0x04
     9ca:	80 85       	ldd	r24, Z+8	; 0x08
     9cc:	91 85       	ldd	r25, Z+9	; 0x09
     9ce:	9a 83       	std	Y+2, r25	; 0x02
     9d0:	89 83       	std	Y+1, r24	; 0x01

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     9d2:	e9 81       	ldd	r30, Y+1	; 0x01
     9d4:	fa 81       	ldd	r31, Y+2	; 0x02
     9d6:	21 81       	ldd	r18, Z+1	; 0x01
     9d8:	32 81       	ldd	r19, Z+2	; 0x02
     9da:	8b 81       	ldd	r24, Y+3	; 0x03
     9dc:	9c 81       	ldd	r25, Y+4	; 0x04
     9de:	28 17       	cp	r18, r24
     9e0:	39 07       	cpc	r19, r25
     9e2:	41 f4       	brne	.+16     	; 0x9f4 <vListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     9e4:	eb 81       	ldd	r30, Y+3	; 0x03
     9e6:	fc 81       	ldd	r31, Y+4	; 0x04
     9e8:	84 81       	ldd	r24, Z+4	; 0x04
     9ea:	95 81       	ldd	r25, Z+5	; 0x05
     9ec:	e9 81       	ldd	r30, Y+1	; 0x01
     9ee:	fa 81       	ldd	r31, Y+2	; 0x02
     9f0:	92 83       	std	Z+2, r25	; 0x02
     9f2:	81 83       	std	Z+1, r24	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
     9f4:	eb 81       	ldd	r30, Y+3	; 0x03
     9f6:	fc 81       	ldd	r31, Y+4	; 0x04
     9f8:	11 86       	std	Z+9, r1	; 0x09
     9fa:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     9fc:	e9 81       	ldd	r30, Y+1	; 0x01
     9fe:	fa 81       	ldd	r31, Y+2	; 0x02
     a00:	80 81       	ld	r24, Z
     a02:	81 50       	subi	r24, 0x01	; 1
     a04:	e9 81       	ldd	r30, Y+1	; 0x01
     a06:	fa 81       	ldd	r31, Y+2	; 0x02
     a08:	80 83       	st	Z, r24
}
     a0a:	0f 90       	pop	r0
     a0c:	0f 90       	pop	r0
     a0e:	0f 90       	pop	r0
     a10:	0f 90       	pop	r0
     a12:	cf 91       	pop	r28
     a14:	df 91       	pop	r29
     a16:	08 95       	ret

00000a18 <main>:
xQueueHandle myhandle;



int main( void )
{
     a18:	af 92       	push	r10
     a1a:	bf 92       	push	r11
     a1c:	cf 92       	push	r12
     a1e:	df 92       	push	r13
     a20:	ef 92       	push	r14
     a22:	ff 92       	push	r15
     a24:	0f 93       	push	r16
     a26:	df 93       	push	r29
     a28:	cf 93       	push	r28
     a2a:	cd b7       	in	r28, 0x3d	; 61
     a2c:	de b7       	in	r29, 0x3e	; 62
	/*Function to initialize the i/os*/
	Init_io();
     a2e:	0e 94 a7 03 	call	0x74e	; 0x74e <Init_io>
	Init_External_Interrupt();
     a32:	0e 94 8d 03 	call	0x71a	; 0x71a <Init_External_Interrupt>

	/*The tasks of the system*/
	xTaskCreate( pin_output, ( signed char * ) "output",
     a36:	20 e6       	ldi	r18, 0x60	; 96
     a38:	30 e0       	ldi	r19, 0x00	; 0
     a3a:	83 e4       	ldi	r24, 0x43	; 67
     a3c:	95 e0       	ldi	r25, 0x05	; 5
     a3e:	b9 01       	movw	r22, r18
     a40:	45 e5       	ldi	r20, 0x55	; 85
     a42:	50 e0       	ldi	r21, 0x00	; 0
     a44:	20 e0       	ldi	r18, 0x00	; 0
     a46:	30 e0       	ldi	r19, 0x00	; 0
     a48:	01 e0       	ldi	r16, 0x01	; 1
     a4a:	ee 24       	eor	r14, r14
     a4c:	ff 24       	eor	r15, r15
     a4e:	cc 24       	eor	r12, r12
     a50:	dd 24       	eor	r13, r13
     a52:	aa 24       	eor	r10, r10
     a54:	bb 24       	eor	r11, r11
     a56:	0e 94 fc 0d 	call	0x1bf8	; 0x1bf8 <xTaskGenericCreate>
			configMINIMAL_STACK_SIZE, NULL,
			PIN_OUTPUT, NULL );

	/*Specify the size of msg*/
	myhandle=xQueueCreate(1,sizeof(char*));
     a5a:	81 e0       	ldi	r24, 0x01	; 1
     a5c:	62 e0       	ldi	r22, 0x02	; 2
     a5e:	0e 94 67 08 	call	0x10ce	; 0x10ce <xQueueCreate>
     a62:	90 93 54 03 	sts	0x0354, r25
     a66:	80 93 53 03 	sts	0x0353, r24

	/*Start the Scheduler*/
	vTaskStartScheduler();
     a6a:	0e 94 f5 0f 	call	0x1fea	; 0x1fea <vTaskStartScheduler>
	return 0;
     a6e:	80 e0       	ldi	r24, 0x00	; 0
     a70:	90 e0       	ldi	r25, 0x00	; 0
}
     a72:	cf 91       	pop	r28
     a74:	df 91       	pop	r29
     a76:	0f 91       	pop	r16
     a78:	ff 90       	pop	r15
     a7a:	ef 90       	pop	r14
     a7c:	df 90       	pop	r13
     a7e:	cf 90       	pop	r12
     a80:	bf 90       	pop	r11
     a82:	af 90       	pop	r10
     a84:	08 95       	ret

00000a86 <pin_output>:
/*-----------------------------------------------------------*/


static void pin_output( void *pvParameters)
{
     a86:	df 93       	push	r29
     a88:	cf 93       	push	r28
     a8a:	00 d0       	rcall	.+0      	; 0xa8c <pin_output+0x6>
     a8c:	0f 92       	push	r0
     a8e:	cd b7       	in	r28, 0x3d	; 61
     a90:	de b7       	in	r29, 0x3e	; 62
     a92:	9b 83       	std	Y+3, r25	; 0x03
     a94:	8a 83       	std	Y+2, r24	; 0x02
	unsigned char port_value;
	while(1)
	{
		xQueueReceiveFromISR(myhandle, &port_value, portMAX_DELAY);
     a96:	80 91 53 03 	lds	r24, 0x0353
     a9a:	90 91 54 03 	lds	r25, 0x0354
     a9e:	9e 01       	movw	r18, r28
     aa0:	2f 5f       	subi	r18, 0xFF	; 255
     aa2:	3f 4f       	sbci	r19, 0xFF	; 255
     aa4:	b9 01       	movw	r22, r18
     aa6:	4f ef       	ldi	r20, 0xFF	; 255
     aa8:	5f ef       	ldi	r21, 0xFF	; 255
     aaa:	0e 94 be 0b 	call	0x177c	; 0x177c <xQueueReceiveFromISR>
		output(port_value);
     aae:	89 81       	ldd	r24, Y+1	; 0x01
     ab0:	0e 94 c3 03 	call	0x786	; 0x786 <output>
     ab4:	f0 cf       	rjmp	.-32     	; 0xa96 <pin_output+0x10>

00000ab6 <__vector_1>:

	}
}

ISR (INT0_vect)
{
     ab6:	1f 92       	push	r1
     ab8:	0f 92       	push	r0
     aba:	0f b6       	in	r0, 0x3f	; 63
     abc:	0f 92       	push	r0
     abe:	11 24       	eor	r1, r1
     ac0:	2f 93       	push	r18
     ac2:	3f 93       	push	r19
     ac4:	4f 93       	push	r20
     ac6:	5f 93       	push	r21
     ac8:	6f 93       	push	r22
     aca:	7f 93       	push	r23
     acc:	8f 93       	push	r24
     ace:	9f 93       	push	r25
     ad0:	af 93       	push	r26
     ad2:	bf 93       	push	r27
     ad4:	ef 93       	push	r30
     ad6:	ff 93       	push	r31
     ad8:	df 93       	push	r29
     ada:	cf 93       	push	r28
     adc:	0f 92       	push	r0
     ade:	cd b7       	in	r28, 0x3d	; 61
     ae0:	de b7       	in	r29, 0x3e	; 62
	unsigned char port_value;
	port_value=input();
     ae2:	0e 94 b9 03 	call	0x772	; 0x772 <input>
     ae6:	89 83       	std	Y+1, r24	; 0x01
	xQueueSend (myhandle,&port_value,portMAX_DELAY);
     ae8:	80 91 53 03 	lds	r24, 0x0353
     aec:	90 91 54 03 	lds	r25, 0x0354
     af0:	9e 01       	movw	r18, r28
     af2:	2f 5f       	subi	r18, 0xFF	; 255
     af4:	3f 4f       	sbci	r19, 0xFF	; 255
     af6:	b9 01       	movw	r22, r18
     af8:	4f ef       	ldi	r20, 0xFF	; 255
     afa:	5f ef       	ldi	r21, 0xFF	; 255
     afc:	20 e0       	ldi	r18, 0x00	; 0
     afe:	0e 94 f6 09 	call	0x13ec	; 0x13ec <xQueueGenericSend>
}
     b02:	0f 90       	pop	r0
     b04:	cf 91       	pop	r28
     b06:	df 91       	pop	r29
     b08:	ff 91       	pop	r31
     b0a:	ef 91       	pop	r30
     b0c:	bf 91       	pop	r27
     b0e:	af 91       	pop	r26
     b10:	9f 91       	pop	r25
     b12:	8f 91       	pop	r24
     b14:	7f 91       	pop	r23
     b16:	6f 91       	pop	r22
     b18:	5f 91       	pop	r21
     b1a:	4f 91       	pop	r20
     b1c:	3f 91       	pop	r19
     b1e:	2f 91       	pop	r18
     b20:	0f 90       	pop	r0
     b22:	0f be       	out	0x3f, r0	; 63
     b24:	0f 90       	pop	r0
     b26:	1f 90       	pop	r1
     b28:	18 95       	reti

00000b2a <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
     b2a:	df 93       	push	r29
     b2c:	cf 93       	push	r28
     b2e:	cd b7       	in	r28, 0x3d	; 61
     b30:	de b7       	in	r29, 0x3e	; 62
     b32:	28 97       	sbiw	r28, 0x08	; 8
     b34:	0f b6       	in	r0, 0x3f	; 63
     b36:	f8 94       	cli
     b38:	de bf       	out	0x3e, r29	; 62
     b3a:	0f be       	out	0x3f, r0	; 63
     b3c:	cd bf       	out	0x3d, r28	; 61
     b3e:	9c 83       	std	Y+4, r25	; 0x04
     b40:	8b 83       	std	Y+3, r24	; 0x03
     b42:	7e 83       	std	Y+6, r23	; 0x06
     b44:	6d 83       	std	Y+5, r22	; 0x05
     b46:	58 87       	std	Y+8, r21	; 0x08
     b48:	4f 83       	std	Y+7, r20	; 0x07
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     b4a:	eb 81       	ldd	r30, Y+3	; 0x03
     b4c:	fc 81       	ldd	r31, Y+4	; 0x04
     b4e:	81 e1       	ldi	r24, 0x11	; 17
     b50:	80 83       	st	Z, r24
	pxTopOfStack--;
     b52:	8b 81       	ldd	r24, Y+3	; 0x03
     b54:	9c 81       	ldd	r25, Y+4	; 0x04
     b56:	01 97       	sbiw	r24, 0x01	; 1
     b58:	9c 83       	std	Y+4, r25	; 0x04
     b5a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
     b5c:	eb 81       	ldd	r30, Y+3	; 0x03
     b5e:	fc 81       	ldd	r31, Y+4	; 0x04
     b60:	82 e2       	ldi	r24, 0x22	; 34
     b62:	80 83       	st	Z, r24
	pxTopOfStack--;
     b64:	8b 81       	ldd	r24, Y+3	; 0x03
     b66:	9c 81       	ldd	r25, Y+4	; 0x04
     b68:	01 97       	sbiw	r24, 0x01	; 1
     b6a:	9c 83       	std	Y+4, r25	; 0x04
     b6c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
     b6e:	eb 81       	ldd	r30, Y+3	; 0x03
     b70:	fc 81       	ldd	r31, Y+4	; 0x04
     b72:	83 e3       	ldi	r24, 0x33	; 51
     b74:	80 83       	st	Z, r24
	pxTopOfStack--;
     b76:	8b 81       	ldd	r24, Y+3	; 0x03
     b78:	9c 81       	ldd	r25, Y+4	; 0x04
     b7a:	01 97       	sbiw	r24, 0x01	; 1
     b7c:	9c 83       	std	Y+4, r25	; 0x04
     b7e:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
     b80:	8d 81       	ldd	r24, Y+5	; 0x05
     b82:	9e 81       	ldd	r25, Y+6	; 0x06
     b84:	9a 83       	std	Y+2, r25	; 0x02
     b86:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     b88:	89 81       	ldd	r24, Y+1	; 0x01
     b8a:	eb 81       	ldd	r30, Y+3	; 0x03
     b8c:	fc 81       	ldd	r31, Y+4	; 0x04
     b8e:	80 83       	st	Z, r24
	pxTopOfStack--;
     b90:	8b 81       	ldd	r24, Y+3	; 0x03
     b92:	9c 81       	ldd	r25, Y+4	; 0x04
     b94:	01 97       	sbiw	r24, 0x01	; 1
     b96:	9c 83       	std	Y+4, r25	; 0x04
     b98:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     b9a:	89 81       	ldd	r24, Y+1	; 0x01
     b9c:	9a 81       	ldd	r25, Y+2	; 0x02
     b9e:	89 2f       	mov	r24, r25
     ba0:	99 27       	eor	r25, r25
     ba2:	9a 83       	std	Y+2, r25	; 0x02
     ba4:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     ba6:	89 81       	ldd	r24, Y+1	; 0x01
     ba8:	eb 81       	ldd	r30, Y+3	; 0x03
     baa:	fc 81       	ldd	r31, Y+4	; 0x04
     bac:	80 83       	st	Z, r24
	pxTopOfStack--;
     bae:	8b 81       	ldd	r24, Y+3	; 0x03
     bb0:	9c 81       	ldd	r25, Y+4	; 0x04
     bb2:	01 97       	sbiw	r24, 0x01	; 1
     bb4:	9c 83       	std	Y+4, r25	; 0x04
     bb6:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
     bb8:	eb 81       	ldd	r30, Y+3	; 0x03
     bba:	fc 81       	ldd	r31, Y+4	; 0x04
     bbc:	10 82       	st	Z, r1
	pxTopOfStack--;
     bbe:	8b 81       	ldd	r24, Y+3	; 0x03
     bc0:	9c 81       	ldd	r25, Y+4	; 0x04
     bc2:	01 97       	sbiw	r24, 0x01	; 1
     bc4:	9c 83       	std	Y+4, r25	; 0x04
     bc6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     bc8:	eb 81       	ldd	r30, Y+3	; 0x03
     bca:	fc 81       	ldd	r31, Y+4	; 0x04
     bcc:	80 e8       	ldi	r24, 0x80	; 128
     bce:	80 83       	st	Z, r24
	pxTopOfStack--;
     bd0:	8b 81       	ldd	r24, Y+3	; 0x03
     bd2:	9c 81       	ldd	r25, Y+4	; 0x04
     bd4:	01 97       	sbiw	r24, 0x01	; 1
     bd6:	9c 83       	std	Y+4, r25	; 0x04
     bd8:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
     bda:	eb 81       	ldd	r30, Y+3	; 0x03
     bdc:	fc 81       	ldd	r31, Y+4	; 0x04
     bde:	10 82       	st	Z, r1
	pxTopOfStack--;
     be0:	8b 81       	ldd	r24, Y+3	; 0x03
     be2:	9c 81       	ldd	r25, Y+4	; 0x04
     be4:	01 97       	sbiw	r24, 0x01	; 1
     be6:	9c 83       	std	Y+4, r25	; 0x04
     be8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
     bea:	eb 81       	ldd	r30, Y+3	; 0x03
     bec:	fc 81       	ldd	r31, Y+4	; 0x04
     bee:	82 e0       	ldi	r24, 0x02	; 2
     bf0:	80 83       	st	Z, r24
	pxTopOfStack--;
     bf2:	8b 81       	ldd	r24, Y+3	; 0x03
     bf4:	9c 81       	ldd	r25, Y+4	; 0x04
     bf6:	01 97       	sbiw	r24, 0x01	; 1
     bf8:	9c 83       	std	Y+4, r25	; 0x04
     bfa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
     bfc:	eb 81       	ldd	r30, Y+3	; 0x03
     bfe:	fc 81       	ldd	r31, Y+4	; 0x04
     c00:	83 e0       	ldi	r24, 0x03	; 3
     c02:	80 83       	st	Z, r24
	pxTopOfStack--;
     c04:	8b 81       	ldd	r24, Y+3	; 0x03
     c06:	9c 81       	ldd	r25, Y+4	; 0x04
     c08:	01 97       	sbiw	r24, 0x01	; 1
     c0a:	9c 83       	std	Y+4, r25	; 0x04
     c0c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
     c0e:	eb 81       	ldd	r30, Y+3	; 0x03
     c10:	fc 81       	ldd	r31, Y+4	; 0x04
     c12:	84 e0       	ldi	r24, 0x04	; 4
     c14:	80 83       	st	Z, r24
	pxTopOfStack--;
     c16:	8b 81       	ldd	r24, Y+3	; 0x03
     c18:	9c 81       	ldd	r25, Y+4	; 0x04
     c1a:	01 97       	sbiw	r24, 0x01	; 1
     c1c:	9c 83       	std	Y+4, r25	; 0x04
     c1e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
     c20:	eb 81       	ldd	r30, Y+3	; 0x03
     c22:	fc 81       	ldd	r31, Y+4	; 0x04
     c24:	85 e0       	ldi	r24, 0x05	; 5
     c26:	80 83       	st	Z, r24
	pxTopOfStack--;
     c28:	8b 81       	ldd	r24, Y+3	; 0x03
     c2a:	9c 81       	ldd	r25, Y+4	; 0x04
     c2c:	01 97       	sbiw	r24, 0x01	; 1
     c2e:	9c 83       	std	Y+4, r25	; 0x04
     c30:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
     c32:	eb 81       	ldd	r30, Y+3	; 0x03
     c34:	fc 81       	ldd	r31, Y+4	; 0x04
     c36:	86 e0       	ldi	r24, 0x06	; 6
     c38:	80 83       	st	Z, r24
	pxTopOfStack--;
     c3a:	8b 81       	ldd	r24, Y+3	; 0x03
     c3c:	9c 81       	ldd	r25, Y+4	; 0x04
     c3e:	01 97       	sbiw	r24, 0x01	; 1
     c40:	9c 83       	std	Y+4, r25	; 0x04
     c42:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
     c44:	eb 81       	ldd	r30, Y+3	; 0x03
     c46:	fc 81       	ldd	r31, Y+4	; 0x04
     c48:	87 e0       	ldi	r24, 0x07	; 7
     c4a:	80 83       	st	Z, r24
	pxTopOfStack--;
     c4c:	8b 81       	ldd	r24, Y+3	; 0x03
     c4e:	9c 81       	ldd	r25, Y+4	; 0x04
     c50:	01 97       	sbiw	r24, 0x01	; 1
     c52:	9c 83       	std	Y+4, r25	; 0x04
     c54:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
     c56:	eb 81       	ldd	r30, Y+3	; 0x03
     c58:	fc 81       	ldd	r31, Y+4	; 0x04
     c5a:	88 e0       	ldi	r24, 0x08	; 8
     c5c:	80 83       	st	Z, r24
	pxTopOfStack--;
     c5e:	8b 81       	ldd	r24, Y+3	; 0x03
     c60:	9c 81       	ldd	r25, Y+4	; 0x04
     c62:	01 97       	sbiw	r24, 0x01	; 1
     c64:	9c 83       	std	Y+4, r25	; 0x04
     c66:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
     c68:	eb 81       	ldd	r30, Y+3	; 0x03
     c6a:	fc 81       	ldd	r31, Y+4	; 0x04
     c6c:	89 e0       	ldi	r24, 0x09	; 9
     c6e:	80 83       	st	Z, r24
	pxTopOfStack--;
     c70:	8b 81       	ldd	r24, Y+3	; 0x03
     c72:	9c 81       	ldd	r25, Y+4	; 0x04
     c74:	01 97       	sbiw	r24, 0x01	; 1
     c76:	9c 83       	std	Y+4, r25	; 0x04
     c78:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
     c7a:	eb 81       	ldd	r30, Y+3	; 0x03
     c7c:	fc 81       	ldd	r31, Y+4	; 0x04
     c7e:	80 e1       	ldi	r24, 0x10	; 16
     c80:	80 83       	st	Z, r24
	pxTopOfStack--;
     c82:	8b 81       	ldd	r24, Y+3	; 0x03
     c84:	9c 81       	ldd	r25, Y+4	; 0x04
     c86:	01 97       	sbiw	r24, 0x01	; 1
     c88:	9c 83       	std	Y+4, r25	; 0x04
     c8a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
     c8c:	eb 81       	ldd	r30, Y+3	; 0x03
     c8e:	fc 81       	ldd	r31, Y+4	; 0x04
     c90:	81 e1       	ldi	r24, 0x11	; 17
     c92:	80 83       	st	Z, r24
	pxTopOfStack--;
     c94:	8b 81       	ldd	r24, Y+3	; 0x03
     c96:	9c 81       	ldd	r25, Y+4	; 0x04
     c98:	01 97       	sbiw	r24, 0x01	; 1
     c9a:	9c 83       	std	Y+4, r25	; 0x04
     c9c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
     c9e:	eb 81       	ldd	r30, Y+3	; 0x03
     ca0:	fc 81       	ldd	r31, Y+4	; 0x04
     ca2:	82 e1       	ldi	r24, 0x12	; 18
     ca4:	80 83       	st	Z, r24
	pxTopOfStack--;
     ca6:	8b 81       	ldd	r24, Y+3	; 0x03
     ca8:	9c 81       	ldd	r25, Y+4	; 0x04
     caa:	01 97       	sbiw	r24, 0x01	; 1
     cac:	9c 83       	std	Y+4, r25	; 0x04
     cae:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
     cb0:	eb 81       	ldd	r30, Y+3	; 0x03
     cb2:	fc 81       	ldd	r31, Y+4	; 0x04
     cb4:	83 e1       	ldi	r24, 0x13	; 19
     cb6:	80 83       	st	Z, r24
	pxTopOfStack--;
     cb8:	8b 81       	ldd	r24, Y+3	; 0x03
     cba:	9c 81       	ldd	r25, Y+4	; 0x04
     cbc:	01 97       	sbiw	r24, 0x01	; 1
     cbe:	9c 83       	std	Y+4, r25	; 0x04
     cc0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
     cc2:	eb 81       	ldd	r30, Y+3	; 0x03
     cc4:	fc 81       	ldd	r31, Y+4	; 0x04
     cc6:	84 e1       	ldi	r24, 0x14	; 20
     cc8:	80 83       	st	Z, r24
	pxTopOfStack--;
     cca:	8b 81       	ldd	r24, Y+3	; 0x03
     ccc:	9c 81       	ldd	r25, Y+4	; 0x04
     cce:	01 97       	sbiw	r24, 0x01	; 1
     cd0:	9c 83       	std	Y+4, r25	; 0x04
     cd2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
     cd4:	eb 81       	ldd	r30, Y+3	; 0x03
     cd6:	fc 81       	ldd	r31, Y+4	; 0x04
     cd8:	85 e1       	ldi	r24, 0x15	; 21
     cda:	80 83       	st	Z, r24
	pxTopOfStack--;
     cdc:	8b 81       	ldd	r24, Y+3	; 0x03
     cde:	9c 81       	ldd	r25, Y+4	; 0x04
     ce0:	01 97       	sbiw	r24, 0x01	; 1
     ce2:	9c 83       	std	Y+4, r25	; 0x04
     ce4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
     ce6:	eb 81       	ldd	r30, Y+3	; 0x03
     ce8:	fc 81       	ldd	r31, Y+4	; 0x04
     cea:	86 e1       	ldi	r24, 0x16	; 22
     cec:	80 83       	st	Z, r24
	pxTopOfStack--;
     cee:	8b 81       	ldd	r24, Y+3	; 0x03
     cf0:	9c 81       	ldd	r25, Y+4	; 0x04
     cf2:	01 97       	sbiw	r24, 0x01	; 1
     cf4:	9c 83       	std	Y+4, r25	; 0x04
     cf6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
     cf8:	eb 81       	ldd	r30, Y+3	; 0x03
     cfa:	fc 81       	ldd	r31, Y+4	; 0x04
     cfc:	87 e1       	ldi	r24, 0x17	; 23
     cfe:	80 83       	st	Z, r24
	pxTopOfStack--;
     d00:	8b 81       	ldd	r24, Y+3	; 0x03
     d02:	9c 81       	ldd	r25, Y+4	; 0x04
     d04:	01 97       	sbiw	r24, 0x01	; 1
     d06:	9c 83       	std	Y+4, r25	; 0x04
     d08:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
     d0a:	eb 81       	ldd	r30, Y+3	; 0x03
     d0c:	fc 81       	ldd	r31, Y+4	; 0x04
     d0e:	88 e1       	ldi	r24, 0x18	; 24
     d10:	80 83       	st	Z, r24
	pxTopOfStack--;
     d12:	8b 81       	ldd	r24, Y+3	; 0x03
     d14:	9c 81       	ldd	r25, Y+4	; 0x04
     d16:	01 97       	sbiw	r24, 0x01	; 1
     d18:	9c 83       	std	Y+4, r25	; 0x04
     d1a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
     d1c:	eb 81       	ldd	r30, Y+3	; 0x03
     d1e:	fc 81       	ldd	r31, Y+4	; 0x04
     d20:	89 e1       	ldi	r24, 0x19	; 25
     d22:	80 83       	st	Z, r24
	pxTopOfStack--;
     d24:	8b 81       	ldd	r24, Y+3	; 0x03
     d26:	9c 81       	ldd	r25, Y+4	; 0x04
     d28:	01 97       	sbiw	r24, 0x01	; 1
     d2a:	9c 83       	std	Y+4, r25	; 0x04
     d2c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
     d2e:	eb 81       	ldd	r30, Y+3	; 0x03
     d30:	fc 81       	ldd	r31, Y+4	; 0x04
     d32:	80 e2       	ldi	r24, 0x20	; 32
     d34:	80 83       	st	Z, r24
	pxTopOfStack--;
     d36:	8b 81       	ldd	r24, Y+3	; 0x03
     d38:	9c 81       	ldd	r25, Y+4	; 0x04
     d3a:	01 97       	sbiw	r24, 0x01	; 1
     d3c:	9c 83       	std	Y+4, r25	; 0x04
     d3e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
     d40:	eb 81       	ldd	r30, Y+3	; 0x03
     d42:	fc 81       	ldd	r31, Y+4	; 0x04
     d44:	81 e2       	ldi	r24, 0x21	; 33
     d46:	80 83       	st	Z, r24
	pxTopOfStack--;
     d48:	8b 81       	ldd	r24, Y+3	; 0x03
     d4a:	9c 81       	ldd	r25, Y+4	; 0x04
     d4c:	01 97       	sbiw	r24, 0x01	; 1
     d4e:	9c 83       	std	Y+4, r25	; 0x04
     d50:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
     d52:	eb 81       	ldd	r30, Y+3	; 0x03
     d54:	fc 81       	ldd	r31, Y+4	; 0x04
     d56:	82 e2       	ldi	r24, 0x22	; 34
     d58:	80 83       	st	Z, r24
	pxTopOfStack--;
     d5a:	8b 81       	ldd	r24, Y+3	; 0x03
     d5c:	9c 81       	ldd	r25, Y+4	; 0x04
     d5e:	01 97       	sbiw	r24, 0x01	; 1
     d60:	9c 83       	std	Y+4, r25	; 0x04
     d62:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
     d64:	eb 81       	ldd	r30, Y+3	; 0x03
     d66:	fc 81       	ldd	r31, Y+4	; 0x04
     d68:	83 e2       	ldi	r24, 0x23	; 35
     d6a:	80 83       	st	Z, r24
	pxTopOfStack--;
     d6c:	8b 81       	ldd	r24, Y+3	; 0x03
     d6e:	9c 81       	ldd	r25, Y+4	; 0x04
     d70:	01 97       	sbiw	r24, 0x01	; 1
     d72:	9c 83       	std	Y+4, r25	; 0x04
     d74:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
     d76:	8f 81       	ldd	r24, Y+7	; 0x07
     d78:	98 85       	ldd	r25, Y+8	; 0x08
     d7a:	9a 83       	std	Y+2, r25	; 0x02
     d7c:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     d7e:	89 81       	ldd	r24, Y+1	; 0x01
     d80:	eb 81       	ldd	r30, Y+3	; 0x03
     d82:	fc 81       	ldd	r31, Y+4	; 0x04
     d84:	80 83       	st	Z, r24
	pxTopOfStack--;
     d86:	8b 81       	ldd	r24, Y+3	; 0x03
     d88:	9c 81       	ldd	r25, Y+4	; 0x04
     d8a:	01 97       	sbiw	r24, 0x01	; 1
     d8c:	9c 83       	std	Y+4, r25	; 0x04
     d8e:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     d90:	89 81       	ldd	r24, Y+1	; 0x01
     d92:	9a 81       	ldd	r25, Y+2	; 0x02
     d94:	89 2f       	mov	r24, r25
     d96:	99 27       	eor	r25, r25
     d98:	9a 83       	std	Y+2, r25	; 0x02
     d9a:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     d9c:	89 81       	ldd	r24, Y+1	; 0x01
     d9e:	eb 81       	ldd	r30, Y+3	; 0x03
     da0:	fc 81       	ldd	r31, Y+4	; 0x04
     da2:	80 83       	st	Z, r24
	pxTopOfStack--;
     da4:	8b 81       	ldd	r24, Y+3	; 0x03
     da6:	9c 81       	ldd	r25, Y+4	; 0x04
     da8:	01 97       	sbiw	r24, 0x01	; 1
     daa:	9c 83       	std	Y+4, r25	; 0x04
     dac:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
     dae:	eb 81       	ldd	r30, Y+3	; 0x03
     db0:	fc 81       	ldd	r31, Y+4	; 0x04
     db2:	86 e2       	ldi	r24, 0x26	; 38
     db4:	80 83       	st	Z, r24
	pxTopOfStack--;
     db6:	8b 81       	ldd	r24, Y+3	; 0x03
     db8:	9c 81       	ldd	r25, Y+4	; 0x04
     dba:	01 97       	sbiw	r24, 0x01	; 1
     dbc:	9c 83       	std	Y+4, r25	; 0x04
     dbe:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
     dc0:	eb 81       	ldd	r30, Y+3	; 0x03
     dc2:	fc 81       	ldd	r31, Y+4	; 0x04
     dc4:	87 e2       	ldi	r24, 0x27	; 39
     dc6:	80 83       	st	Z, r24
	pxTopOfStack--;
     dc8:	8b 81       	ldd	r24, Y+3	; 0x03
     dca:	9c 81       	ldd	r25, Y+4	; 0x04
     dcc:	01 97       	sbiw	r24, 0x01	; 1
     dce:	9c 83       	std	Y+4, r25	; 0x04
     dd0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
     dd2:	eb 81       	ldd	r30, Y+3	; 0x03
     dd4:	fc 81       	ldd	r31, Y+4	; 0x04
     dd6:	88 e2       	ldi	r24, 0x28	; 40
     dd8:	80 83       	st	Z, r24
	pxTopOfStack--;
     dda:	8b 81       	ldd	r24, Y+3	; 0x03
     ddc:	9c 81       	ldd	r25, Y+4	; 0x04
     dde:	01 97       	sbiw	r24, 0x01	; 1
     de0:	9c 83       	std	Y+4, r25	; 0x04
     de2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
     de4:	eb 81       	ldd	r30, Y+3	; 0x03
     de6:	fc 81       	ldd	r31, Y+4	; 0x04
     de8:	89 e2       	ldi	r24, 0x29	; 41
     dea:	80 83       	st	Z, r24
	pxTopOfStack--;
     dec:	8b 81       	ldd	r24, Y+3	; 0x03
     dee:	9c 81       	ldd	r25, Y+4	; 0x04
     df0:	01 97       	sbiw	r24, 0x01	; 1
     df2:	9c 83       	std	Y+4, r25	; 0x04
     df4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
     df6:	eb 81       	ldd	r30, Y+3	; 0x03
     df8:	fc 81       	ldd	r31, Y+4	; 0x04
     dfa:	80 e3       	ldi	r24, 0x30	; 48
     dfc:	80 83       	st	Z, r24
	pxTopOfStack--;
     dfe:	8b 81       	ldd	r24, Y+3	; 0x03
     e00:	9c 81       	ldd	r25, Y+4	; 0x04
     e02:	01 97       	sbiw	r24, 0x01	; 1
     e04:	9c 83       	std	Y+4, r25	; 0x04
     e06:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
     e08:	eb 81       	ldd	r30, Y+3	; 0x03
     e0a:	fc 81       	ldd	r31, Y+4	; 0x04
     e0c:	81 e3       	ldi	r24, 0x31	; 49
     e0e:	80 83       	st	Z, r24
	pxTopOfStack--;
     e10:	8b 81       	ldd	r24, Y+3	; 0x03
     e12:	9c 81       	ldd	r25, Y+4	; 0x04
     e14:	01 97       	sbiw	r24, 0x01	; 1
     e16:	9c 83       	std	Y+4, r25	; 0x04
     e18:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
     e1a:	8b 81       	ldd	r24, Y+3	; 0x03
     e1c:	9c 81       	ldd	r25, Y+4	; 0x04
}
     e1e:	28 96       	adiw	r28, 0x08	; 8
     e20:	0f b6       	in	r0, 0x3f	; 63
     e22:	f8 94       	cli
     e24:	de bf       	out	0x3e, r29	; 62
     e26:	0f be       	out	0x3f, r0	; 63
     e28:	cd bf       	out	0x3d, r28	; 61
     e2a:	cf 91       	pop	r28
     e2c:	df 91       	pop	r29
     e2e:	08 95       	ret

00000e30 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
     e30:	df 93       	push	r29
     e32:	cf 93       	push	r28
     e34:	cd b7       	in	r28, 0x3d	; 61
     e36:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
     e38:	0e 94 08 08 	call	0x1010	; 0x1010 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     e3c:	a0 91 02 03 	lds	r26, 0x0302
     e40:	b0 91 03 03 	lds	r27, 0x0303
     e44:	cd 91       	ld	r28, X+
     e46:	cd bf       	out	0x3d, r28	; 61
     e48:	dd 91       	ld	r29, X+
     e4a:	de bf       	out	0x3e, r29	; 62
     e4c:	ff 91       	pop	r31
     e4e:	ef 91       	pop	r30
     e50:	df 91       	pop	r29
     e52:	cf 91       	pop	r28
     e54:	bf 91       	pop	r27
     e56:	af 91       	pop	r26
     e58:	9f 91       	pop	r25
     e5a:	8f 91       	pop	r24
     e5c:	7f 91       	pop	r23
     e5e:	6f 91       	pop	r22
     e60:	5f 91       	pop	r21
     e62:	4f 91       	pop	r20
     e64:	3f 91       	pop	r19
     e66:	2f 91       	pop	r18
     e68:	1f 91       	pop	r17
     e6a:	0f 91       	pop	r16
     e6c:	ff 90       	pop	r15
     e6e:	ef 90       	pop	r14
     e70:	df 90       	pop	r13
     e72:	cf 90       	pop	r12
     e74:	bf 90       	pop	r11
     e76:	af 90       	pop	r10
     e78:	9f 90       	pop	r9
     e7a:	8f 90       	pop	r8
     e7c:	7f 90       	pop	r7
     e7e:	6f 90       	pop	r6
     e80:	5f 90       	pop	r5
     e82:	4f 90       	pop	r4
     e84:	3f 90       	pop	r3
     e86:	2f 90       	pop	r2
     e88:	1f 90       	pop	r1
     e8a:	0f 90       	pop	r0
     e8c:	0f be       	out	0x3f, r0	; 63
     e8e:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     e90:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
     e92:	81 e0       	ldi	r24, 0x01	; 1
}
     e94:	cf 91       	pop	r28
     e96:	df 91       	pop	r29
     e98:	08 95       	ret

00000e9a <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     e9a:	df 93       	push	r29
     e9c:	cf 93       	push	r28
     e9e:	cd b7       	in	r28, 0x3d	; 61
     ea0:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
     ea2:	cf 91       	pop	r28
     ea4:	df 91       	pop	r29
     ea6:	08 95       	ret

00000ea8 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     ea8:	0f 92       	push	r0
     eaa:	0f b6       	in	r0, 0x3f	; 63
     eac:	f8 94       	cli
     eae:	0f 92       	push	r0
     eb0:	1f 92       	push	r1
     eb2:	11 24       	eor	r1, r1
     eb4:	2f 92       	push	r2
     eb6:	3f 92       	push	r3
     eb8:	4f 92       	push	r4
     eba:	5f 92       	push	r5
     ebc:	6f 92       	push	r6
     ebe:	7f 92       	push	r7
     ec0:	8f 92       	push	r8
     ec2:	9f 92       	push	r9
     ec4:	af 92       	push	r10
     ec6:	bf 92       	push	r11
     ec8:	cf 92       	push	r12
     eca:	df 92       	push	r13
     ecc:	ef 92       	push	r14
     ece:	ff 92       	push	r15
     ed0:	0f 93       	push	r16
     ed2:	1f 93       	push	r17
     ed4:	2f 93       	push	r18
     ed6:	3f 93       	push	r19
     ed8:	4f 93       	push	r20
     eda:	5f 93       	push	r21
     edc:	6f 93       	push	r22
     ede:	7f 93       	push	r23
     ee0:	8f 93       	push	r24
     ee2:	9f 93       	push	r25
     ee4:	af 93       	push	r26
     ee6:	bf 93       	push	r27
     ee8:	cf 93       	push	r28
     eea:	df 93       	push	r29
     eec:	ef 93       	push	r30
     eee:	ff 93       	push	r31
     ef0:	a0 91 02 03 	lds	r26, 0x0302
     ef4:	b0 91 03 03 	lds	r27, 0x0303
     ef8:	0d b6       	in	r0, 0x3d	; 61
     efa:	0d 92       	st	X+, r0
     efc:	0e b6       	in	r0, 0x3e	; 62
     efe:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     f00:	0e 94 d8 11 	call	0x23b0	; 0x23b0 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     f04:	a0 91 02 03 	lds	r26, 0x0302
     f08:	b0 91 03 03 	lds	r27, 0x0303
     f0c:	cd 91       	ld	r28, X+
     f0e:	cd bf       	out	0x3d, r28	; 61
     f10:	dd 91       	ld	r29, X+
     f12:	de bf       	out	0x3e, r29	; 62
     f14:	ff 91       	pop	r31
     f16:	ef 91       	pop	r30
     f18:	df 91       	pop	r29
     f1a:	cf 91       	pop	r28
     f1c:	bf 91       	pop	r27
     f1e:	af 91       	pop	r26
     f20:	9f 91       	pop	r25
     f22:	8f 91       	pop	r24
     f24:	7f 91       	pop	r23
     f26:	6f 91       	pop	r22
     f28:	5f 91       	pop	r21
     f2a:	4f 91       	pop	r20
     f2c:	3f 91       	pop	r19
     f2e:	2f 91       	pop	r18
     f30:	1f 91       	pop	r17
     f32:	0f 91       	pop	r16
     f34:	ff 90       	pop	r15
     f36:	ef 90       	pop	r14
     f38:	df 90       	pop	r13
     f3a:	cf 90       	pop	r12
     f3c:	bf 90       	pop	r11
     f3e:	af 90       	pop	r10
     f40:	9f 90       	pop	r9
     f42:	8f 90       	pop	r8
     f44:	7f 90       	pop	r7
     f46:	6f 90       	pop	r6
     f48:	5f 90       	pop	r5
     f4a:	4f 90       	pop	r4
     f4c:	3f 90       	pop	r3
     f4e:	2f 90       	pop	r2
     f50:	1f 90       	pop	r1
     f52:	0f 90       	pop	r0
     f54:	0f be       	out	0x3f, r0	; 63
     f56:	0f 90       	pop	r0

	asm volatile ( "ret" );
     f58:	08 95       	ret

00000f5a <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     f5a:	0f 92       	push	r0
     f5c:	0f b6       	in	r0, 0x3f	; 63
     f5e:	f8 94       	cli
     f60:	0f 92       	push	r0
     f62:	1f 92       	push	r1
     f64:	11 24       	eor	r1, r1
     f66:	2f 92       	push	r2
     f68:	3f 92       	push	r3
     f6a:	4f 92       	push	r4
     f6c:	5f 92       	push	r5
     f6e:	6f 92       	push	r6
     f70:	7f 92       	push	r7
     f72:	8f 92       	push	r8
     f74:	9f 92       	push	r9
     f76:	af 92       	push	r10
     f78:	bf 92       	push	r11
     f7a:	cf 92       	push	r12
     f7c:	df 92       	push	r13
     f7e:	ef 92       	push	r14
     f80:	ff 92       	push	r15
     f82:	0f 93       	push	r16
     f84:	1f 93       	push	r17
     f86:	2f 93       	push	r18
     f88:	3f 93       	push	r19
     f8a:	4f 93       	push	r20
     f8c:	5f 93       	push	r21
     f8e:	6f 93       	push	r22
     f90:	7f 93       	push	r23
     f92:	8f 93       	push	r24
     f94:	9f 93       	push	r25
     f96:	af 93       	push	r26
     f98:	bf 93       	push	r27
     f9a:	cf 93       	push	r28
     f9c:	df 93       	push	r29
     f9e:	ef 93       	push	r30
     fa0:	ff 93       	push	r31
     fa2:	a0 91 02 03 	lds	r26, 0x0302
     fa6:	b0 91 03 03 	lds	r27, 0x0303
     faa:	0d b6       	in	r0, 0x3d	; 61
     fac:	0d 92       	st	X+, r0
     fae:	0e b6       	in	r0, 0x3e	; 62
     fb0:	0d 92       	st	X+, r0
	vTaskIncrementTick();
     fb2:	0e 94 03 11 	call	0x2206	; 0x2206 <vTaskIncrementTick>
	vTaskSwitchContext();
     fb6:	0e 94 d8 11 	call	0x23b0	; 0x23b0 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     fba:	a0 91 02 03 	lds	r26, 0x0302
     fbe:	b0 91 03 03 	lds	r27, 0x0303
     fc2:	cd 91       	ld	r28, X+
     fc4:	cd bf       	out	0x3d, r28	; 61
     fc6:	dd 91       	ld	r29, X+
     fc8:	de bf       	out	0x3e, r29	; 62
     fca:	ff 91       	pop	r31
     fcc:	ef 91       	pop	r30
     fce:	df 91       	pop	r29
     fd0:	cf 91       	pop	r28
     fd2:	bf 91       	pop	r27
     fd4:	af 91       	pop	r26
     fd6:	9f 91       	pop	r25
     fd8:	8f 91       	pop	r24
     fda:	7f 91       	pop	r23
     fdc:	6f 91       	pop	r22
     fde:	5f 91       	pop	r21
     fe0:	4f 91       	pop	r20
     fe2:	3f 91       	pop	r19
     fe4:	2f 91       	pop	r18
     fe6:	1f 91       	pop	r17
     fe8:	0f 91       	pop	r16
     fea:	ff 90       	pop	r15
     fec:	ef 90       	pop	r14
     fee:	df 90       	pop	r13
     ff0:	cf 90       	pop	r12
     ff2:	bf 90       	pop	r11
     ff4:	af 90       	pop	r10
     ff6:	9f 90       	pop	r9
     ff8:	8f 90       	pop	r8
     ffa:	7f 90       	pop	r7
     ffc:	6f 90       	pop	r6
     ffe:	5f 90       	pop	r5
    1000:	4f 90       	pop	r4
    1002:	3f 90       	pop	r3
    1004:	2f 90       	pop	r2
    1006:	1f 90       	pop	r1
    1008:	0f 90       	pop	r0
    100a:	0f be       	out	0x3f, r0	; 63
    100c:	0f 90       	pop	r0

	asm volatile ( "ret" );
    100e:	08 95       	ret

00001010 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    1010:	df 93       	push	r29
    1012:	cf 93       	push	r28
    1014:	00 d0       	rcall	.+0      	; 0x1016 <prvSetupTimerInterrupt+0x6>
    1016:	00 d0       	rcall	.+0      	; 0x1018 <prvSetupTimerInterrupt+0x8>
    1018:	00 d0       	rcall	.+0      	; 0x101a <prvSetupTimerInterrupt+0xa>
    101a:	cd b7       	in	r28, 0x3d	; 61
    101c:	de b7       	in	r29, 0x3e	; 62
unsigned char ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    101e:	80 e4       	ldi	r24, 0x40	; 64
    1020:	9f e1       	ldi	r25, 0x1F	; 31
    1022:	a0 e0       	ldi	r26, 0x00	; 0
    1024:	b0 e0       	ldi	r27, 0x00	; 0
    1026:	8b 83       	std	Y+3, r24	; 0x03
    1028:	9c 83       	std	Y+4, r25	; 0x04
    102a:	ad 83       	std	Y+5, r26	; 0x05
    102c:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    102e:	8b 81       	ldd	r24, Y+3	; 0x03
    1030:	9c 81       	ldd	r25, Y+4	; 0x04
    1032:	ad 81       	ldd	r26, Y+5	; 0x05
    1034:	be 81       	ldd	r27, Y+6	; 0x06
    1036:	68 94       	set
    1038:	15 f8       	bld	r1, 5
    103a:	b6 95       	lsr	r27
    103c:	a7 95       	ror	r26
    103e:	97 95       	ror	r25
    1040:	87 95       	ror	r24
    1042:	16 94       	lsr	r1
    1044:	d1 f7       	brne	.-12     	; 0x103a <prvSetupTimerInterrupt+0x2a>
    1046:	8b 83       	std	Y+3, r24	; 0x03
    1048:	9c 83       	std	Y+4, r25	; 0x04
    104a:	ad 83       	std	Y+5, r26	; 0x05
    104c:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( unsigned long ) 1;
    104e:	8b 81       	ldd	r24, Y+3	; 0x03
    1050:	9c 81       	ldd	r25, Y+4	; 0x04
    1052:	ad 81       	ldd	r26, Y+5	; 0x05
    1054:	be 81       	ldd	r27, Y+6	; 0x06
    1056:	01 97       	sbiw	r24, 0x01	; 1
    1058:	a1 09       	sbc	r26, r1
    105a:	b1 09       	sbc	r27, r1
    105c:	8b 83       	std	Y+3, r24	; 0x03
    105e:	9c 83       	std	Y+4, r25	; 0x04
    1060:	ad 83       	std	Y+5, r26	; 0x05
    1062:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    1064:	8b 81       	ldd	r24, Y+3	; 0x03
    1066:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    1068:	8b 81       	ldd	r24, Y+3	; 0x03
    106a:	9c 81       	ldd	r25, Y+4	; 0x04
    106c:	ad 81       	ldd	r26, Y+5	; 0x05
    106e:	be 81       	ldd	r27, Y+6	; 0x06
    1070:	89 2f       	mov	r24, r25
    1072:	9a 2f       	mov	r25, r26
    1074:	ab 2f       	mov	r26, r27
    1076:	bb 27       	eor	r27, r27
    1078:	8b 83       	std	Y+3, r24	; 0x03
    107a:	9c 83       	std	Y+4, r25	; 0x04
    107c:	ad 83       	std	Y+5, r26	; 0x05
    107e:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    1080:	8b 81       	ldd	r24, Y+3	; 0x03
    1082:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    1084:	eb e4       	ldi	r30, 0x4B	; 75
    1086:	f0 e0       	ldi	r31, 0x00	; 0
    1088:	8a 81       	ldd	r24, Y+2	; 0x02
    108a:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    108c:	ea e4       	ldi	r30, 0x4A	; 74
    108e:	f0 e0       	ldi	r31, 0x00	; 0
    1090:	89 81       	ldd	r24, Y+1	; 0x01
    1092:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    1094:	8b e0       	ldi	r24, 0x0B	; 11
    1096:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    1098:	ee e4       	ldi	r30, 0x4E	; 78
    109a:	f0 e0       	ldi	r31, 0x00	; 0
    109c:	89 81       	ldd	r24, Y+1	; 0x01
    109e:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    10a0:	e9 e5       	ldi	r30, 0x59	; 89
    10a2:	f0 e0       	ldi	r31, 0x00	; 0
    10a4:	80 81       	ld	r24, Z
    10a6:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    10a8:	89 81       	ldd	r24, Y+1	; 0x01
    10aa:	80 61       	ori	r24, 0x10	; 16
    10ac:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    10ae:	e9 e5       	ldi	r30, 0x59	; 89
    10b0:	f0 e0       	ldi	r31, 0x00	; 0
    10b2:	89 81       	ldd	r24, Y+1	; 0x01
    10b4:	80 83       	st	Z, r24
}
    10b6:	26 96       	adiw	r28, 0x06	; 6
    10b8:	0f b6       	in	r0, 0x3f	; 63
    10ba:	f8 94       	cli
    10bc:	de bf       	out	0x3e, r29	; 62
    10be:	0f be       	out	0x3f, r0	; 63
    10c0:	cd bf       	out	0x3d, r28	; 61
    10c2:	cf 91       	pop	r28
    10c4:	df 91       	pop	r29
    10c6:	08 95       	ret

000010c8 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    10c8:	0e 94 ad 07 	call	0xf5a	; 0xf5a <vPortYieldFromTick>
		asm volatile ( "reti" );
    10cc:	18 95       	reti

000010ce <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    10ce:	df 93       	push	r29
    10d0:	cf 93       	push	r28
    10d2:	cd b7       	in	r28, 0x3d	; 61
    10d4:	de b7       	in	r29, 0x3e	; 62
    10d6:	28 97       	sbiw	r28, 0x08	; 8
    10d8:	0f b6       	in	r0, 0x3f	; 63
    10da:	f8 94       	cli
    10dc:	de bf       	out	0x3e, r29	; 62
    10de:	0f be       	out	0x3f, r0	; 63
    10e0:	cd bf       	out	0x3d, r28	; 61
    10e2:	8f 83       	std	Y+7, r24	; 0x07
    10e4:	68 87       	std	Y+8, r22	; 0x08
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    10e6:	1a 82       	std	Y+2, r1	; 0x02
    10e8:	19 82       	std	Y+1, r1	; 0x01

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    10ea:	8f 81       	ldd	r24, Y+7	; 0x07
    10ec:	88 23       	and	r24, r24
    10ee:	09 f4       	brne	.+2      	; 0x10f2 <xQueueCreate+0x24>
    10f0:	8c c0       	rjmp	.+280    	; 0x120a <xQueueCreate+0x13c>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    10f2:	8f e1       	ldi	r24, 0x1F	; 31
    10f4:	90 e0       	ldi	r25, 0x00	; 0
    10f6:	0e 94 21 03 	call	0x642	; 0x642 <pvPortMalloc>
    10fa:	9e 83       	std	Y+6, r25	; 0x06
    10fc:	8d 83       	std	Y+5, r24	; 0x05
		if( pxNewQueue != NULL )
    10fe:	8d 81       	ldd	r24, Y+5	; 0x05
    1100:	9e 81       	ldd	r25, Y+6	; 0x06
    1102:	00 97       	sbiw	r24, 0x00	; 0
    1104:	09 f4       	brne	.+2      	; 0x1108 <xQueueCreate+0x3a>
    1106:	81 c0       	rjmp	.+258    	; 0x120a <xQueueCreate+0x13c>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    1108:	8f 81       	ldd	r24, Y+7	; 0x07
    110a:	28 2f       	mov	r18, r24
    110c:	30 e0       	ldi	r19, 0x00	; 0
    110e:	88 85       	ldd	r24, Y+8	; 0x08
    1110:	88 2f       	mov	r24, r24
    1112:	90 e0       	ldi	r25, 0x00	; 0
    1114:	ac 01       	movw	r20, r24
    1116:	24 9f       	mul	r18, r20
    1118:	c0 01       	movw	r24, r0
    111a:	25 9f       	mul	r18, r21
    111c:	90 0d       	add	r25, r0
    111e:	34 9f       	mul	r19, r20
    1120:	90 0d       	add	r25, r0
    1122:	11 24       	eor	r1, r1
    1124:	01 96       	adiw	r24, 0x01	; 1
    1126:	9c 83       	std	Y+4, r25	; 0x04
    1128:	8b 83       	std	Y+3, r24	; 0x03

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    112a:	8b 81       	ldd	r24, Y+3	; 0x03
    112c:	9c 81       	ldd	r25, Y+4	; 0x04
    112e:	0e 94 21 03 	call	0x642	; 0x642 <pvPortMalloc>
    1132:	ed 81       	ldd	r30, Y+5	; 0x05
    1134:	fe 81       	ldd	r31, Y+6	; 0x06
    1136:	91 83       	std	Z+1, r25	; 0x01
    1138:	80 83       	st	Z, r24
			if( pxNewQueue->pcHead != NULL )
    113a:	ed 81       	ldd	r30, Y+5	; 0x05
    113c:	fe 81       	ldd	r31, Y+6	; 0x06
    113e:	80 81       	ld	r24, Z
    1140:	91 81       	ldd	r25, Z+1	; 0x01
    1142:	00 97       	sbiw	r24, 0x00	; 0
    1144:	09 f4       	brne	.+2      	; 0x1148 <xQueueCreate+0x7a>
    1146:	5d c0       	rjmp	.+186    	; 0x1202 <xQueueCreate+0x134>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    1148:	ed 81       	ldd	r30, Y+5	; 0x05
    114a:	fe 81       	ldd	r31, Y+6	; 0x06
    114c:	40 81       	ld	r20, Z
    114e:	51 81       	ldd	r21, Z+1	; 0x01
    1150:	8f 81       	ldd	r24, Y+7	; 0x07
    1152:	28 2f       	mov	r18, r24
    1154:	30 e0       	ldi	r19, 0x00	; 0
    1156:	88 85       	ldd	r24, Y+8	; 0x08
    1158:	88 2f       	mov	r24, r24
    115a:	90 e0       	ldi	r25, 0x00	; 0
    115c:	bc 01       	movw	r22, r24
    115e:	26 9f       	mul	r18, r22
    1160:	c0 01       	movw	r24, r0
    1162:	27 9f       	mul	r18, r23
    1164:	90 0d       	add	r25, r0
    1166:	36 9f       	mul	r19, r22
    1168:	90 0d       	add	r25, r0
    116a:	11 24       	eor	r1, r1
    116c:	84 0f       	add	r24, r20
    116e:	95 1f       	adc	r25, r21
    1170:	ed 81       	ldd	r30, Y+5	; 0x05
    1172:	fe 81       	ldd	r31, Y+6	; 0x06
    1174:	93 83       	std	Z+3, r25	; 0x03
    1176:	82 83       	std	Z+2, r24	; 0x02
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    1178:	ed 81       	ldd	r30, Y+5	; 0x05
    117a:	fe 81       	ldd	r31, Y+6	; 0x06
    117c:	12 8e       	std	Z+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    117e:	ed 81       	ldd	r30, Y+5	; 0x05
    1180:	fe 81       	ldd	r31, Y+6	; 0x06
    1182:	80 81       	ld	r24, Z
    1184:	91 81       	ldd	r25, Z+1	; 0x01
    1186:	ed 81       	ldd	r30, Y+5	; 0x05
    1188:	fe 81       	ldd	r31, Y+6	; 0x06
    118a:	95 83       	std	Z+5, r25	; 0x05
    118c:	84 83       	std	Z+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
    118e:	ed 81       	ldd	r30, Y+5	; 0x05
    1190:	fe 81       	ldd	r31, Y+6	; 0x06
    1192:	40 81       	ld	r20, Z
    1194:	51 81       	ldd	r21, Z+1	; 0x01
    1196:	8f 81       	ldd	r24, Y+7	; 0x07
    1198:	88 2f       	mov	r24, r24
    119a:	90 e0       	ldi	r25, 0x00	; 0
    119c:	9c 01       	movw	r18, r24
    119e:	21 50       	subi	r18, 0x01	; 1
    11a0:	30 40       	sbci	r19, 0x00	; 0
    11a2:	88 85       	ldd	r24, Y+8	; 0x08
    11a4:	88 2f       	mov	r24, r24
    11a6:	90 e0       	ldi	r25, 0x00	; 0
    11a8:	bc 01       	movw	r22, r24
    11aa:	26 9f       	mul	r18, r22
    11ac:	c0 01       	movw	r24, r0
    11ae:	27 9f       	mul	r18, r23
    11b0:	90 0d       	add	r25, r0
    11b2:	36 9f       	mul	r19, r22
    11b4:	90 0d       	add	r25, r0
    11b6:	11 24       	eor	r1, r1
    11b8:	84 0f       	add	r24, r20
    11ba:	95 1f       	adc	r25, r21
    11bc:	ed 81       	ldd	r30, Y+5	; 0x05
    11be:	fe 81       	ldd	r31, Y+6	; 0x06
    11c0:	97 83       	std	Z+7, r25	; 0x07
    11c2:	86 83       	std	Z+6, r24	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    11c4:	ed 81       	ldd	r30, Y+5	; 0x05
    11c6:	fe 81       	ldd	r31, Y+6	; 0x06
    11c8:	8f 81       	ldd	r24, Y+7	; 0x07
    11ca:	83 8f       	std	Z+27, r24	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    11cc:	ed 81       	ldd	r30, Y+5	; 0x05
    11ce:	fe 81       	ldd	r31, Y+6	; 0x06
    11d0:	88 85       	ldd	r24, Y+8	; 0x08
    11d2:	84 8f       	std	Z+28, r24	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    11d4:	ed 81       	ldd	r30, Y+5	; 0x05
    11d6:	fe 81       	ldd	r31, Y+6	; 0x06
    11d8:	8f ef       	ldi	r24, 0xFF	; 255
    11da:	85 8f       	std	Z+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    11dc:	ed 81       	ldd	r30, Y+5	; 0x05
    11de:	fe 81       	ldd	r31, Y+6	; 0x06
    11e0:	8f ef       	ldi	r24, 0xFF	; 255
    11e2:	86 8f       	std	Z+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    11e4:	8d 81       	ldd	r24, Y+5	; 0x05
    11e6:	9e 81       	ldd	r25, Y+6	; 0x06
    11e8:	08 96       	adiw	r24, 0x08	; 8
    11ea:	0e 94 d1 03 	call	0x7a2	; 0x7a2 <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    11ee:	8d 81       	ldd	r24, Y+5	; 0x05
    11f0:	9e 81       	ldd	r25, Y+6	; 0x06
    11f2:	41 96       	adiw	r24, 0x11	; 17
    11f4:	0e 94 d1 03 	call	0x7a2	; 0x7a2 <vListInitialise>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    11f8:	8d 81       	ldd	r24, Y+5	; 0x05
    11fa:	9e 81       	ldd	r25, Y+6	; 0x06
    11fc:	9a 83       	std	Y+2, r25	; 0x02
    11fe:	89 83       	std	Y+1, r24	; 0x01
    1200:	04 c0       	rjmp	.+8      	; 0x120a <xQueueCreate+0x13c>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    1202:	8d 81       	ldd	r24, Y+5	; 0x05
    1204:	9e 81       	ldd	r25, Y+6	; 0x06
    1206:	0e 94 67 03 	call	0x6ce	; 0x6ce <vPortFree>
		}
	}

	configASSERT( xReturn );

	return xReturn;
    120a:	89 81       	ldd	r24, Y+1	; 0x01
    120c:	9a 81       	ldd	r25, Y+2	; 0x02
}
    120e:	28 96       	adiw	r28, 0x08	; 8
    1210:	0f b6       	in	r0, 0x3f	; 63
    1212:	f8 94       	cli
    1214:	de bf       	out	0x3e, r29	; 62
    1216:	0f be       	out	0x3f, r0	; 63
    1218:	cd bf       	out	0x3d, r28	; 61
    121a:	cf 91       	pop	r28
    121c:	df 91       	pop	r29
    121e:	08 95       	ret

00001220 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( void )
	{
    1220:	df 93       	push	r29
    1222:	cf 93       	push	r28
    1224:	00 d0       	rcall	.+0      	; 0x1226 <xQueueCreateMutex+0x6>
    1226:	cd b7       	in	r28, 0x3d	; 61
    1228:	de b7       	in	r29, 0x3e	; 62
	xQUEUE *pxNewQueue;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    122a:	8f e1       	ldi	r24, 0x1F	; 31
    122c:	90 e0       	ldi	r25, 0x00	; 0
    122e:	0e 94 21 03 	call	0x642	; 0x642 <pvPortMalloc>
    1232:	9a 83       	std	Y+2, r25	; 0x02
    1234:	89 83       	std	Y+1, r24	; 0x01
		if( pxNewQueue != NULL )
    1236:	89 81       	ldd	r24, Y+1	; 0x01
    1238:	9a 81       	ldd	r25, Y+2	; 0x02
    123a:	00 97       	sbiw	r24, 0x00	; 0
    123c:	a9 f1       	breq	.+106    	; 0x12a8 <xQueueCreateMutex+0x88>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    123e:	e9 81       	ldd	r30, Y+1	; 0x01
    1240:	fa 81       	ldd	r31, Y+2	; 0x02
    1242:	13 82       	std	Z+3, r1	; 0x03
    1244:	12 82       	std	Z+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    1246:	e9 81       	ldd	r30, Y+1	; 0x01
    1248:	fa 81       	ldd	r31, Y+2	; 0x02
    124a:	11 82       	std	Z+1, r1	; 0x01
    124c:	10 82       	st	Z, r1

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
    124e:	e9 81       	ldd	r30, Y+1	; 0x01
    1250:	fa 81       	ldd	r31, Y+2	; 0x02
    1252:	15 82       	std	Z+5, r1	; 0x05
    1254:	14 82       	std	Z+4, r1	; 0x04
			pxNewQueue->pcReadFrom = NULL;
    1256:	e9 81       	ldd	r30, Y+1	; 0x01
    1258:	fa 81       	ldd	r31, Y+2	; 0x02
    125a:	17 82       	std	Z+7, r1	; 0x07
    125c:	16 82       	std	Z+6, r1	; 0x06

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    125e:	e9 81       	ldd	r30, Y+1	; 0x01
    1260:	fa 81       	ldd	r31, Y+2	; 0x02
    1262:	12 8e       	std	Z+26, r1	; 0x1a
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
    1264:	e9 81       	ldd	r30, Y+1	; 0x01
    1266:	fa 81       	ldd	r31, Y+2	; 0x02
    1268:	81 e0       	ldi	r24, 0x01	; 1
    126a:	83 8f       	std	Z+27, r24	; 0x1b
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
    126c:	e9 81       	ldd	r30, Y+1	; 0x01
    126e:	fa 81       	ldd	r31, Y+2	; 0x02
    1270:	14 8e       	std	Z+28, r1	; 0x1c
			pxNewQueue->xRxLock = queueUNLOCKED;
    1272:	e9 81       	ldd	r30, Y+1	; 0x01
    1274:	fa 81       	ldd	r31, Y+2	; 0x02
    1276:	8f ef       	ldi	r24, 0xFF	; 255
    1278:	85 8f       	std	Z+29, r24	; 0x1d
			pxNewQueue->xTxLock = queueUNLOCKED;
    127a:	e9 81       	ldd	r30, Y+1	; 0x01
    127c:	fa 81       	ldd	r31, Y+2	; 0x02
    127e:	8f ef       	ldi	r24, 0xFF	; 255
    1280:	86 8f       	std	Z+30, r24	; 0x1e

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    1282:	89 81       	ldd	r24, Y+1	; 0x01
    1284:	9a 81       	ldd	r25, Y+2	; 0x02
    1286:	08 96       	adiw	r24, 0x08	; 8
    1288:	0e 94 d1 03 	call	0x7a2	; 0x7a2 <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    128c:	89 81       	ldd	r24, Y+1	; 0x01
    128e:	9a 81       	ldd	r25, Y+2	; 0x02
    1290:	41 96       	adiw	r24, 0x11	; 17
    1292:	0e 94 d1 03 	call	0x7a2	; 0x7a2 <vListInitialise>

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
    1296:	89 81       	ldd	r24, Y+1	; 0x01
    1298:	9a 81       	ldd	r25, Y+2	; 0x02
    129a:	60 e0       	ldi	r22, 0x00	; 0
    129c:	70 e0       	ldi	r23, 0x00	; 0
    129e:	40 e0       	ldi	r20, 0x00	; 0
    12a0:	50 e0       	ldi	r21, 0x00	; 0
    12a2:	20 e0       	ldi	r18, 0x00	; 0
    12a4:	0e 94 f6 09 	call	0x13ec	; 0x13ec <xQueueGenericSend>
		{
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
    12a8:	89 81       	ldd	r24, Y+1	; 0x01
    12aa:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    12ac:	0f 90       	pop	r0
    12ae:	0f 90       	pop	r0
    12b0:	cf 91       	pop	r28
    12b2:	df 91       	pop	r29
    12b4:	08 95       	ret

000012b6 <xQueueGiveMutexRecursive>:
/*-----------------------------------------------------------*/

#if configUSE_RECURSIVE_MUTEXES == 1

	portBASE_TYPE xQueueGiveMutexRecursive( xQueueHandle pxMutex )
	{
    12b6:	0f 93       	push	r16
    12b8:	1f 93       	push	r17
    12ba:	df 93       	push	r29
    12bc:	cf 93       	push	r28
    12be:	00 d0       	rcall	.+0      	; 0x12c0 <xQueueGiveMutexRecursive+0xa>
    12c0:	0f 92       	push	r0
    12c2:	cd b7       	in	r28, 0x3d	; 61
    12c4:	de b7       	in	r29, 0x3e	; 62
    12c6:	9b 83       	std	Y+3, r25	; 0x03
    12c8:	8a 83       	std	Y+2, r24	; 0x02
		change outside of this task.  If this task does not hold the mutex then
		pxMutexHolder can never coincidentally equal the tasks handle, and as
		this is the only condition we are interested in it does not matter if
		pxMutexHolder is accessed simultaneously by another task.  Therefore no
		mutual exclusion is required to test the pxMutexHolder variable. */
		if( pxMutex->pxMutexHolder == xTaskGetCurrentTaskHandle() )
    12ca:	ea 81       	ldd	r30, Y+2	; 0x02
    12cc:	fb 81       	ldd	r31, Y+3	; 0x03
    12ce:	02 81       	ldd	r16, Z+2	; 0x02
    12d0:	13 81       	ldd	r17, Z+3	; 0x03
    12d2:	0e 94 eb 14 	call	0x29d6	; 0x29d6 <xTaskGetCurrentTaskHandle>
    12d6:	08 17       	cp	r16, r24
    12d8:	19 07       	cpc	r17, r25
    12da:	d9 f4       	brne	.+54     	; 0x1312 <xQueueGiveMutexRecursive+0x5c>
			/* uxRecursiveCallCount cannot be zero if pxMutexHolder is equal to
			the task handle, therefore no underflow check is required.  Also,
			uxRecursiveCallCount is only modified by the mutex holder, and as
			there can only be one, no mutual exclusion is required to modify the
			uxRecursiveCallCount member. */
			( pxMutex->uxRecursiveCallCount )--;
    12dc:	ea 81       	ldd	r30, Y+2	; 0x02
    12de:	fb 81       	ldd	r31, Y+3	; 0x03
    12e0:	86 81       	ldd	r24, Z+6	; 0x06
    12e2:	97 81       	ldd	r25, Z+7	; 0x07
    12e4:	01 97       	sbiw	r24, 0x01	; 1
    12e6:	ea 81       	ldd	r30, Y+2	; 0x02
    12e8:	fb 81       	ldd	r31, Y+3	; 0x03
    12ea:	97 83       	std	Z+7, r25	; 0x07
    12ec:	86 83       	std	Z+6, r24	; 0x06

			/* Have we unwound the call count? */
			if( pxMutex->uxRecursiveCallCount == 0 )
    12ee:	ea 81       	ldd	r30, Y+2	; 0x02
    12f0:	fb 81       	ldd	r31, Y+3	; 0x03
    12f2:	86 81       	ldd	r24, Z+6	; 0x06
    12f4:	97 81       	ldd	r25, Z+7	; 0x07
    12f6:	00 97       	sbiw	r24, 0x00	; 0
    12f8:	49 f4       	brne	.+18     	; 0x130c <xQueueGiveMutexRecursive+0x56>
			{
				/* Return the mutex.  This will automatically unblock any other
				task that might be waiting to access the mutex. */
				xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
    12fa:	8a 81       	ldd	r24, Y+2	; 0x02
    12fc:	9b 81       	ldd	r25, Y+3	; 0x03
    12fe:	60 e0       	ldi	r22, 0x00	; 0
    1300:	70 e0       	ldi	r23, 0x00	; 0
    1302:	40 e0       	ldi	r20, 0x00	; 0
    1304:	50 e0       	ldi	r21, 0x00	; 0
    1306:	20 e0       	ldi	r18, 0x00	; 0
    1308:	0e 94 f6 09 	call	0x13ec	; 0x13ec <xQueueGenericSend>
			}

			xReturn = pdPASS;
    130c:	81 e0       	ldi	r24, 0x01	; 1
    130e:	89 83       	std	Y+1, r24	; 0x01
    1310:	01 c0       	rjmp	.+2      	; 0x1314 <xQueueGiveMutexRecursive+0x5e>
		}
		else
		{
			/* We cannot give the mutex because we are not the holder. */
			xReturn = pdFAIL;
    1312:	19 82       	std	Y+1, r1	; 0x01

			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
		}

		return xReturn;
    1314:	89 81       	ldd	r24, Y+1	; 0x01
	}
    1316:	0f 90       	pop	r0
    1318:	0f 90       	pop	r0
    131a:	0f 90       	pop	r0
    131c:	cf 91       	pop	r28
    131e:	df 91       	pop	r29
    1320:	1f 91       	pop	r17
    1322:	0f 91       	pop	r16
    1324:	08 95       	ret

00001326 <xQueueTakeMutexRecursive>:
/*-----------------------------------------------------------*/

#if configUSE_RECURSIVE_MUTEXES == 1

	portBASE_TYPE xQueueTakeMutexRecursive( xQueueHandle pxMutex, portTickType xBlockTime )
	{
    1326:	0f 93       	push	r16
    1328:	1f 93       	push	r17
    132a:	df 93       	push	r29
    132c:	cf 93       	push	r28
    132e:	00 d0       	rcall	.+0      	; 0x1330 <xQueueTakeMutexRecursive+0xa>
    1330:	00 d0       	rcall	.+0      	; 0x1332 <xQueueTakeMutexRecursive+0xc>
    1332:	0f 92       	push	r0
    1334:	cd b7       	in	r28, 0x3d	; 61
    1336:	de b7       	in	r29, 0x3e	; 62
    1338:	9b 83       	std	Y+3, r25	; 0x03
    133a:	8a 83       	std	Y+2, r24	; 0x02
    133c:	7d 83       	std	Y+5, r23	; 0x05
    133e:	6c 83       	std	Y+4, r22	; 0x04
		/* Comments regarding mutual exclusion as per those within
		xQueueGiveMutexRecursive(). */

		traceTAKE_MUTEX_RECURSIVE( pxMutex );

		if( pxMutex->pxMutexHolder == xTaskGetCurrentTaskHandle() )
    1340:	ea 81       	ldd	r30, Y+2	; 0x02
    1342:	fb 81       	ldd	r31, Y+3	; 0x03
    1344:	02 81       	ldd	r16, Z+2	; 0x02
    1346:	13 81       	ldd	r17, Z+3	; 0x03
    1348:	0e 94 eb 14 	call	0x29d6	; 0x29d6 <xTaskGetCurrentTaskHandle>
    134c:	08 17       	cp	r16, r24
    134e:	19 07       	cpc	r17, r25
    1350:	61 f4       	brne	.+24     	; 0x136a <xQueueTakeMutexRecursive+0x44>
		{
			( pxMutex->uxRecursiveCallCount )++;
    1352:	ea 81       	ldd	r30, Y+2	; 0x02
    1354:	fb 81       	ldd	r31, Y+3	; 0x03
    1356:	86 81       	ldd	r24, Z+6	; 0x06
    1358:	97 81       	ldd	r25, Z+7	; 0x07
    135a:	01 96       	adiw	r24, 0x01	; 1
    135c:	ea 81       	ldd	r30, Y+2	; 0x02
    135e:	fb 81       	ldd	r31, Y+3	; 0x03
    1360:	97 83       	std	Z+7, r25	; 0x07
    1362:	86 83       	std	Z+6, r24	; 0x06
			xReturn = pdPASS;
    1364:	81 e0       	ldi	r24, 0x01	; 1
    1366:	89 83       	std	Y+1, r24	; 0x01
    1368:	17 c0       	rjmp	.+46     	; 0x1398 <xQueueTakeMutexRecursive+0x72>
		}
		else
		{
			xReturn = xQueueGenericReceive( pxMutex, NULL, xBlockTime, pdFALSE );
    136a:	8a 81       	ldd	r24, Y+2	; 0x02
    136c:	9b 81       	ldd	r25, Y+3	; 0x03
    136e:	2c 81       	ldd	r18, Y+4	; 0x04
    1370:	3d 81       	ldd	r19, Y+5	; 0x05
    1372:	60 e0       	ldi	r22, 0x00	; 0
    1374:	70 e0       	ldi	r23, 0x00	; 0
    1376:	a9 01       	movw	r20, r18
    1378:	20 e0       	ldi	r18, 0x00	; 0
    137a:	0e 94 e1 0a 	call	0x15c2	; 0x15c2 <xQueueGenericReceive>
    137e:	89 83       	std	Y+1, r24	; 0x01

			/* pdPASS will only be returned if we successfully obtained the mutex,
			we may have blocked to reach here. */
			if( xReturn == pdPASS )
    1380:	89 81       	ldd	r24, Y+1	; 0x01
    1382:	81 30       	cpi	r24, 0x01	; 1
    1384:	49 f4       	brne	.+18     	; 0x1398 <xQueueTakeMutexRecursive+0x72>
			{
				( pxMutex->uxRecursiveCallCount )++;
    1386:	ea 81       	ldd	r30, Y+2	; 0x02
    1388:	fb 81       	ldd	r31, Y+3	; 0x03
    138a:	86 81       	ldd	r24, Z+6	; 0x06
    138c:	97 81       	ldd	r25, Z+7	; 0x07
    138e:	01 96       	adiw	r24, 0x01	; 1
    1390:	ea 81       	ldd	r30, Y+2	; 0x02
    1392:	fb 81       	ldd	r31, Y+3	; 0x03
    1394:	97 83       	std	Z+7, r25	; 0x07
    1396:	86 83       	std	Z+6, r24	; 0x06
			{
				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
			}
		}

		return xReturn;
    1398:	89 81       	ldd	r24, Y+1	; 0x01
	}
    139a:	0f 90       	pop	r0
    139c:	0f 90       	pop	r0
    139e:	0f 90       	pop	r0
    13a0:	0f 90       	pop	r0
    13a2:	0f 90       	pop	r0
    13a4:	cf 91       	pop	r28
    13a6:	df 91       	pop	r29
    13a8:	1f 91       	pop	r17
    13aa:	0f 91       	pop	r16
    13ac:	08 95       	ret

000013ae <xQueueCreateCountingSemaphore>:
/*-----------------------------------------------------------*/

#if configUSE_COUNTING_SEMAPHORES == 1

	xQueueHandle xQueueCreateCountingSemaphore( unsigned portBASE_TYPE uxCountValue, unsigned portBASE_TYPE uxInitialCount )
	{
    13ae:	df 93       	push	r29
    13b0:	cf 93       	push	r28
    13b2:	00 d0       	rcall	.+0      	; 0x13b4 <xQueueCreateCountingSemaphore+0x6>
    13b4:	00 d0       	rcall	.+0      	; 0x13b6 <xQueueCreateCountingSemaphore+0x8>
    13b6:	cd b7       	in	r28, 0x3d	; 61
    13b8:	de b7       	in	r29, 0x3e	; 62
    13ba:	8b 83       	std	Y+3, r24	; 0x03
    13bc:	6c 83       	std	Y+4, r22	; 0x04
	xQueueHandle pxHandle;

		pxHandle = xQueueCreate( ( unsigned portBASE_TYPE ) uxCountValue, queueSEMAPHORE_QUEUE_ITEM_LENGTH );
    13be:	8b 81       	ldd	r24, Y+3	; 0x03
    13c0:	60 e0       	ldi	r22, 0x00	; 0
    13c2:	0e 94 67 08 	call	0x10ce	; 0x10ce <xQueueCreate>
    13c6:	9a 83       	std	Y+2, r25	; 0x02
    13c8:	89 83       	std	Y+1, r24	; 0x01

		if( pxHandle != NULL )
    13ca:	89 81       	ldd	r24, Y+1	; 0x01
    13cc:	9a 81       	ldd	r25, Y+2	; 0x02
    13ce:	00 97       	sbiw	r24, 0x00	; 0
    13d0:	21 f0       	breq	.+8      	; 0x13da <xQueueCreateCountingSemaphore+0x2c>
		{
			pxHandle->uxMessagesWaiting = uxInitialCount;
    13d2:	e9 81       	ldd	r30, Y+1	; 0x01
    13d4:	fa 81       	ldd	r31, Y+2	; 0x02
    13d6:	8c 81       	ldd	r24, Y+4	; 0x04
    13d8:	82 8f       	std	Z+26, r24	; 0x1a
		{
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		configASSERT( pxHandle );
		return pxHandle;
    13da:	89 81       	ldd	r24, Y+1	; 0x01
    13dc:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    13de:	0f 90       	pop	r0
    13e0:	0f 90       	pop	r0
    13e2:	0f 90       	pop	r0
    13e4:	0f 90       	pop	r0
    13e6:	cf 91       	pop	r28
    13e8:	df 91       	pop	r29
    13ea:	08 95       	ret

000013ec <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    13ec:	df 93       	push	r29
    13ee:	cf 93       	push	r28
    13f0:	cd b7       	in	r28, 0x3d	; 61
    13f2:	de b7       	in	r29, 0x3e	; 62
    13f4:	2c 97       	sbiw	r28, 0x0c	; 12
    13f6:	0f b6       	in	r0, 0x3f	; 63
    13f8:	f8 94       	cli
    13fa:	de bf       	out	0x3e, r29	; 62
    13fc:	0f be       	out	0x3f, r0	; 63
    13fe:	cd bf       	out	0x3d, r28	; 61
    1400:	9e 83       	std	Y+6, r25	; 0x06
    1402:	8d 83       	std	Y+5, r24	; 0x05
    1404:	78 87       	std	Y+8, r23	; 0x08
    1406:	6f 83       	std	Y+7, r22	; 0x07
    1408:	5a 87       	std	Y+10, r21	; 0x0a
    140a:	49 87       	std	Y+9, r20	; 0x09
    140c:	2b 87       	std	Y+11, r18	; 0x0b
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    140e:	19 82       	std	Y+1, r1	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1410:	0f b6       	in	r0, 0x3f	; 63
    1412:	f8 94       	cli
    1414:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1416:	ed 81       	ldd	r30, Y+5	; 0x05
    1418:	fe 81       	ldd	r31, Y+6	; 0x06
    141a:	92 8d       	ldd	r25, Z+26	; 0x1a
    141c:	ed 81       	ldd	r30, Y+5	; 0x05
    141e:	fe 81       	ldd	r31, Y+6	; 0x06
    1420:	83 8d       	ldd	r24, Z+27	; 0x1b
    1422:	98 17       	cp	r25, r24
    1424:	d8 f4       	brcc	.+54     	; 0x145c <xQueueGenericSend+0x70>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1426:	8d 81       	ldd	r24, Y+5	; 0x05
    1428:	9e 81       	ldd	r25, Y+6	; 0x06
    142a:	2f 81       	ldd	r18, Y+7	; 0x07
    142c:	38 85       	ldd	r19, Y+8	; 0x08
    142e:	b9 01       	movw	r22, r18
    1430:	4b 85       	ldd	r20, Y+11	; 0x0b
    1432:	0e 94 4e 0c 	call	0x189c	; 0x189c <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1436:	ed 81       	ldd	r30, Y+5	; 0x05
    1438:	fe 81       	ldd	r31, Y+6	; 0x06
    143a:	81 89       	ldd	r24, Z+17	; 0x11
    143c:	88 23       	and	r24, r24
    143e:	49 f0       	breq	.+18     	; 0x1452 <xQueueGenericSend+0x66>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    1440:	8d 81       	ldd	r24, Y+5	; 0x05
    1442:	9e 81       	ldd	r25, Y+6	; 0x06
    1444:	41 96       	adiw	r24, 0x11	; 17
    1446:	0e 94 74 12 	call	0x24e8	; 0x24e8 <xTaskRemoveFromEventList>
    144a:	81 30       	cpi	r24, 0x01	; 1
    144c:	11 f4       	brne	.+4      	; 0x1452 <xQueueGenericSend+0x66>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    144e:	0e 94 54 07 	call	0xea8	; 0xea8 <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    1452:	0f 90       	pop	r0
    1454:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    1456:	81 e0       	ldi	r24, 0x01	; 1
    1458:	8c 87       	std	Y+12, r24	; 0x0c
    145a:	5c c0       	rjmp	.+184    	; 0x1514 <xQueueGenericSend+0x128>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    145c:	89 85       	ldd	r24, Y+9	; 0x09
    145e:	9a 85       	ldd	r25, Y+10	; 0x0a
    1460:	00 97       	sbiw	r24, 0x00	; 0
    1462:	21 f4       	brne	.+8      	; 0x146c <xQueueGenericSend+0x80>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1464:	0f 90       	pop	r0
    1466:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    1468:	1c 86       	std	Y+12, r1	; 0x0c
    146a:	54 c0       	rjmp	.+168    	; 0x1514 <xQueueGenericSend+0x128>
				}
				else if( xEntryTimeSet == pdFALSE )
    146c:	89 81       	ldd	r24, Y+1	; 0x01
    146e:	88 23       	and	r24, r24
    1470:	31 f4       	brne	.+12     	; 0x147e <xQueueGenericSend+0x92>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1472:	ce 01       	movw	r24, r28
    1474:	02 96       	adiw	r24, 0x02	; 2
    1476:	0e 94 dc 12 	call	0x25b8	; 0x25b8 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    147a:	81 e0       	ldi	r24, 0x01	; 1
    147c:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
    147e:	0f 90       	pop	r0
    1480:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1482:	0e 94 38 10 	call	0x2070	; 0x2070 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1486:	0f b6       	in	r0, 0x3f	; 63
    1488:	f8 94       	cli
    148a:	0f 92       	push	r0
    148c:	ed 81       	ldd	r30, Y+5	; 0x05
    148e:	fe 81       	ldd	r31, Y+6	; 0x06
    1490:	85 8d       	ldd	r24, Z+29	; 0x1d
    1492:	8f 3f       	cpi	r24, 0xFF	; 255
    1494:	19 f4       	brne	.+6      	; 0x149c <xQueueGenericSend+0xb0>
    1496:	ed 81       	ldd	r30, Y+5	; 0x05
    1498:	fe 81       	ldd	r31, Y+6	; 0x06
    149a:	15 8e       	std	Z+29, r1	; 0x1d
    149c:	ed 81       	ldd	r30, Y+5	; 0x05
    149e:	fe 81       	ldd	r31, Y+6	; 0x06
    14a0:	86 8d       	ldd	r24, Z+30	; 0x1e
    14a2:	8f 3f       	cpi	r24, 0xFF	; 255
    14a4:	19 f4       	brne	.+6      	; 0x14ac <xQueueGenericSend+0xc0>
    14a6:	ed 81       	ldd	r30, Y+5	; 0x05
    14a8:	fe 81       	ldd	r31, Y+6	; 0x06
    14aa:	16 8e       	std	Z+30, r1	; 0x1e
    14ac:	0f 90       	pop	r0
    14ae:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    14b0:	ce 01       	movw	r24, r28
    14b2:	02 96       	adiw	r24, 0x02	; 2
    14b4:	9e 01       	movw	r18, r28
    14b6:	27 5f       	subi	r18, 0xF7	; 247
    14b8:	3f 4f       	sbci	r19, 0xFF	; 255
    14ba:	b9 01       	movw	r22, r18
    14bc:	0e 94 f5 12 	call	0x25ea	; 0x25ea <xTaskCheckForTimeOut>
    14c0:	88 23       	and	r24, r24
    14c2:	09 f5       	brne	.+66     	; 0x1506 <xQueueGenericSend+0x11a>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    14c4:	8d 81       	ldd	r24, Y+5	; 0x05
    14c6:	9e 81       	ldd	r25, Y+6	; 0x06
    14c8:	0e 94 c3 0d 	call	0x1b86	; 0x1b86 <prvIsQueueFull>
    14cc:	88 23       	and	r24, r24
    14ce:	a1 f0       	breq	.+40     	; 0x14f8 <xQueueGenericSend+0x10c>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    14d0:	8d 81       	ldd	r24, Y+5	; 0x05
    14d2:	9e 81       	ldd	r25, Y+6	; 0x06
    14d4:	08 96       	adiw	r24, 0x08	; 8
    14d6:	29 85       	ldd	r18, Y+9	; 0x09
    14d8:	3a 85       	ldd	r19, Y+10	; 0x0a
    14da:	b9 01       	movw	r22, r18
    14dc:	0e 94 3e 12 	call	0x247c	; 0x247c <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    14e0:	8d 81       	ldd	r24, Y+5	; 0x05
    14e2:	9e 81       	ldd	r25, Y+6	; 0x06
    14e4:	0e 94 3c 0d 	call	0x1a78	; 0x1a78 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    14e8:	0e 94 44 10 	call	0x2088	; 0x2088 <xTaskResumeAll>
    14ec:	88 23       	and	r24, r24
    14ee:	09 f0       	breq	.+2      	; 0x14f2 <xQueueGenericSend+0x106>
    14f0:	8f cf       	rjmp	.-226    	; 0x1410 <xQueueGenericSend+0x24>
				{
					portYIELD_WITHIN_API();
    14f2:	0e 94 54 07 	call	0xea8	; 0xea8 <vPortYield>
    14f6:	8c cf       	rjmp	.-232    	; 0x1410 <xQueueGenericSend+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    14f8:	8d 81       	ldd	r24, Y+5	; 0x05
    14fa:	9e 81       	ldd	r25, Y+6	; 0x06
    14fc:	0e 94 3c 0d 	call	0x1a78	; 0x1a78 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1500:	0e 94 44 10 	call	0x2088	; 0x2088 <xTaskResumeAll>
    1504:	85 cf       	rjmp	.-246    	; 0x1410 <xQueueGenericSend+0x24>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1506:	8d 81       	ldd	r24, Y+5	; 0x05
    1508:	9e 81       	ldd	r25, Y+6	; 0x06
    150a:	0e 94 3c 0d 	call	0x1a78	; 0x1a78 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    150e:	0e 94 44 10 	call	0x2088	; 0x2088 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1512:	1c 86       	std	Y+12, r1	; 0x0c
    1514:	8c 85       	ldd	r24, Y+12	; 0x0c
		}
	}
}
    1516:	2c 96       	adiw	r28, 0x0c	; 12
    1518:	0f b6       	in	r0, 0x3f	; 63
    151a:	f8 94       	cli
    151c:	de bf       	out	0x3e, r29	; 62
    151e:	0f be       	out	0x3f, r0	; 63
    1520:	cd bf       	out	0x3d, r28	; 61
    1522:	cf 91       	pop	r28
    1524:	df 91       	pop	r29
    1526:	08 95       	ret

00001528 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    1528:	df 93       	push	r29
    152a:	cf 93       	push	r28
    152c:	cd b7       	in	r28, 0x3d	; 61
    152e:	de b7       	in	r29, 0x3e	; 62
    1530:	29 97       	sbiw	r28, 0x09	; 9
    1532:	0f b6       	in	r0, 0x3f	; 63
    1534:	f8 94       	cli
    1536:	de bf       	out	0x3e, r29	; 62
    1538:	0f be       	out	0x3f, r0	; 63
    153a:	cd bf       	out	0x3d, r28	; 61
    153c:	9c 83       	std	Y+4, r25	; 0x04
    153e:	8b 83       	std	Y+3, r24	; 0x03
    1540:	7e 83       	std	Y+6, r23	; 0x06
    1542:	6d 83       	std	Y+5, r22	; 0x05
    1544:	58 87       	std	Y+8, r21	; 0x08
    1546:	4f 83       	std	Y+7, r20	; 0x07
    1548:	29 87       	std	Y+9, r18	; 0x09
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    154a:	19 82       	std	Y+1, r1	; 0x01
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    154c:	eb 81       	ldd	r30, Y+3	; 0x03
    154e:	fc 81       	ldd	r31, Y+4	; 0x04
    1550:	92 8d       	ldd	r25, Z+26	; 0x1a
    1552:	eb 81       	ldd	r30, Y+3	; 0x03
    1554:	fc 81       	ldd	r31, Y+4	; 0x04
    1556:	83 8d       	ldd	r24, Z+27	; 0x1b
    1558:	98 17       	cp	r25, r24
    155a:	40 f5       	brcc	.+80     	; 0x15ac <xQueueGenericSendFromISR+0x84>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    155c:	8b 81       	ldd	r24, Y+3	; 0x03
    155e:	9c 81       	ldd	r25, Y+4	; 0x04
    1560:	2d 81       	ldd	r18, Y+5	; 0x05
    1562:	3e 81       	ldd	r19, Y+6	; 0x06
    1564:	b9 01       	movw	r22, r18
    1566:	49 85       	ldd	r20, Y+9	; 0x09
    1568:	0e 94 4e 0c 	call	0x189c	; 0x189c <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    156c:	eb 81       	ldd	r30, Y+3	; 0x03
    156e:	fc 81       	ldd	r31, Y+4	; 0x04
    1570:	86 8d       	ldd	r24, Z+30	; 0x1e
    1572:	8f 3f       	cpi	r24, 0xFF	; 255
    1574:	89 f4       	brne	.+34     	; 0x1598 <xQueueGenericSendFromISR+0x70>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1576:	eb 81       	ldd	r30, Y+3	; 0x03
    1578:	fc 81       	ldd	r31, Y+4	; 0x04
    157a:	81 89       	ldd	r24, Z+17	; 0x11
    157c:	88 23       	and	r24, r24
    157e:	99 f0       	breq	.+38     	; 0x15a6 <xQueueGenericSendFromISR+0x7e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1580:	8b 81       	ldd	r24, Y+3	; 0x03
    1582:	9c 81       	ldd	r25, Y+4	; 0x04
    1584:	41 96       	adiw	r24, 0x11	; 17
    1586:	0e 94 74 12 	call	0x24e8	; 0x24e8 <xTaskRemoveFromEventList>
    158a:	88 23       	and	r24, r24
    158c:	61 f0       	breq	.+24     	; 0x15a6 <xQueueGenericSendFromISR+0x7e>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    158e:	ef 81       	ldd	r30, Y+7	; 0x07
    1590:	f8 85       	ldd	r31, Y+8	; 0x08
    1592:	81 e0       	ldi	r24, 0x01	; 1
    1594:	80 83       	st	Z, r24
    1596:	07 c0       	rjmp	.+14     	; 0x15a6 <xQueueGenericSendFromISR+0x7e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    1598:	eb 81       	ldd	r30, Y+3	; 0x03
    159a:	fc 81       	ldd	r31, Y+4	; 0x04
    159c:	86 8d       	ldd	r24, Z+30	; 0x1e
    159e:	8f 5f       	subi	r24, 0xFF	; 255
    15a0:	eb 81       	ldd	r30, Y+3	; 0x03
    15a2:	fc 81       	ldd	r31, Y+4	; 0x04
    15a4:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    15a6:	81 e0       	ldi	r24, 0x01	; 1
    15a8:	8a 83       	std	Y+2, r24	; 0x02
    15aa:	01 c0       	rjmp	.+2      	; 0x15ae <xQueueGenericSendFromISR+0x86>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    15ac:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    15ae:	8a 81       	ldd	r24, Y+2	; 0x02
}
    15b0:	29 96       	adiw	r28, 0x09	; 9
    15b2:	0f b6       	in	r0, 0x3f	; 63
    15b4:	f8 94       	cli
    15b6:	de bf       	out	0x3e, r29	; 62
    15b8:	0f be       	out	0x3f, r0	; 63
    15ba:	cd bf       	out	0x3d, r28	; 61
    15bc:	cf 91       	pop	r28
    15be:	df 91       	pop	r29
    15c0:	08 95       	ret

000015c2 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    15c2:	df 93       	push	r29
    15c4:	cf 93       	push	r28
    15c6:	cd b7       	in	r28, 0x3d	; 61
    15c8:	de b7       	in	r29, 0x3e	; 62
    15ca:	2e 97       	sbiw	r28, 0x0e	; 14
    15cc:	0f b6       	in	r0, 0x3f	; 63
    15ce:	f8 94       	cli
    15d0:	de bf       	out	0x3e, r29	; 62
    15d2:	0f be       	out	0x3f, r0	; 63
    15d4:	cd bf       	out	0x3d, r28	; 61
    15d6:	98 87       	std	Y+8, r25	; 0x08
    15d8:	8f 83       	std	Y+7, r24	; 0x07
    15da:	7a 87       	std	Y+10, r23	; 0x0a
    15dc:	69 87       	std	Y+9, r22	; 0x09
    15de:	5c 87       	std	Y+12, r21	; 0x0c
    15e0:	4b 87       	std	Y+11, r20	; 0x0b
    15e2:	2d 87       	std	Y+13, r18	; 0x0d
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    15e4:	1b 82       	std	Y+3, r1	; 0x03
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    15e6:	0f b6       	in	r0, 0x3f	; 63
    15e8:	f8 94       	cli
    15ea:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    15ec:	ef 81       	ldd	r30, Y+7	; 0x07
    15ee:	f8 85       	ldd	r31, Y+8	; 0x08
    15f0:	82 8d       	ldd	r24, Z+26	; 0x1a
    15f2:	88 23       	and	r24, r24
    15f4:	09 f4       	brne	.+2      	; 0x15f8 <xQueueGenericReceive+0x36>
    15f6:	4b c0       	rjmp	.+150    	; 0x168e <xQueueGenericReceive+0xcc>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    15f8:	ef 81       	ldd	r30, Y+7	; 0x07
    15fa:	f8 85       	ldd	r31, Y+8	; 0x08
    15fc:	86 81       	ldd	r24, Z+6	; 0x06
    15fe:	97 81       	ldd	r25, Z+7	; 0x07
    1600:	9a 83       	std	Y+2, r25	; 0x02
    1602:	89 83       	std	Y+1, r24	; 0x01

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1604:	8f 81       	ldd	r24, Y+7	; 0x07
    1606:	98 85       	ldd	r25, Y+8	; 0x08
    1608:	29 85       	ldd	r18, Y+9	; 0x09
    160a:	3a 85       	ldd	r19, Y+10	; 0x0a
    160c:	b9 01       	movw	r22, r18
    160e:	0e 94 f4 0c 	call	0x19e8	; 0x19e8 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1612:	8d 85       	ldd	r24, Y+13	; 0x0d
    1614:	88 23       	and	r24, r24
    1616:	11 f5       	brne	.+68     	; 0x165c <xQueueGenericReceive+0x9a>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    1618:	ef 81       	ldd	r30, Y+7	; 0x07
    161a:	f8 85       	ldd	r31, Y+8	; 0x08
    161c:	82 8d       	ldd	r24, Z+26	; 0x1a
    161e:	81 50       	subi	r24, 0x01	; 1
    1620:	ef 81       	ldd	r30, Y+7	; 0x07
    1622:	f8 85       	ldd	r31, Y+8	; 0x08
    1624:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1626:	ef 81       	ldd	r30, Y+7	; 0x07
    1628:	f8 85       	ldd	r31, Y+8	; 0x08
    162a:	80 81       	ld	r24, Z
    162c:	91 81       	ldd	r25, Z+1	; 0x01
    162e:	00 97       	sbiw	r24, 0x00	; 0
    1630:	31 f4       	brne	.+12     	; 0x163e <xQueueGenericReceive+0x7c>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
    1632:	0e 94 eb 14 	call	0x29d6	; 0x29d6 <xTaskGetCurrentTaskHandle>
    1636:	ef 81       	ldd	r30, Y+7	; 0x07
    1638:	f8 85       	ldd	r31, Y+8	; 0x08
    163a:	93 83       	std	Z+3, r25	; 0x03
    163c:	82 83       	std	Z+2, r24	; 0x02
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    163e:	ef 81       	ldd	r30, Y+7	; 0x07
    1640:	f8 85       	ldd	r31, Y+8	; 0x08
    1642:	80 85       	ldd	r24, Z+8	; 0x08
    1644:	88 23       	and	r24, r24
    1646:	f1 f0       	breq	.+60     	; 0x1684 <xQueueGenericReceive+0xc2>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1648:	8f 81       	ldd	r24, Y+7	; 0x07
    164a:	98 85       	ldd	r25, Y+8	; 0x08
    164c:	08 96       	adiw	r24, 0x08	; 8
    164e:	0e 94 74 12 	call	0x24e8	; 0x24e8 <xTaskRemoveFromEventList>
    1652:	81 30       	cpi	r24, 0x01	; 1
    1654:	b9 f4       	brne	.+46     	; 0x1684 <xQueueGenericReceive+0xc2>
						{
							portYIELD_WITHIN_API();
    1656:	0e 94 54 07 	call	0xea8	; 0xea8 <vPortYield>
    165a:	14 c0       	rjmp	.+40     	; 0x1684 <xQueueGenericReceive+0xc2>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    165c:	ef 81       	ldd	r30, Y+7	; 0x07
    165e:	f8 85       	ldd	r31, Y+8	; 0x08
    1660:	89 81       	ldd	r24, Y+1	; 0x01
    1662:	9a 81       	ldd	r25, Y+2	; 0x02
    1664:	97 83       	std	Z+7, r25	; 0x07
    1666:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1668:	ef 81       	ldd	r30, Y+7	; 0x07
    166a:	f8 85       	ldd	r31, Y+8	; 0x08
    166c:	81 89       	ldd	r24, Z+17	; 0x11
    166e:	88 23       	and	r24, r24
    1670:	49 f0       	breq	.+18     	; 0x1684 <xQueueGenericReceive+0xc2>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1672:	8f 81       	ldd	r24, Y+7	; 0x07
    1674:	98 85       	ldd	r25, Y+8	; 0x08
    1676:	41 96       	adiw	r24, 0x11	; 17
    1678:	0e 94 74 12 	call	0x24e8	; 0x24e8 <xTaskRemoveFromEventList>
    167c:	88 23       	and	r24, r24
    167e:	11 f0       	breq	.+4      	; 0x1684 <xQueueGenericReceive+0xc2>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    1680:	0e 94 54 07 	call	0xea8	; 0xea8 <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    1684:	0f 90       	pop	r0
    1686:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1688:	81 e0       	ldi	r24, 0x01	; 1
    168a:	8e 87       	std	Y+14, r24	; 0x0e
    168c:	6d c0       	rjmp	.+218    	; 0x1768 <xQueueGenericReceive+0x1a6>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    168e:	8b 85       	ldd	r24, Y+11	; 0x0b
    1690:	9c 85       	ldd	r25, Y+12	; 0x0c
    1692:	00 97       	sbiw	r24, 0x00	; 0
    1694:	21 f4       	brne	.+8      	; 0x169e <xQueueGenericReceive+0xdc>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1696:	0f 90       	pop	r0
    1698:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    169a:	1e 86       	std	Y+14, r1	; 0x0e
    169c:	65 c0       	rjmp	.+202    	; 0x1768 <xQueueGenericReceive+0x1a6>
				}
				else if( xEntryTimeSet == pdFALSE )
    169e:	8b 81       	ldd	r24, Y+3	; 0x03
    16a0:	88 23       	and	r24, r24
    16a2:	31 f4       	brne	.+12     	; 0x16b0 <xQueueGenericReceive+0xee>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    16a4:	ce 01       	movw	r24, r28
    16a6:	04 96       	adiw	r24, 0x04	; 4
    16a8:	0e 94 dc 12 	call	0x25b8	; 0x25b8 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    16ac:	81 e0       	ldi	r24, 0x01	; 1
    16ae:	8b 83       	std	Y+3, r24	; 0x03
				}
			}
		}
		taskEXIT_CRITICAL();
    16b0:	0f 90       	pop	r0
    16b2:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    16b4:	0e 94 38 10 	call	0x2070	; 0x2070 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    16b8:	0f b6       	in	r0, 0x3f	; 63
    16ba:	f8 94       	cli
    16bc:	0f 92       	push	r0
    16be:	ef 81       	ldd	r30, Y+7	; 0x07
    16c0:	f8 85       	ldd	r31, Y+8	; 0x08
    16c2:	85 8d       	ldd	r24, Z+29	; 0x1d
    16c4:	8f 3f       	cpi	r24, 0xFF	; 255
    16c6:	19 f4       	brne	.+6      	; 0x16ce <xQueueGenericReceive+0x10c>
    16c8:	ef 81       	ldd	r30, Y+7	; 0x07
    16ca:	f8 85       	ldd	r31, Y+8	; 0x08
    16cc:	15 8e       	std	Z+29, r1	; 0x1d
    16ce:	ef 81       	ldd	r30, Y+7	; 0x07
    16d0:	f8 85       	ldd	r31, Y+8	; 0x08
    16d2:	86 8d       	ldd	r24, Z+30	; 0x1e
    16d4:	8f 3f       	cpi	r24, 0xFF	; 255
    16d6:	19 f4       	brne	.+6      	; 0x16de <xQueueGenericReceive+0x11c>
    16d8:	ef 81       	ldd	r30, Y+7	; 0x07
    16da:	f8 85       	ldd	r31, Y+8	; 0x08
    16dc:	16 8e       	std	Z+30, r1	; 0x1e
    16de:	0f 90       	pop	r0
    16e0:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    16e2:	ce 01       	movw	r24, r28
    16e4:	04 96       	adiw	r24, 0x04	; 4
    16e6:	9e 01       	movw	r18, r28
    16e8:	25 5f       	subi	r18, 0xF5	; 245
    16ea:	3f 4f       	sbci	r19, 0xFF	; 255
    16ec:	b9 01       	movw	r22, r18
    16ee:	0e 94 f5 12 	call	0x25ea	; 0x25ea <xTaskCheckForTimeOut>
    16f2:	88 23       	and	r24, r24
    16f4:	91 f5       	brne	.+100    	; 0x175a <xQueueGenericReceive+0x198>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    16f6:	8f 81       	ldd	r24, Y+7	; 0x07
    16f8:	98 85       	ldd	r25, Y+8	; 0x08
    16fa:	0e 94 90 0d 	call	0x1b20	; 0x1b20 <prvIsQueueEmpty>
    16fe:	88 23       	and	r24, r24
    1700:	29 f1       	breq	.+74     	; 0x174c <xQueueGenericReceive+0x18a>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1702:	ef 81       	ldd	r30, Y+7	; 0x07
    1704:	f8 85       	ldd	r31, Y+8	; 0x08
    1706:	80 81       	ld	r24, Z
    1708:	91 81       	ldd	r25, Z+1	; 0x01
    170a:	00 97       	sbiw	r24, 0x00	; 0
    170c:	59 f4       	brne	.+22     	; 0x1724 <xQueueGenericReceive+0x162>
					{
						portENTER_CRITICAL();
    170e:	0f b6       	in	r0, 0x3f	; 63
    1710:	f8 94       	cli
    1712:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    1714:	ef 81       	ldd	r30, Y+7	; 0x07
    1716:	f8 85       	ldd	r31, Y+8	; 0x08
    1718:	82 81       	ldd	r24, Z+2	; 0x02
    171a:	93 81       	ldd	r25, Z+3	; 0x03
    171c:	0e 94 fd 14 	call	0x29fa	; 0x29fa <vTaskPriorityInherit>
						}
						portEXIT_CRITICAL();
    1720:	0f 90       	pop	r0
    1722:	0f be       	out	0x3f, r0	; 63
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1724:	8f 81       	ldd	r24, Y+7	; 0x07
    1726:	98 85       	ldd	r25, Y+8	; 0x08
    1728:	41 96       	adiw	r24, 0x11	; 17
    172a:	2b 85       	ldd	r18, Y+11	; 0x0b
    172c:	3c 85       	ldd	r19, Y+12	; 0x0c
    172e:	b9 01       	movw	r22, r18
    1730:	0e 94 3e 12 	call	0x247c	; 0x247c <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1734:	8f 81       	ldd	r24, Y+7	; 0x07
    1736:	98 85       	ldd	r25, Y+8	; 0x08
    1738:	0e 94 3c 0d 	call	0x1a78	; 0x1a78 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    173c:	0e 94 44 10 	call	0x2088	; 0x2088 <xTaskResumeAll>
    1740:	88 23       	and	r24, r24
    1742:	09 f0       	breq	.+2      	; 0x1746 <xQueueGenericReceive+0x184>
    1744:	50 cf       	rjmp	.-352    	; 0x15e6 <xQueueGenericReceive+0x24>
				{
					portYIELD_WITHIN_API();
    1746:	0e 94 54 07 	call	0xea8	; 0xea8 <vPortYield>
    174a:	4d cf       	rjmp	.-358    	; 0x15e6 <xQueueGenericReceive+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    174c:	8f 81       	ldd	r24, Y+7	; 0x07
    174e:	98 85       	ldd	r25, Y+8	; 0x08
    1750:	0e 94 3c 0d 	call	0x1a78	; 0x1a78 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1754:	0e 94 44 10 	call	0x2088	; 0x2088 <xTaskResumeAll>
    1758:	46 cf       	rjmp	.-372    	; 0x15e6 <xQueueGenericReceive+0x24>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    175a:	8f 81       	ldd	r24, Y+7	; 0x07
    175c:	98 85       	ldd	r25, Y+8	; 0x08
    175e:	0e 94 3c 0d 	call	0x1a78	; 0x1a78 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1762:	0e 94 44 10 	call	0x2088	; 0x2088 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1766:	1e 86       	std	Y+14, r1	; 0x0e
    1768:	8e 85       	ldd	r24, Y+14	; 0x0e
		}
	}
}
    176a:	2e 96       	adiw	r28, 0x0e	; 14
    176c:	0f b6       	in	r0, 0x3f	; 63
    176e:	f8 94       	cli
    1770:	de bf       	out	0x3e, r29	; 62
    1772:	0f be       	out	0x3f, r0	; 63
    1774:	cd bf       	out	0x3d, r28	; 61
    1776:	cf 91       	pop	r28
    1778:	df 91       	pop	r29
    177a:	08 95       	ret

0000177c <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    177c:	df 93       	push	r29
    177e:	cf 93       	push	r28
    1780:	cd b7       	in	r28, 0x3d	; 61
    1782:	de b7       	in	r29, 0x3e	; 62
    1784:	28 97       	sbiw	r28, 0x08	; 8
    1786:	0f b6       	in	r0, 0x3f	; 63
    1788:	f8 94       	cli
    178a:	de bf       	out	0x3e, r29	; 62
    178c:	0f be       	out	0x3f, r0	; 63
    178e:	cd bf       	out	0x3d, r28	; 61
    1790:	9c 83       	std	Y+4, r25	; 0x04
    1792:	8b 83       	std	Y+3, r24	; 0x03
    1794:	7e 83       	std	Y+6, r23	; 0x06
    1796:	6d 83       	std	Y+5, r22	; 0x05
    1798:	58 87       	std	Y+8, r21	; 0x08
    179a:	4f 83       	std	Y+7, r20	; 0x07

	configASSERT( pxQueue );
	configASSERT( pxTaskWoken );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    179c:	19 82       	std	Y+1, r1	; 0x01
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    179e:	eb 81       	ldd	r30, Y+3	; 0x03
    17a0:	fc 81       	ldd	r31, Y+4	; 0x04
    17a2:	82 8d       	ldd	r24, Z+26	; 0x1a
    17a4:	88 23       	and	r24, r24
    17a6:	71 f1       	breq	.+92     	; 0x1804 <xQueueReceiveFromISR+0x88>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    17a8:	8b 81       	ldd	r24, Y+3	; 0x03
    17aa:	9c 81       	ldd	r25, Y+4	; 0x04
    17ac:	2d 81       	ldd	r18, Y+5	; 0x05
    17ae:	3e 81       	ldd	r19, Y+6	; 0x06
    17b0:	b9 01       	movw	r22, r18
    17b2:	0e 94 f4 0c 	call	0x19e8	; 0x19e8 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    17b6:	eb 81       	ldd	r30, Y+3	; 0x03
    17b8:	fc 81       	ldd	r31, Y+4	; 0x04
    17ba:	82 8d       	ldd	r24, Z+26	; 0x1a
    17bc:	81 50       	subi	r24, 0x01	; 1
    17be:	eb 81       	ldd	r30, Y+3	; 0x03
    17c0:	fc 81       	ldd	r31, Y+4	; 0x04
    17c2:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    17c4:	eb 81       	ldd	r30, Y+3	; 0x03
    17c6:	fc 81       	ldd	r31, Y+4	; 0x04
    17c8:	85 8d       	ldd	r24, Z+29	; 0x1d
    17ca:	8f 3f       	cpi	r24, 0xFF	; 255
    17cc:	89 f4       	brne	.+34     	; 0x17f0 <xQueueReceiveFromISR+0x74>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    17ce:	eb 81       	ldd	r30, Y+3	; 0x03
    17d0:	fc 81       	ldd	r31, Y+4	; 0x04
    17d2:	80 85       	ldd	r24, Z+8	; 0x08
    17d4:	88 23       	and	r24, r24
    17d6:	99 f0       	breq	.+38     	; 0x17fe <xQueueReceiveFromISR+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    17d8:	8b 81       	ldd	r24, Y+3	; 0x03
    17da:	9c 81       	ldd	r25, Y+4	; 0x04
    17dc:	08 96       	adiw	r24, 0x08	; 8
    17de:	0e 94 74 12 	call	0x24e8	; 0x24e8 <xTaskRemoveFromEventList>
    17e2:	88 23       	and	r24, r24
    17e4:	61 f0       	breq	.+24     	; 0x17fe <xQueueReceiveFromISR+0x82>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    17e6:	ef 81       	ldd	r30, Y+7	; 0x07
    17e8:	f8 85       	ldd	r31, Y+8	; 0x08
    17ea:	81 e0       	ldi	r24, 0x01	; 1
    17ec:	80 83       	st	Z, r24
    17ee:	07 c0       	rjmp	.+14     	; 0x17fe <xQueueReceiveFromISR+0x82>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    17f0:	eb 81       	ldd	r30, Y+3	; 0x03
    17f2:	fc 81       	ldd	r31, Y+4	; 0x04
    17f4:	85 8d       	ldd	r24, Z+29	; 0x1d
    17f6:	8f 5f       	subi	r24, 0xFF	; 255
    17f8:	eb 81       	ldd	r30, Y+3	; 0x03
    17fa:	fc 81       	ldd	r31, Y+4	; 0x04
    17fc:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    17fe:	81 e0       	ldi	r24, 0x01	; 1
    1800:	8a 83       	std	Y+2, r24	; 0x02
    1802:	01 c0       	rjmp	.+2      	; 0x1806 <xQueueReceiveFromISR+0x8a>
		}
		else
		{
			xReturn = pdFAIL;
    1804:	1a 82       	std	Y+2, r1	; 0x02
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1806:	8a 81       	ldd	r24, Y+2	; 0x02
}
    1808:	28 96       	adiw	r28, 0x08	; 8
    180a:	0f b6       	in	r0, 0x3f	; 63
    180c:	f8 94       	cli
    180e:	de bf       	out	0x3e, r29	; 62
    1810:	0f be       	out	0x3f, r0	; 63
    1812:	cd bf       	out	0x3d, r28	; 61
    1814:	cf 91       	pop	r28
    1816:	df 91       	pop	r29
    1818:	08 95       	ret

0000181a <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    181a:	df 93       	push	r29
    181c:	cf 93       	push	r28
    181e:	00 d0       	rcall	.+0      	; 0x1820 <uxQueueMessagesWaiting+0x6>
    1820:	0f 92       	push	r0
    1822:	cd b7       	in	r28, 0x3d	; 61
    1824:	de b7       	in	r29, 0x3e	; 62
    1826:	9b 83       	std	Y+3, r25	; 0x03
    1828:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    182a:	0f b6       	in	r0, 0x3f	; 63
    182c:	f8 94       	cli
    182e:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    1830:	ea 81       	ldd	r30, Y+2	; 0x02
    1832:	fb 81       	ldd	r31, Y+3	; 0x03
    1834:	82 8d       	ldd	r24, Z+26	; 0x1a
    1836:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    1838:	0f 90       	pop	r0
    183a:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    183c:	89 81       	ldd	r24, Y+1	; 0x01
}
    183e:	0f 90       	pop	r0
    1840:	0f 90       	pop	r0
    1842:	0f 90       	pop	r0
    1844:	cf 91       	pop	r28
    1846:	df 91       	pop	r29
    1848:	08 95       	ret

0000184a <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    184a:	df 93       	push	r29
    184c:	cf 93       	push	r28
    184e:	00 d0       	rcall	.+0      	; 0x1850 <uxQueueMessagesWaitingFromISR+0x6>
    1850:	0f 92       	push	r0
    1852:	cd b7       	in	r28, 0x3d	; 61
    1854:	de b7       	in	r29, 0x3e	; 62
    1856:	9b 83       	std	Y+3, r25	; 0x03
    1858:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    185a:	ea 81       	ldd	r30, Y+2	; 0x02
    185c:	fb 81       	ldd	r31, Y+3	; 0x03
    185e:	82 8d       	ldd	r24, Z+26	; 0x1a
    1860:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    1862:	89 81       	ldd	r24, Y+1	; 0x01
}
    1864:	0f 90       	pop	r0
    1866:	0f 90       	pop	r0
    1868:	0f 90       	pop	r0
    186a:	cf 91       	pop	r28
    186c:	df 91       	pop	r29
    186e:	08 95       	ret

00001870 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    1870:	df 93       	push	r29
    1872:	cf 93       	push	r28
    1874:	00 d0       	rcall	.+0      	; 0x1876 <vQueueDelete+0x6>
    1876:	cd b7       	in	r28, 0x3d	; 61
    1878:	de b7       	in	r29, 0x3e	; 62
    187a:	9a 83       	std	Y+2, r25	; 0x02
    187c:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    187e:	e9 81       	ldd	r30, Y+1	; 0x01
    1880:	fa 81       	ldd	r31, Y+2	; 0x02
    1882:	80 81       	ld	r24, Z
    1884:	91 81       	ldd	r25, Z+1	; 0x01
    1886:	0e 94 67 03 	call	0x6ce	; 0x6ce <vPortFree>
	vPortFree( pxQueue );
    188a:	89 81       	ldd	r24, Y+1	; 0x01
    188c:	9a 81       	ldd	r25, Y+2	; 0x02
    188e:	0e 94 67 03 	call	0x6ce	; 0x6ce <vPortFree>
}
    1892:	0f 90       	pop	r0
    1894:	0f 90       	pop	r0
    1896:	cf 91       	pop	r28
    1898:	df 91       	pop	r29
    189a:	08 95       	ret

0000189c <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    189c:	df 93       	push	r29
    189e:	cf 93       	push	r28
    18a0:	00 d0       	rcall	.+0      	; 0x18a2 <prvCopyDataToQueue+0x6>
    18a2:	00 d0       	rcall	.+0      	; 0x18a4 <prvCopyDataToQueue+0x8>
    18a4:	0f 92       	push	r0
    18a6:	cd b7       	in	r28, 0x3d	; 61
    18a8:	de b7       	in	r29, 0x3e	; 62
    18aa:	9a 83       	std	Y+2, r25	; 0x02
    18ac:	89 83       	std	Y+1, r24	; 0x01
    18ae:	7c 83       	std	Y+4, r23	; 0x04
    18b0:	6b 83       	std	Y+3, r22	; 0x03
    18b2:	4d 83       	std	Y+5, r20	; 0x05
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    18b4:	e9 81       	ldd	r30, Y+1	; 0x01
    18b6:	fa 81       	ldd	r31, Y+2	; 0x02
    18b8:	84 8d       	ldd	r24, Z+28	; 0x1c
    18ba:	88 23       	and	r24, r24
    18bc:	91 f4       	brne	.+36     	; 0x18e2 <prvCopyDataToQueue+0x46>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    18be:	e9 81       	ldd	r30, Y+1	; 0x01
    18c0:	fa 81       	ldd	r31, Y+2	; 0x02
    18c2:	80 81       	ld	r24, Z
    18c4:	91 81       	ldd	r25, Z+1	; 0x01
    18c6:	00 97       	sbiw	r24, 0x00	; 0
    18c8:	09 f0       	breq	.+2      	; 0x18cc <prvCopyDataToQueue+0x30>
    18ca:	7f c0       	rjmp	.+254    	; 0x19ca <prvCopyDataToQueue+0x12e>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
    18cc:	e9 81       	ldd	r30, Y+1	; 0x01
    18ce:	fa 81       	ldd	r31, Y+2	; 0x02
    18d0:	82 81       	ldd	r24, Z+2	; 0x02
    18d2:	93 81       	ldd	r25, Z+3	; 0x03
    18d4:	0e 94 7d 15 	call	0x2afa	; 0x2afa <vTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
    18d8:	e9 81       	ldd	r30, Y+1	; 0x01
    18da:	fa 81       	ldd	r31, Y+2	; 0x02
    18dc:	13 82       	std	Z+3, r1	; 0x03
    18de:	12 82       	std	Z+2, r1	; 0x02
    18e0:	74 c0       	rjmp	.+232    	; 0x19ca <prvCopyDataToQueue+0x12e>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    18e2:	8d 81       	ldd	r24, Y+5	; 0x05
    18e4:	88 23       	and	r24, r24
    18e6:	99 f5       	brne	.+102    	; 0x194e <prvCopyDataToQueue+0xb2>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    18e8:	e9 81       	ldd	r30, Y+1	; 0x01
    18ea:	fa 81       	ldd	r31, Y+2	; 0x02
    18ec:	64 81       	ldd	r22, Z+4	; 0x04
    18ee:	75 81       	ldd	r23, Z+5	; 0x05
    18f0:	e9 81       	ldd	r30, Y+1	; 0x01
    18f2:	fa 81       	ldd	r31, Y+2	; 0x02
    18f4:	84 8d       	ldd	r24, Z+28	; 0x1c
    18f6:	48 2f       	mov	r20, r24
    18f8:	50 e0       	ldi	r21, 0x00	; 0
    18fa:	2b 81       	ldd	r18, Y+3	; 0x03
    18fc:	3c 81       	ldd	r19, Y+4	; 0x04
    18fe:	cb 01       	movw	r24, r22
    1900:	b9 01       	movw	r22, r18
    1902:	0e 94 dc 15 	call	0x2bb8	; 0x2bb8 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    1906:	e9 81       	ldd	r30, Y+1	; 0x01
    1908:	fa 81       	ldd	r31, Y+2	; 0x02
    190a:	24 81       	ldd	r18, Z+4	; 0x04
    190c:	35 81       	ldd	r19, Z+5	; 0x05
    190e:	e9 81       	ldd	r30, Y+1	; 0x01
    1910:	fa 81       	ldd	r31, Y+2	; 0x02
    1912:	84 8d       	ldd	r24, Z+28	; 0x1c
    1914:	88 2f       	mov	r24, r24
    1916:	90 e0       	ldi	r25, 0x00	; 0
    1918:	82 0f       	add	r24, r18
    191a:	93 1f       	adc	r25, r19
    191c:	e9 81       	ldd	r30, Y+1	; 0x01
    191e:	fa 81       	ldd	r31, Y+2	; 0x02
    1920:	95 83       	std	Z+5, r25	; 0x05
    1922:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    1924:	e9 81       	ldd	r30, Y+1	; 0x01
    1926:	fa 81       	ldd	r31, Y+2	; 0x02
    1928:	24 81       	ldd	r18, Z+4	; 0x04
    192a:	35 81       	ldd	r19, Z+5	; 0x05
    192c:	e9 81       	ldd	r30, Y+1	; 0x01
    192e:	fa 81       	ldd	r31, Y+2	; 0x02
    1930:	82 81       	ldd	r24, Z+2	; 0x02
    1932:	93 81       	ldd	r25, Z+3	; 0x03
    1934:	28 17       	cp	r18, r24
    1936:	39 07       	cpc	r19, r25
    1938:	08 f4       	brcc	.+2      	; 0x193c <prvCopyDataToQueue+0xa0>
    193a:	47 c0       	rjmp	.+142    	; 0x19ca <prvCopyDataToQueue+0x12e>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    193c:	e9 81       	ldd	r30, Y+1	; 0x01
    193e:	fa 81       	ldd	r31, Y+2	; 0x02
    1940:	80 81       	ld	r24, Z
    1942:	91 81       	ldd	r25, Z+1	; 0x01
    1944:	e9 81       	ldd	r30, Y+1	; 0x01
    1946:	fa 81       	ldd	r31, Y+2	; 0x02
    1948:	95 83       	std	Z+5, r25	; 0x05
    194a:	84 83       	std	Z+4, r24	; 0x04
    194c:	3e c0       	rjmp	.+124    	; 0x19ca <prvCopyDataToQueue+0x12e>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    194e:	e9 81       	ldd	r30, Y+1	; 0x01
    1950:	fa 81       	ldd	r31, Y+2	; 0x02
    1952:	66 81       	ldd	r22, Z+6	; 0x06
    1954:	77 81       	ldd	r23, Z+7	; 0x07
    1956:	e9 81       	ldd	r30, Y+1	; 0x01
    1958:	fa 81       	ldd	r31, Y+2	; 0x02
    195a:	84 8d       	ldd	r24, Z+28	; 0x1c
    195c:	48 2f       	mov	r20, r24
    195e:	50 e0       	ldi	r21, 0x00	; 0
    1960:	2b 81       	ldd	r18, Y+3	; 0x03
    1962:	3c 81       	ldd	r19, Y+4	; 0x04
    1964:	cb 01       	movw	r24, r22
    1966:	b9 01       	movw	r22, r18
    1968:	0e 94 dc 15 	call	0x2bb8	; 0x2bb8 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    196c:	e9 81       	ldd	r30, Y+1	; 0x01
    196e:	fa 81       	ldd	r31, Y+2	; 0x02
    1970:	26 81       	ldd	r18, Z+6	; 0x06
    1972:	37 81       	ldd	r19, Z+7	; 0x07
    1974:	e9 81       	ldd	r30, Y+1	; 0x01
    1976:	fa 81       	ldd	r31, Y+2	; 0x02
    1978:	84 8d       	ldd	r24, Z+28	; 0x1c
    197a:	88 2f       	mov	r24, r24
    197c:	90 e0       	ldi	r25, 0x00	; 0
    197e:	90 95       	com	r25
    1980:	81 95       	neg	r24
    1982:	9f 4f       	sbci	r25, 0xFF	; 255
    1984:	82 0f       	add	r24, r18
    1986:	93 1f       	adc	r25, r19
    1988:	e9 81       	ldd	r30, Y+1	; 0x01
    198a:	fa 81       	ldd	r31, Y+2	; 0x02
    198c:	97 83       	std	Z+7, r25	; 0x07
    198e:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    1990:	e9 81       	ldd	r30, Y+1	; 0x01
    1992:	fa 81       	ldd	r31, Y+2	; 0x02
    1994:	26 81       	ldd	r18, Z+6	; 0x06
    1996:	37 81       	ldd	r19, Z+7	; 0x07
    1998:	e9 81       	ldd	r30, Y+1	; 0x01
    199a:	fa 81       	ldd	r31, Y+2	; 0x02
    199c:	80 81       	ld	r24, Z
    199e:	91 81       	ldd	r25, Z+1	; 0x01
    19a0:	28 17       	cp	r18, r24
    19a2:	39 07       	cpc	r19, r25
    19a4:	90 f4       	brcc	.+36     	; 0x19ca <prvCopyDataToQueue+0x12e>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    19a6:	e9 81       	ldd	r30, Y+1	; 0x01
    19a8:	fa 81       	ldd	r31, Y+2	; 0x02
    19aa:	22 81       	ldd	r18, Z+2	; 0x02
    19ac:	33 81       	ldd	r19, Z+3	; 0x03
    19ae:	e9 81       	ldd	r30, Y+1	; 0x01
    19b0:	fa 81       	ldd	r31, Y+2	; 0x02
    19b2:	84 8d       	ldd	r24, Z+28	; 0x1c
    19b4:	88 2f       	mov	r24, r24
    19b6:	90 e0       	ldi	r25, 0x00	; 0
    19b8:	90 95       	com	r25
    19ba:	81 95       	neg	r24
    19bc:	9f 4f       	sbci	r25, 0xFF	; 255
    19be:	82 0f       	add	r24, r18
    19c0:	93 1f       	adc	r25, r19
    19c2:	e9 81       	ldd	r30, Y+1	; 0x01
    19c4:	fa 81       	ldd	r31, Y+2	; 0x02
    19c6:	97 83       	std	Z+7, r25	; 0x07
    19c8:	86 83       	std	Z+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    19ca:	e9 81       	ldd	r30, Y+1	; 0x01
    19cc:	fa 81       	ldd	r31, Y+2	; 0x02
    19ce:	82 8d       	ldd	r24, Z+26	; 0x1a
    19d0:	8f 5f       	subi	r24, 0xFF	; 255
    19d2:	e9 81       	ldd	r30, Y+1	; 0x01
    19d4:	fa 81       	ldd	r31, Y+2	; 0x02
    19d6:	82 8f       	std	Z+26, r24	; 0x1a
}
    19d8:	0f 90       	pop	r0
    19da:	0f 90       	pop	r0
    19dc:	0f 90       	pop	r0
    19de:	0f 90       	pop	r0
    19e0:	0f 90       	pop	r0
    19e2:	cf 91       	pop	r28
    19e4:	df 91       	pop	r29
    19e6:	08 95       	ret

000019e8 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    19e8:	df 93       	push	r29
    19ea:	cf 93       	push	r28
    19ec:	00 d0       	rcall	.+0      	; 0x19ee <prvCopyDataFromQueue+0x6>
    19ee:	00 d0       	rcall	.+0      	; 0x19f0 <prvCopyDataFromQueue+0x8>
    19f0:	cd b7       	in	r28, 0x3d	; 61
    19f2:	de b7       	in	r29, 0x3e	; 62
    19f4:	9a 83       	std	Y+2, r25	; 0x02
    19f6:	89 83       	std	Y+1, r24	; 0x01
    19f8:	7c 83       	std	Y+4, r23	; 0x04
    19fa:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    19fc:	e9 81       	ldd	r30, Y+1	; 0x01
    19fe:	fa 81       	ldd	r31, Y+2	; 0x02
    1a00:	80 81       	ld	r24, Z
    1a02:	91 81       	ldd	r25, Z+1	; 0x01
    1a04:	00 97       	sbiw	r24, 0x00	; 0
    1a06:	89 f1       	breq	.+98     	; 0x1a6a <prvCopyDataFromQueue+0x82>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    1a08:	e9 81       	ldd	r30, Y+1	; 0x01
    1a0a:	fa 81       	ldd	r31, Y+2	; 0x02
    1a0c:	26 81       	ldd	r18, Z+6	; 0x06
    1a0e:	37 81       	ldd	r19, Z+7	; 0x07
    1a10:	e9 81       	ldd	r30, Y+1	; 0x01
    1a12:	fa 81       	ldd	r31, Y+2	; 0x02
    1a14:	84 8d       	ldd	r24, Z+28	; 0x1c
    1a16:	88 2f       	mov	r24, r24
    1a18:	90 e0       	ldi	r25, 0x00	; 0
    1a1a:	82 0f       	add	r24, r18
    1a1c:	93 1f       	adc	r25, r19
    1a1e:	e9 81       	ldd	r30, Y+1	; 0x01
    1a20:	fa 81       	ldd	r31, Y+2	; 0x02
    1a22:	97 83       	std	Z+7, r25	; 0x07
    1a24:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    1a26:	e9 81       	ldd	r30, Y+1	; 0x01
    1a28:	fa 81       	ldd	r31, Y+2	; 0x02
    1a2a:	26 81       	ldd	r18, Z+6	; 0x06
    1a2c:	37 81       	ldd	r19, Z+7	; 0x07
    1a2e:	e9 81       	ldd	r30, Y+1	; 0x01
    1a30:	fa 81       	ldd	r31, Y+2	; 0x02
    1a32:	82 81       	ldd	r24, Z+2	; 0x02
    1a34:	93 81       	ldd	r25, Z+3	; 0x03
    1a36:	28 17       	cp	r18, r24
    1a38:	39 07       	cpc	r19, r25
    1a3a:	40 f0       	brcs	.+16     	; 0x1a4c <prvCopyDataFromQueue+0x64>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    1a3c:	e9 81       	ldd	r30, Y+1	; 0x01
    1a3e:	fa 81       	ldd	r31, Y+2	; 0x02
    1a40:	80 81       	ld	r24, Z
    1a42:	91 81       	ldd	r25, Z+1	; 0x01
    1a44:	e9 81       	ldd	r30, Y+1	; 0x01
    1a46:	fa 81       	ldd	r31, Y+2	; 0x02
    1a48:	97 83       	std	Z+7, r25	; 0x07
    1a4a:	86 83       	std	Z+6, r24	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1a4c:	e9 81       	ldd	r30, Y+1	; 0x01
    1a4e:	fa 81       	ldd	r31, Y+2	; 0x02
    1a50:	46 81       	ldd	r20, Z+6	; 0x06
    1a52:	57 81       	ldd	r21, Z+7	; 0x07
    1a54:	e9 81       	ldd	r30, Y+1	; 0x01
    1a56:	fa 81       	ldd	r31, Y+2	; 0x02
    1a58:	84 8d       	ldd	r24, Z+28	; 0x1c
    1a5a:	28 2f       	mov	r18, r24
    1a5c:	30 e0       	ldi	r19, 0x00	; 0
    1a5e:	8b 81       	ldd	r24, Y+3	; 0x03
    1a60:	9c 81       	ldd	r25, Y+4	; 0x04
    1a62:	ba 01       	movw	r22, r20
    1a64:	a9 01       	movw	r20, r18
    1a66:	0e 94 dc 15 	call	0x2bb8	; 0x2bb8 <memcpy>
	}
}
    1a6a:	0f 90       	pop	r0
    1a6c:	0f 90       	pop	r0
    1a6e:	0f 90       	pop	r0
    1a70:	0f 90       	pop	r0
    1a72:	cf 91       	pop	r28
    1a74:	df 91       	pop	r29
    1a76:	08 95       	ret

00001a78 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    1a78:	df 93       	push	r29
    1a7a:	cf 93       	push	r28
    1a7c:	00 d0       	rcall	.+0      	; 0x1a7e <prvUnlockQueue+0x6>
    1a7e:	cd b7       	in	r28, 0x3d	; 61
    1a80:	de b7       	in	r29, 0x3e	; 62
    1a82:	9a 83       	std	Y+2, r25	; 0x02
    1a84:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    1a86:	0f b6       	in	r0, 0x3f	; 63
    1a88:	f8 94       	cli
    1a8a:	0f 92       	push	r0
    1a8c:	15 c0       	rjmp	.+42     	; 0x1ab8 <prvUnlockQueue+0x40>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1a8e:	e9 81       	ldd	r30, Y+1	; 0x01
    1a90:	fa 81       	ldd	r31, Y+2	; 0x02
    1a92:	81 89       	ldd	r24, Z+17	; 0x11
    1a94:	88 23       	and	r24, r24
    1a96:	a9 f0       	breq	.+42     	; 0x1ac2 <prvUnlockQueue+0x4a>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1a98:	89 81       	ldd	r24, Y+1	; 0x01
    1a9a:	9a 81       	ldd	r25, Y+2	; 0x02
    1a9c:	41 96       	adiw	r24, 0x11	; 17
    1a9e:	0e 94 74 12 	call	0x24e8	; 0x24e8 <xTaskRemoveFromEventList>
    1aa2:	88 23       	and	r24, r24
    1aa4:	11 f0       	breq	.+4      	; 0x1aaa <prvUnlockQueue+0x32>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    1aa6:	0e 94 52 13 	call	0x26a4	; 0x26a4 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    1aaa:	e9 81       	ldd	r30, Y+1	; 0x01
    1aac:	fa 81       	ldd	r31, Y+2	; 0x02
    1aae:	86 8d       	ldd	r24, Z+30	; 0x1e
    1ab0:	81 50       	subi	r24, 0x01	; 1
    1ab2:	e9 81       	ldd	r30, Y+1	; 0x01
    1ab4:	fa 81       	ldd	r31, Y+2	; 0x02
    1ab6:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    1ab8:	e9 81       	ldd	r30, Y+1	; 0x01
    1aba:	fa 81       	ldd	r31, Y+2	; 0x02
    1abc:	86 8d       	ldd	r24, Z+30	; 0x1e
    1abe:	18 16       	cp	r1, r24
    1ac0:	34 f3       	brlt	.-52     	; 0x1a8e <prvUnlockQueue+0x16>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    1ac2:	e9 81       	ldd	r30, Y+1	; 0x01
    1ac4:	fa 81       	ldd	r31, Y+2	; 0x02
    1ac6:	8f ef       	ldi	r24, 0xFF	; 255
    1ac8:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    1aca:	0f 90       	pop	r0
    1acc:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    1ace:	0f b6       	in	r0, 0x3f	; 63
    1ad0:	f8 94       	cli
    1ad2:	0f 92       	push	r0
    1ad4:	15 c0       	rjmp	.+42     	; 0x1b00 <prvUnlockQueue+0x88>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1ad6:	e9 81       	ldd	r30, Y+1	; 0x01
    1ad8:	fa 81       	ldd	r31, Y+2	; 0x02
    1ada:	80 85       	ldd	r24, Z+8	; 0x08
    1adc:	88 23       	and	r24, r24
    1ade:	a9 f0       	breq	.+42     	; 0x1b0a <prvUnlockQueue+0x92>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1ae0:	89 81       	ldd	r24, Y+1	; 0x01
    1ae2:	9a 81       	ldd	r25, Y+2	; 0x02
    1ae4:	08 96       	adiw	r24, 0x08	; 8
    1ae6:	0e 94 74 12 	call	0x24e8	; 0x24e8 <xTaskRemoveFromEventList>
    1aea:	88 23       	and	r24, r24
    1aec:	11 f0       	breq	.+4      	; 0x1af2 <prvUnlockQueue+0x7a>
				{
					vTaskMissedYield();
    1aee:	0e 94 52 13 	call	0x26a4	; 0x26a4 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    1af2:	e9 81       	ldd	r30, Y+1	; 0x01
    1af4:	fa 81       	ldd	r31, Y+2	; 0x02
    1af6:	85 8d       	ldd	r24, Z+29	; 0x1d
    1af8:	81 50       	subi	r24, 0x01	; 1
    1afa:	e9 81       	ldd	r30, Y+1	; 0x01
    1afc:	fa 81       	ldd	r31, Y+2	; 0x02
    1afe:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    1b00:	e9 81       	ldd	r30, Y+1	; 0x01
    1b02:	fa 81       	ldd	r31, Y+2	; 0x02
    1b04:	85 8d       	ldd	r24, Z+29	; 0x1d
    1b06:	18 16       	cp	r1, r24
    1b08:	34 f3       	brlt	.-52     	; 0x1ad6 <prvUnlockQueue+0x5e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    1b0a:	e9 81       	ldd	r30, Y+1	; 0x01
    1b0c:	fa 81       	ldd	r31, Y+2	; 0x02
    1b0e:	8f ef       	ldi	r24, 0xFF	; 255
    1b10:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    1b12:	0f 90       	pop	r0
    1b14:	0f be       	out	0x3f, r0	; 63
}
    1b16:	0f 90       	pop	r0
    1b18:	0f 90       	pop	r0
    1b1a:	cf 91       	pop	r28
    1b1c:	df 91       	pop	r29
    1b1e:	08 95       	ret

00001b20 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
    1b20:	df 93       	push	r29
    1b22:	cf 93       	push	r28
    1b24:	00 d0       	rcall	.+0      	; 0x1b26 <prvIsQueueEmpty+0x6>
    1b26:	0f 92       	push	r0
    1b28:	cd b7       	in	r28, 0x3d	; 61
    1b2a:	de b7       	in	r29, 0x3e	; 62
    1b2c:	9b 83       	std	Y+3, r25	; 0x03
    1b2e:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    1b30:	0f b6       	in	r0, 0x3f	; 63
    1b32:	f8 94       	cli
    1b34:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    1b36:	ea 81       	ldd	r30, Y+2	; 0x02
    1b38:	fb 81       	ldd	r31, Y+3	; 0x03
    1b3a:	82 8d       	ldd	r24, Z+26	; 0x1a
    1b3c:	19 82       	std	Y+1, r1	; 0x01
    1b3e:	88 23       	and	r24, r24
    1b40:	11 f4       	brne	.+4      	; 0x1b46 <prvIsQueueEmpty+0x26>
    1b42:	81 e0       	ldi	r24, 0x01	; 1
    1b44:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    1b46:	0f 90       	pop	r0
    1b48:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    1b4a:	89 81       	ldd	r24, Y+1	; 0x01
}
    1b4c:	0f 90       	pop	r0
    1b4e:	0f 90       	pop	r0
    1b50:	0f 90       	pop	r0
    1b52:	cf 91       	pop	r28
    1b54:	df 91       	pop	r29
    1b56:	08 95       	ret

00001b58 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    1b58:	df 93       	push	r29
    1b5a:	cf 93       	push	r28
    1b5c:	00 d0       	rcall	.+0      	; 0x1b5e <xQueueIsQueueEmptyFromISR+0x6>
    1b5e:	0f 92       	push	r0
    1b60:	cd b7       	in	r28, 0x3d	; 61
    1b62:	de b7       	in	r29, 0x3e	; 62
    1b64:	9b 83       	std	Y+3, r25	; 0x03
    1b66:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    1b68:	ea 81       	ldd	r30, Y+2	; 0x02
    1b6a:	fb 81       	ldd	r31, Y+3	; 0x03
    1b6c:	82 8d       	ldd	r24, Z+26	; 0x1a
    1b6e:	19 82       	std	Y+1, r1	; 0x01
    1b70:	88 23       	and	r24, r24
    1b72:	11 f4       	brne	.+4      	; 0x1b78 <xQueueIsQueueEmptyFromISR+0x20>
    1b74:	81 e0       	ldi	r24, 0x01	; 1
    1b76:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    1b78:	89 81       	ldd	r24, Y+1	; 0x01
}
    1b7a:	0f 90       	pop	r0
    1b7c:	0f 90       	pop	r0
    1b7e:	0f 90       	pop	r0
    1b80:	cf 91       	pop	r28
    1b82:	df 91       	pop	r29
    1b84:	08 95       	ret

00001b86 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
    1b86:	df 93       	push	r29
    1b88:	cf 93       	push	r28
    1b8a:	00 d0       	rcall	.+0      	; 0x1b8c <prvIsQueueFull+0x6>
    1b8c:	0f 92       	push	r0
    1b8e:	cd b7       	in	r28, 0x3d	; 61
    1b90:	de b7       	in	r29, 0x3e	; 62
    1b92:	9b 83       	std	Y+3, r25	; 0x03
    1b94:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    1b96:	0f b6       	in	r0, 0x3f	; 63
    1b98:	f8 94       	cli
    1b9a:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    1b9c:	ea 81       	ldd	r30, Y+2	; 0x02
    1b9e:	fb 81       	ldd	r31, Y+3	; 0x03
    1ba0:	92 8d       	ldd	r25, Z+26	; 0x1a
    1ba2:	ea 81       	ldd	r30, Y+2	; 0x02
    1ba4:	fb 81       	ldd	r31, Y+3	; 0x03
    1ba6:	83 8d       	ldd	r24, Z+27	; 0x1b
    1ba8:	19 82       	std	Y+1, r1	; 0x01
    1baa:	98 17       	cp	r25, r24
    1bac:	11 f4       	brne	.+4      	; 0x1bb2 <prvIsQueueFull+0x2c>
    1bae:	81 e0       	ldi	r24, 0x01	; 1
    1bb0:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    1bb2:	0f 90       	pop	r0
    1bb4:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    1bb6:	89 81       	ldd	r24, Y+1	; 0x01
}
    1bb8:	0f 90       	pop	r0
    1bba:	0f 90       	pop	r0
    1bbc:	0f 90       	pop	r0
    1bbe:	cf 91       	pop	r28
    1bc0:	df 91       	pop	r29
    1bc2:	08 95       	ret

00001bc4 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    1bc4:	df 93       	push	r29
    1bc6:	cf 93       	push	r28
    1bc8:	00 d0       	rcall	.+0      	; 0x1bca <xQueueIsQueueFullFromISR+0x6>
    1bca:	0f 92       	push	r0
    1bcc:	cd b7       	in	r28, 0x3d	; 61
    1bce:	de b7       	in	r29, 0x3e	; 62
    1bd0:	9b 83       	std	Y+3, r25	; 0x03
    1bd2:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    1bd4:	ea 81       	ldd	r30, Y+2	; 0x02
    1bd6:	fb 81       	ldd	r31, Y+3	; 0x03
    1bd8:	92 8d       	ldd	r25, Z+26	; 0x1a
    1bda:	ea 81       	ldd	r30, Y+2	; 0x02
    1bdc:	fb 81       	ldd	r31, Y+3	; 0x03
    1bde:	83 8d       	ldd	r24, Z+27	; 0x1b
    1be0:	19 82       	std	Y+1, r1	; 0x01
    1be2:	98 17       	cp	r25, r24
    1be4:	11 f4       	brne	.+4      	; 0x1bea <xQueueIsQueueFullFromISR+0x26>
    1be6:	81 e0       	ldi	r24, 0x01	; 1
    1be8:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    1bea:	89 81       	ldd	r24, Y+1	; 0x01
}
    1bec:	0f 90       	pop	r0
    1bee:	0f 90       	pop	r0
    1bf0:	0f 90       	pop	r0
    1bf2:	cf 91       	pop	r28
    1bf4:	df 91       	pop	r29
    1bf6:	08 95       	ret

00001bf8 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    1bf8:	af 92       	push	r10
    1bfa:	bf 92       	push	r11
    1bfc:	cf 92       	push	r12
    1bfe:	df 92       	push	r13
    1c00:	ef 92       	push	r14
    1c02:	ff 92       	push	r15
    1c04:	0f 93       	push	r16
    1c06:	1f 93       	push	r17
    1c08:	df 93       	push	r29
    1c0a:	cf 93       	push	r28
    1c0c:	cd b7       	in	r28, 0x3d	; 61
    1c0e:	de b7       	in	r29, 0x3e	; 62
    1c10:	64 97       	sbiw	r28, 0x14	; 20
    1c12:	0f b6       	in	r0, 0x3f	; 63
    1c14:	f8 94       	cli
    1c16:	de bf       	out	0x3e, r29	; 62
    1c18:	0f be       	out	0x3f, r0	; 63
    1c1a:	cd bf       	out	0x3d, r28	; 61
    1c1c:	9f 83       	std	Y+7, r25	; 0x07
    1c1e:	8e 83       	std	Y+6, r24	; 0x06
    1c20:	79 87       	std	Y+9, r23	; 0x09
    1c22:	68 87       	std	Y+8, r22	; 0x08
    1c24:	5b 87       	std	Y+11, r21	; 0x0b
    1c26:	4a 87       	std	Y+10, r20	; 0x0a
    1c28:	3d 87       	std	Y+13, r19	; 0x0d
    1c2a:	2c 87       	std	Y+12, r18	; 0x0c
    1c2c:	0e 87       	std	Y+14, r16	; 0x0e
    1c2e:	f8 8a       	std	Y+16, r15	; 0x10
    1c30:	ef 86       	std	Y+15, r14	; 0x0f
    1c32:	da 8a       	std	Y+18, r13	; 0x12
    1c34:	c9 8a       	std	Y+17, r12	; 0x11
    1c36:	bc 8a       	std	Y+20, r11	; 0x14
    1c38:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    1c3a:	8a 85       	ldd	r24, Y+10	; 0x0a
    1c3c:	9b 85       	ldd	r25, Y+11	; 0x0b
    1c3e:	29 89       	ldd	r18, Y+17	; 0x11
    1c40:	3a 89       	ldd	r19, Y+18	; 0x12
    1c42:	b9 01       	movw	r22, r18
    1c44:	0e 94 85 14 	call	0x290a	; 0x290a <prvAllocateTCBAndStack>
    1c48:	9c 83       	std	Y+4, r25	; 0x04
    1c4a:	8b 83       	std	Y+3, r24	; 0x03

	if( pxNewTCB != NULL )
    1c4c:	8b 81       	ldd	r24, Y+3	; 0x03
    1c4e:	9c 81       	ldd	r25, Y+4	; 0x04
    1c50:	00 97       	sbiw	r24, 0x00	; 0
    1c52:	09 f4       	brne	.+2      	; 0x1c56 <xTaskGenericCreate+0x5e>
    1c54:	99 c0       	rjmp	.+306    	; 0x1d88 <xTaskGenericCreate+0x190>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    1c56:	eb 81       	ldd	r30, Y+3	; 0x03
    1c58:	fc 81       	ldd	r31, Y+4	; 0x04
    1c5a:	27 89       	ldd	r18, Z+23	; 0x17
    1c5c:	30 8d       	ldd	r19, Z+24	; 0x18
    1c5e:	8a 85       	ldd	r24, Y+10	; 0x0a
    1c60:	9b 85       	ldd	r25, Y+11	; 0x0b
    1c62:	01 97       	sbiw	r24, 0x01	; 1
    1c64:	82 0f       	add	r24, r18
    1c66:	93 1f       	adc	r25, r19
    1c68:	9a 83       	std	Y+2, r25	; 0x02
    1c6a:	89 83       	std	Y+1, r24	; 0x01
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    1c6c:	8b 81       	ldd	r24, Y+3	; 0x03
    1c6e:	9c 81       	ldd	r25, Y+4	; 0x04
    1c70:	28 85       	ldd	r18, Y+8	; 0x08
    1c72:	39 85       	ldd	r19, Y+9	; 0x09
    1c74:	eb 89       	ldd	r30, Y+19	; 0x13
    1c76:	fc 89       	ldd	r31, Y+20	; 0x14
    1c78:	aa 85       	ldd	r26, Y+10	; 0x0a
    1c7a:	bb 85       	ldd	r27, Y+11	; 0x0b
    1c7c:	b9 01       	movw	r22, r18
    1c7e:	4e 85       	ldd	r20, Y+14	; 0x0e
    1c80:	9f 01       	movw	r18, r30
    1c82:	8d 01       	movw	r16, r26
    1c84:	0e 94 66 13 	call	0x26cc	; 0x26cc <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    1c88:	89 81       	ldd	r24, Y+1	; 0x01
    1c8a:	9a 81       	ldd	r25, Y+2	; 0x02
    1c8c:	2e 81       	ldd	r18, Y+6	; 0x06
    1c8e:	3f 81       	ldd	r19, Y+7	; 0x07
    1c90:	4c 85       	ldd	r20, Y+12	; 0x0c
    1c92:	5d 85       	ldd	r21, Y+13	; 0x0d
    1c94:	b9 01       	movw	r22, r18
    1c96:	0e 94 95 05 	call	0xb2a	; 0xb2a <pxPortInitialiseStack>
    1c9a:	eb 81       	ldd	r30, Y+3	; 0x03
    1c9c:	fc 81       	ldd	r31, Y+4	; 0x04
    1c9e:	91 83       	std	Z+1, r25	; 0x01
    1ca0:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    1ca2:	8f 85       	ldd	r24, Y+15	; 0x0f
    1ca4:	98 89       	ldd	r25, Y+16	; 0x10
    1ca6:	00 97       	sbiw	r24, 0x00	; 0
    1ca8:	31 f0       	breq	.+12     	; 0x1cb6 <xTaskGenericCreate+0xbe>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    1caa:	ef 85       	ldd	r30, Y+15	; 0x0f
    1cac:	f8 89       	ldd	r31, Y+16	; 0x10
    1cae:	8b 81       	ldd	r24, Y+3	; 0x03
    1cb0:	9c 81       	ldd	r25, Y+4	; 0x04
    1cb2:	91 83       	std	Z+1, r25	; 0x01
    1cb4:	80 83       	st	Z, r24
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    1cb6:	0f b6       	in	r0, 0x3f	; 63
    1cb8:	f8 94       	cli
    1cba:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    1cbc:	80 91 05 03 	lds	r24, 0x0305
    1cc0:	8f 5f       	subi	r24, 0xFF	; 255
    1cc2:	80 93 05 03 	sts	0x0305, r24
			if( pxCurrentTCB == NULL )
    1cc6:	80 91 02 03 	lds	r24, 0x0302
    1cca:	90 91 03 03 	lds	r25, 0x0303
    1cce:	00 97       	sbiw	r24, 0x00	; 0
    1cd0:	69 f4       	brne	.+26     	; 0x1cec <xTaskGenericCreate+0xf4>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    1cd2:	8b 81       	ldd	r24, Y+3	; 0x03
    1cd4:	9c 81       	ldd	r25, Y+4	; 0x04
    1cd6:	90 93 03 03 	sts	0x0303, r25
    1cda:	80 93 02 03 	sts	0x0302, r24

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    1cde:	80 91 05 03 	lds	r24, 0x0305
    1ce2:	81 30       	cpi	r24, 0x01	; 1
    1ce4:	a9 f4       	brne	.+42     	; 0x1d10 <xTaskGenericCreate+0x118>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    1ce6:	0e 94 c1 13 	call	0x2782	; 0x2782 <prvInitialiseTaskLists>
    1cea:	12 c0       	rjmp	.+36     	; 0x1d10 <xTaskGenericCreate+0x118>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    1cec:	80 91 0a 03 	lds	r24, 0x030A
    1cf0:	88 23       	and	r24, r24
    1cf2:	71 f4       	brne	.+28     	; 0x1d10 <xTaskGenericCreate+0x118>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    1cf4:	e0 91 02 03 	lds	r30, 0x0302
    1cf8:	f0 91 03 03 	lds	r31, 0x0303
    1cfc:	96 89       	ldd	r25, Z+22	; 0x16
    1cfe:	8e 85       	ldd	r24, Y+14	; 0x0e
    1d00:	89 17       	cp	r24, r25
    1d02:	30 f0       	brcs	.+12     	; 0x1d10 <xTaskGenericCreate+0x118>
					{
						pxCurrentTCB = pxNewTCB;
    1d04:	8b 81       	ldd	r24, Y+3	; 0x03
    1d06:	9c 81       	ldd	r25, Y+4	; 0x04
    1d08:	90 93 03 03 	sts	0x0303, r25
    1d0c:	80 93 02 03 	sts	0x0302, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    1d10:	eb 81       	ldd	r30, Y+3	; 0x03
    1d12:	fc 81       	ldd	r31, Y+4	; 0x04
    1d14:	96 89       	ldd	r25, Z+22	; 0x16
    1d16:	80 91 08 03 	lds	r24, 0x0308
    1d1a:	89 17       	cp	r24, r25
    1d1c:	28 f4       	brcc	.+10     	; 0x1d28 <xTaskGenericCreate+0x130>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    1d1e:	eb 81       	ldd	r30, Y+3	; 0x03
    1d20:	fc 81       	ldd	r31, Y+4	; 0x04
    1d22:	86 89       	ldd	r24, Z+22	; 0x16
    1d24:	80 93 08 03 	sts	0x0308, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    1d28:	80 91 0f 03 	lds	r24, 0x030F
    1d2c:	8f 5f       	subi	r24, 0xFF	; 255
    1d2e:	80 93 0f 03 	sts	0x030F, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    1d32:	eb 81       	ldd	r30, Y+3	; 0x03
    1d34:	fc 81       	ldd	r31, Y+4	; 0x04
    1d36:	96 89       	ldd	r25, Z+22	; 0x16
    1d38:	80 91 09 03 	lds	r24, 0x0309
    1d3c:	89 17       	cp	r24, r25
    1d3e:	28 f4       	brcc	.+10     	; 0x1d4a <xTaskGenericCreate+0x152>
    1d40:	eb 81       	ldd	r30, Y+3	; 0x03
    1d42:	fc 81       	ldd	r31, Y+4	; 0x04
    1d44:	86 89       	ldd	r24, Z+22	; 0x16
    1d46:	80 93 09 03 	sts	0x0309, r24
    1d4a:	eb 81       	ldd	r30, Y+3	; 0x03
    1d4c:	fc 81       	ldd	r31, Y+4	; 0x04
    1d4e:	86 89       	ldd	r24, Z+22	; 0x16
    1d50:	28 2f       	mov	r18, r24
    1d52:	30 e0       	ldi	r19, 0x00	; 0
    1d54:	c9 01       	movw	r24, r18
    1d56:	88 0f       	add	r24, r24
    1d58:	99 1f       	adc	r25, r25
    1d5a:	88 0f       	add	r24, r24
    1d5c:	99 1f       	adc	r25, r25
    1d5e:	88 0f       	add	r24, r24
    1d60:	99 1f       	adc	r25, r25
    1d62:	82 0f       	add	r24, r18
    1d64:	93 1f       	adc	r25, r19
    1d66:	ac 01       	movw	r20, r24
    1d68:	40 5f       	subi	r20, 0xF0	; 240
    1d6a:	5c 4f       	sbci	r21, 0xFC	; 252
    1d6c:	8b 81       	ldd	r24, Y+3	; 0x03
    1d6e:	9c 81       	ldd	r25, Y+4	; 0x04
    1d70:	9c 01       	movw	r18, r24
    1d72:	2e 5f       	subi	r18, 0xFE	; 254
    1d74:	3f 4f       	sbci	r19, 0xFF	; 255
    1d76:	ca 01       	movw	r24, r20
    1d78:	b9 01       	movw	r22, r18
    1d7a:	0e 94 0b 04 	call	0x816	; 0x816 <vListInsertEnd>

			xReturn = pdPASS;
    1d7e:	81 e0       	ldi	r24, 0x01	; 1
    1d80:	8d 83       	std	Y+5, r24	; 0x05
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    1d82:	0f 90       	pop	r0
    1d84:	0f be       	out	0x3f, r0	; 63
    1d86:	02 c0       	rjmp	.+4      	; 0x1d8c <xTaskGenericCreate+0x194>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1d88:	8f ef       	ldi	r24, 0xFF	; 255
    1d8a:	8d 83       	std	Y+5, r24	; 0x05
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    1d8c:	8d 81       	ldd	r24, Y+5	; 0x05
    1d8e:	81 30       	cpi	r24, 0x01	; 1
    1d90:	71 f4       	brne	.+28     	; 0x1dae <xTaskGenericCreate+0x1b6>
	{
		if( xSchedulerRunning != pdFALSE )
    1d92:	80 91 0a 03 	lds	r24, 0x030A
    1d96:	88 23       	and	r24, r24
    1d98:	51 f0       	breq	.+20     	; 0x1dae <xTaskGenericCreate+0x1b6>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    1d9a:	e0 91 02 03 	lds	r30, 0x0302
    1d9e:	f0 91 03 03 	lds	r31, 0x0303
    1da2:	96 89       	ldd	r25, Z+22	; 0x16
    1da4:	8e 85       	ldd	r24, Y+14	; 0x0e
    1da6:	98 17       	cp	r25, r24
    1da8:	10 f4       	brcc	.+4      	; 0x1dae <xTaskGenericCreate+0x1b6>
			{
				portYIELD_WITHIN_API();
    1daa:	0e 94 54 07 	call	0xea8	; 0xea8 <vPortYield>
			}
		}
	}

	return xReturn;
    1dae:	8d 81       	ldd	r24, Y+5	; 0x05
}
    1db0:	64 96       	adiw	r28, 0x14	; 20
    1db2:	0f b6       	in	r0, 0x3f	; 63
    1db4:	f8 94       	cli
    1db6:	de bf       	out	0x3e, r29	; 62
    1db8:	0f be       	out	0x3f, r0	; 63
    1dba:	cd bf       	out	0x3d, r28	; 61
    1dbc:	cf 91       	pop	r28
    1dbe:	df 91       	pop	r29
    1dc0:	1f 91       	pop	r17
    1dc2:	0f 91       	pop	r16
    1dc4:	ff 90       	pop	r15
    1dc6:	ef 90       	pop	r14
    1dc8:	df 90       	pop	r13
    1dca:	cf 90       	pop	r12
    1dcc:	bf 90       	pop	r11
    1dce:	af 90       	pop	r10
    1dd0:	08 95       	ret

00001dd2 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    1dd2:	df 93       	push	r29
    1dd4:	cf 93       	push	r28
    1dd6:	00 d0       	rcall	.+0      	; 0x1dd8 <vTaskDelete+0x6>
    1dd8:	00 d0       	rcall	.+0      	; 0x1dda <vTaskDelete+0x8>
    1dda:	00 d0       	rcall	.+0      	; 0x1ddc <vTaskDelete+0xa>
    1ddc:	cd b7       	in	r28, 0x3d	; 61
    1dde:	de b7       	in	r29, 0x3e	; 62
    1de0:	9c 83       	std	Y+4, r25	; 0x04
    1de2:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    1de4:	0f b6       	in	r0, 0x3f	; 63
    1de6:	f8 94       	cli
    1de8:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    1dea:	20 91 02 03 	lds	r18, 0x0302
    1dee:	30 91 03 03 	lds	r19, 0x0303
    1df2:	8b 81       	ldd	r24, Y+3	; 0x03
    1df4:	9c 81       	ldd	r25, Y+4	; 0x04
    1df6:	82 17       	cp	r24, r18
    1df8:	93 07       	cpc	r25, r19
    1dfa:	11 f4       	brne	.+4      	; 0x1e00 <vTaskDelete+0x2e>
			{
				pxTaskToDelete = NULL;
    1dfc:	1c 82       	std	Y+4, r1	; 0x04
    1dfe:	1b 82       	std	Y+3, r1	; 0x03
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    1e00:	8b 81       	ldd	r24, Y+3	; 0x03
    1e02:	9c 81       	ldd	r25, Y+4	; 0x04
    1e04:	00 97       	sbiw	r24, 0x00	; 0
    1e06:	39 f4       	brne	.+14     	; 0x1e16 <vTaskDelete+0x44>
    1e08:	80 91 02 03 	lds	r24, 0x0302
    1e0c:	90 91 03 03 	lds	r25, 0x0303
    1e10:	9e 83       	std	Y+6, r25	; 0x06
    1e12:	8d 83       	std	Y+5, r24	; 0x05
    1e14:	04 c0       	rjmp	.+8      	; 0x1e1e <vTaskDelete+0x4c>
    1e16:	8b 81       	ldd	r24, Y+3	; 0x03
    1e18:	9c 81       	ldd	r25, Y+4	; 0x04
    1e1a:	9e 83       	std	Y+6, r25	; 0x06
    1e1c:	8d 83       	std	Y+5, r24	; 0x05
    1e1e:	8d 81       	ldd	r24, Y+5	; 0x05
    1e20:	9e 81       	ldd	r25, Y+6	; 0x06
    1e22:	9a 83       	std	Y+2, r25	; 0x02
    1e24:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    1e26:	89 81       	ldd	r24, Y+1	; 0x01
    1e28:	9a 81       	ldd	r25, Y+2	; 0x02
    1e2a:	02 96       	adiw	r24, 0x02	; 2
    1e2c:	0e 94 c3 04 	call	0x986	; 0x986 <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    1e30:	e9 81       	ldd	r30, Y+1	; 0x01
    1e32:	fa 81       	ldd	r31, Y+2	; 0x02
    1e34:	84 89       	ldd	r24, Z+20	; 0x14
    1e36:	95 89       	ldd	r25, Z+21	; 0x15
    1e38:	00 97       	sbiw	r24, 0x00	; 0
    1e3a:	29 f0       	breq	.+10     	; 0x1e46 <vTaskDelete+0x74>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    1e3c:	89 81       	ldd	r24, Y+1	; 0x01
    1e3e:	9a 81       	ldd	r25, Y+2	; 0x02
    1e40:	0c 96       	adiw	r24, 0x0c	; 12
    1e42:	0e 94 c3 04 	call	0x986	; 0x986 <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    1e46:	89 81       	ldd	r24, Y+1	; 0x01
    1e48:	9a 81       	ldd	r25, Y+2	; 0x02
    1e4a:	9c 01       	movw	r18, r24
    1e4c:	2e 5f       	subi	r18, 0xFE	; 254
    1e4e:	3f 4f       	sbci	r19, 0xFF	; 255
    1e50:	8a e4       	ldi	r24, 0x4A	; 74
    1e52:	93 e0       	ldi	r25, 0x03	; 3
    1e54:	b9 01       	movw	r22, r18
    1e56:	0e 94 0b 04 	call	0x816	; 0x816 <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    1e5a:	80 91 04 03 	lds	r24, 0x0304
    1e5e:	8f 5f       	subi	r24, 0xFF	; 255
    1e60:	80 93 04 03 	sts	0x0304, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    1e64:	80 91 0f 03 	lds	r24, 0x030F
    1e68:	8f 5f       	subi	r24, 0xFF	; 255
    1e6a:	80 93 0f 03 	sts	0x030F, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    1e6e:	0f 90       	pop	r0
    1e70:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    1e72:	80 91 0a 03 	lds	r24, 0x030A
    1e76:	88 23       	and	r24, r24
    1e78:	31 f0       	breq	.+12     	; 0x1e86 <vTaskDelete+0xb4>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    1e7a:	8b 81       	ldd	r24, Y+3	; 0x03
    1e7c:	9c 81       	ldd	r25, Y+4	; 0x04
    1e7e:	00 97       	sbiw	r24, 0x00	; 0
    1e80:	11 f4       	brne	.+4      	; 0x1e86 <vTaskDelete+0xb4>
			{
				portYIELD_WITHIN_API();
    1e82:	0e 94 54 07 	call	0xea8	; 0xea8 <vPortYield>
			}
		}
	}
    1e86:	26 96       	adiw	r28, 0x06	; 6
    1e88:	0f b6       	in	r0, 0x3f	; 63
    1e8a:	f8 94       	cli
    1e8c:	de bf       	out	0x3e, r29	; 62
    1e8e:	0f be       	out	0x3f, r0	; 63
    1e90:	cd bf       	out	0x3d, r28	; 61
    1e92:	cf 91       	pop	r28
    1e94:	df 91       	pop	r29
    1e96:	08 95       	ret

00001e98 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    1e98:	df 93       	push	r29
    1e9a:	cf 93       	push	r28
    1e9c:	cd b7       	in	r28, 0x3d	; 61
    1e9e:	de b7       	in	r29, 0x3e	; 62
    1ea0:	28 97       	sbiw	r28, 0x08	; 8
    1ea2:	0f b6       	in	r0, 0x3f	; 63
    1ea4:	f8 94       	cli
    1ea6:	de bf       	out	0x3e, r29	; 62
    1ea8:	0f be       	out	0x3f, r0	; 63
    1eaa:	cd bf       	out	0x3d, r28	; 61
    1eac:	9e 83       	std	Y+6, r25	; 0x06
    1eae:	8d 83       	std	Y+5, r24	; 0x05
    1eb0:	78 87       	std	Y+8, r23	; 0x08
    1eb2:	6f 83       	std	Y+7, r22	; 0x07
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
    1eb4:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    1eb6:	0e 94 38 10 	call	0x2070	; 0x2070 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    1eba:	ed 81       	ldd	r30, Y+5	; 0x05
    1ebc:	fe 81       	ldd	r31, Y+6	; 0x06
    1ebe:	20 81       	ld	r18, Z
    1ec0:	31 81       	ldd	r19, Z+1	; 0x01
    1ec2:	8f 81       	ldd	r24, Y+7	; 0x07
    1ec4:	98 85       	ldd	r25, Y+8	; 0x08
    1ec6:	82 0f       	add	r24, r18
    1ec8:	93 1f       	adc	r25, r19
    1eca:	9c 83       	std	Y+4, r25	; 0x04
    1ecc:	8b 83       	std	Y+3, r24	; 0x03

			if( xTickCount < *pxPreviousWakeTime )
    1ece:	ed 81       	ldd	r30, Y+5	; 0x05
    1ed0:	fe 81       	ldd	r31, Y+6	; 0x06
    1ed2:	20 81       	ld	r18, Z
    1ed4:	31 81       	ldd	r19, Z+1	; 0x01
    1ed6:	80 91 06 03 	lds	r24, 0x0306
    1eda:	90 91 07 03 	lds	r25, 0x0307
    1ede:	82 17       	cp	r24, r18
    1ee0:	93 07       	cpc	r25, r19
    1ee2:	a8 f4       	brcc	.+42     	; 0x1f0e <vTaskDelayUntil+0x76>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    1ee4:	ed 81       	ldd	r30, Y+5	; 0x05
    1ee6:	fe 81       	ldd	r31, Y+6	; 0x06
    1ee8:	20 81       	ld	r18, Z
    1eea:	31 81       	ldd	r19, Z+1	; 0x01
    1eec:	8b 81       	ldd	r24, Y+3	; 0x03
    1eee:	9c 81       	ldd	r25, Y+4	; 0x04
    1ef0:	82 17       	cp	r24, r18
    1ef2:	93 07       	cpc	r25, r19
    1ef4:	00 f5       	brcc	.+64     	; 0x1f36 <vTaskDelayUntil+0x9e>
    1ef6:	20 91 06 03 	lds	r18, 0x0306
    1efa:	30 91 07 03 	lds	r19, 0x0307
    1efe:	8b 81       	ldd	r24, Y+3	; 0x03
    1f00:	9c 81       	ldd	r25, Y+4	; 0x04
    1f02:	28 17       	cp	r18, r24
    1f04:	39 07       	cpc	r19, r25
    1f06:	b8 f4       	brcc	.+46     	; 0x1f36 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    1f08:	81 e0       	ldi	r24, 0x01	; 1
    1f0a:	89 83       	std	Y+1, r24	; 0x01
    1f0c:	14 c0       	rjmp	.+40     	; 0x1f36 <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    1f0e:	ed 81       	ldd	r30, Y+5	; 0x05
    1f10:	fe 81       	ldd	r31, Y+6	; 0x06
    1f12:	20 81       	ld	r18, Z
    1f14:	31 81       	ldd	r19, Z+1	; 0x01
    1f16:	8b 81       	ldd	r24, Y+3	; 0x03
    1f18:	9c 81       	ldd	r25, Y+4	; 0x04
    1f1a:	82 17       	cp	r24, r18
    1f1c:	93 07       	cpc	r25, r19
    1f1e:	48 f0       	brcs	.+18     	; 0x1f32 <vTaskDelayUntil+0x9a>
    1f20:	20 91 06 03 	lds	r18, 0x0306
    1f24:	30 91 07 03 	lds	r19, 0x0307
    1f28:	8b 81       	ldd	r24, Y+3	; 0x03
    1f2a:	9c 81       	ldd	r25, Y+4	; 0x04
    1f2c:	28 17       	cp	r18, r24
    1f2e:	39 07       	cpc	r19, r25
    1f30:	10 f4       	brcc	.+4      	; 0x1f36 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    1f32:	81 e0       	ldi	r24, 0x01	; 1
    1f34:	89 83       	std	Y+1, r24	; 0x01
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    1f36:	ed 81       	ldd	r30, Y+5	; 0x05
    1f38:	fe 81       	ldd	r31, Y+6	; 0x06
    1f3a:	8b 81       	ldd	r24, Y+3	; 0x03
    1f3c:	9c 81       	ldd	r25, Y+4	; 0x04
    1f3e:	91 83       	std	Z+1, r25	; 0x01
    1f40:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    1f42:	89 81       	ldd	r24, Y+1	; 0x01
    1f44:	88 23       	and	r24, r24
    1f46:	59 f0       	breq	.+22     	; 0x1f5e <vTaskDelayUntil+0xc6>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1f48:	80 91 02 03 	lds	r24, 0x0302
    1f4c:	90 91 03 03 	lds	r25, 0x0303
    1f50:	02 96       	adiw	r24, 0x02	; 2
    1f52:	0e 94 c3 04 	call	0x986	; 0x986 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1f56:	8b 81       	ldd	r24, Y+3	; 0x03
    1f58:	9c 81       	ldd	r25, Y+4	; 0x04
    1f5a:	0e 94 3c 14 	call	0x2878	; 0x2878 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    1f5e:	0e 94 44 10 	call	0x2088	; 0x2088 <xTaskResumeAll>
    1f62:	8a 83       	std	Y+2, r24	; 0x02

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1f64:	8a 81       	ldd	r24, Y+2	; 0x02
    1f66:	88 23       	and	r24, r24
    1f68:	11 f4       	brne	.+4      	; 0x1f6e <vTaskDelayUntil+0xd6>
		{
			portYIELD_WITHIN_API();
    1f6a:	0e 94 54 07 	call	0xea8	; 0xea8 <vPortYield>
		}
	}
    1f6e:	28 96       	adiw	r28, 0x08	; 8
    1f70:	0f b6       	in	r0, 0x3f	; 63
    1f72:	f8 94       	cli
    1f74:	de bf       	out	0x3e, r29	; 62
    1f76:	0f be       	out	0x3f, r0	; 63
    1f78:	cd bf       	out	0x3d, r28	; 61
    1f7a:	cf 91       	pop	r28
    1f7c:	df 91       	pop	r29
    1f7e:	08 95       	ret

00001f80 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    1f80:	df 93       	push	r29
    1f82:	cf 93       	push	r28
    1f84:	00 d0       	rcall	.+0      	; 0x1f86 <vTaskDelay+0x6>
    1f86:	00 d0       	rcall	.+0      	; 0x1f88 <vTaskDelay+0x8>
    1f88:	0f 92       	push	r0
    1f8a:	cd b7       	in	r28, 0x3d	; 61
    1f8c:	de b7       	in	r29, 0x3e	; 62
    1f8e:	9d 83       	std	Y+5, r25	; 0x05
    1f90:	8c 83       	std	Y+4, r24	; 0x04
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    1f92:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    1f94:	8c 81       	ldd	r24, Y+4	; 0x04
    1f96:	9d 81       	ldd	r25, Y+5	; 0x05
    1f98:	00 97       	sbiw	r24, 0x00	; 0
    1f9a:	d1 f0       	breq	.+52     	; 0x1fd0 <vTaskDelay+0x50>
		{
			vTaskSuspendAll();
    1f9c:	0e 94 38 10 	call	0x2070	; 0x2070 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    1fa0:	20 91 06 03 	lds	r18, 0x0306
    1fa4:	30 91 07 03 	lds	r19, 0x0307
    1fa8:	8c 81       	ldd	r24, Y+4	; 0x04
    1faa:	9d 81       	ldd	r25, Y+5	; 0x05
    1fac:	82 0f       	add	r24, r18
    1fae:	93 1f       	adc	r25, r19
    1fb0:	9b 83       	std	Y+3, r25	; 0x03
    1fb2:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1fb4:	80 91 02 03 	lds	r24, 0x0302
    1fb8:	90 91 03 03 	lds	r25, 0x0303
    1fbc:	02 96       	adiw	r24, 0x02	; 2
    1fbe:	0e 94 c3 04 	call	0x986	; 0x986 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1fc2:	8a 81       	ldd	r24, Y+2	; 0x02
    1fc4:	9b 81       	ldd	r25, Y+3	; 0x03
    1fc6:	0e 94 3c 14 	call	0x2878	; 0x2878 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    1fca:	0e 94 44 10 	call	0x2088	; 0x2088 <xTaskResumeAll>
    1fce:	89 83       	std	Y+1, r24	; 0x01
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1fd0:	89 81       	ldd	r24, Y+1	; 0x01
    1fd2:	88 23       	and	r24, r24
    1fd4:	11 f4       	brne	.+4      	; 0x1fda <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
    1fd6:	0e 94 54 07 	call	0xea8	; 0xea8 <vPortYield>
		}
	}
    1fda:	0f 90       	pop	r0
    1fdc:	0f 90       	pop	r0
    1fde:	0f 90       	pop	r0
    1fe0:	0f 90       	pop	r0
    1fe2:	0f 90       	pop	r0
    1fe4:	cf 91       	pop	r28
    1fe6:	df 91       	pop	r29
    1fe8:	08 95       	ret

00001fea <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    1fea:	af 92       	push	r10
    1fec:	bf 92       	push	r11
    1fee:	cf 92       	push	r12
    1ff0:	df 92       	push	r13
    1ff2:	ef 92       	push	r14
    1ff4:	ff 92       	push	r15
    1ff6:	0f 93       	push	r16
    1ff8:	df 93       	push	r29
    1ffa:	cf 93       	push	r28
    1ffc:	0f 92       	push	r0
    1ffe:	cd b7       	in	r28, 0x3d	; 61
    2000:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    2002:	29 e6       	ldi	r18, 0x69	; 105
    2004:	30 e0       	ldi	r19, 0x00	; 0
    2006:	8c e5       	ldi	r24, 0x5C	; 92
    2008:	93 e1       	ldi	r25, 0x13	; 19
    200a:	b9 01       	movw	r22, r18
    200c:	45 e5       	ldi	r20, 0x55	; 85
    200e:	50 e0       	ldi	r21, 0x00	; 0
    2010:	20 e0       	ldi	r18, 0x00	; 0
    2012:	30 e0       	ldi	r19, 0x00	; 0
    2014:	00 e0       	ldi	r16, 0x00	; 0
    2016:	ee 24       	eor	r14, r14
    2018:	ff 24       	eor	r15, r15
    201a:	cc 24       	eor	r12, r12
    201c:	dd 24       	eor	r13, r13
    201e:	aa 24       	eor	r10, r10
    2020:	bb 24       	eor	r11, r11
    2022:	0e 94 fc 0d 	call	0x1bf8	; 0x1bf8 <xTaskGenericCreate>
    2026:	89 83       	std	Y+1, r24	; 0x01
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    2028:	89 81       	ldd	r24, Y+1	; 0x01
    202a:	81 30       	cpi	r24, 0x01	; 1
    202c:	51 f4       	brne	.+20     	; 0x2042 <vTaskStartScheduler+0x58>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    202e:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    2030:	81 e0       	ldi	r24, 0x01	; 1
    2032:	80 93 0a 03 	sts	0x030A, r24
		xTickCount = ( portTickType ) 0U;
    2036:	10 92 07 03 	sts	0x0307, r1
    203a:	10 92 06 03 	sts	0x0306, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    203e:	0e 94 18 07 	call	0xe30	; 0xe30 <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    2042:	0f 90       	pop	r0
    2044:	cf 91       	pop	r28
    2046:	df 91       	pop	r29
    2048:	0f 91       	pop	r16
    204a:	ff 90       	pop	r15
    204c:	ef 90       	pop	r14
    204e:	df 90       	pop	r13
    2050:	cf 90       	pop	r12
    2052:	bf 90       	pop	r11
    2054:	af 90       	pop	r10
    2056:	08 95       	ret

00002058 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    2058:	df 93       	push	r29
    205a:	cf 93       	push	r28
    205c:	cd b7       	in	r28, 0x3d	; 61
    205e:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    2060:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    2062:	10 92 0a 03 	sts	0x030A, r1
	vPortEndScheduler();
    2066:	0e 94 4d 07 	call	0xe9a	; 0xe9a <vPortEndScheduler>
}
    206a:	cf 91       	pop	r28
    206c:	df 91       	pop	r29
    206e:	08 95       	ret

00002070 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    2070:	df 93       	push	r29
    2072:	cf 93       	push	r28
    2074:	cd b7       	in	r28, 0x3d	; 61
    2076:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    2078:	80 91 0b 03 	lds	r24, 0x030B
    207c:	8f 5f       	subi	r24, 0xFF	; 255
    207e:	80 93 0b 03 	sts	0x030B, r24
}
    2082:	cf 91       	pop	r28
    2084:	df 91       	pop	r29
    2086:	08 95       	ret

00002088 <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    2088:	df 93       	push	r29
    208a:	cf 93       	push	r28
    208c:	00 d0       	rcall	.+0      	; 0x208e <xTaskResumeAll+0x6>
    208e:	00 d0       	rcall	.+0      	; 0x2090 <xTaskResumeAll+0x8>
    2090:	cd b7       	in	r28, 0x3d	; 61
    2092:	de b7       	in	r29, 0x3e	; 62
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    2094:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    2096:	0f b6       	in	r0, 0x3f	; 63
    2098:	f8 94       	cli
    209a:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    209c:	80 91 0b 03 	lds	r24, 0x030B
    20a0:	81 50       	subi	r24, 0x01	; 1
    20a2:	80 93 0b 03 	sts	0x030B, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    20a6:	80 91 0b 03 	lds	r24, 0x030B
    20aa:	88 23       	and	r24, r24
    20ac:	09 f0       	breq	.+2      	; 0x20b0 <xTaskResumeAll+0x28>
    20ae:	6c c0       	rjmp	.+216    	; 0x2188 <xTaskResumeAll+0x100>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    20b0:	80 91 05 03 	lds	r24, 0x0305
    20b4:	88 23       	and	r24, r24
    20b6:	09 f4       	brne	.+2      	; 0x20ba <xTaskResumeAll+0x32>
    20b8:	67 c0       	rjmp	.+206    	; 0x2188 <xTaskResumeAll+0x100>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
    20ba:	19 82       	std	Y+1, r1	; 0x01
    20bc:	41 c0       	rjmp	.+130    	; 0x2140 <xTaskResumeAll+0xb8>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    20be:	e0 91 46 03 	lds	r30, 0x0346
    20c2:	f0 91 47 03 	lds	r31, 0x0347
    20c6:	86 81       	ldd	r24, Z+6	; 0x06
    20c8:	97 81       	ldd	r25, Z+7	; 0x07
    20ca:	9c 83       	std	Y+4, r25	; 0x04
    20cc:	8b 83       	std	Y+3, r24	; 0x03
					vListRemove( &( pxTCB->xEventListItem ) );
    20ce:	8b 81       	ldd	r24, Y+3	; 0x03
    20d0:	9c 81       	ldd	r25, Y+4	; 0x04
    20d2:	0c 96       	adiw	r24, 0x0c	; 12
    20d4:	0e 94 c3 04 	call	0x986	; 0x986 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    20d8:	8b 81       	ldd	r24, Y+3	; 0x03
    20da:	9c 81       	ldd	r25, Y+4	; 0x04
    20dc:	02 96       	adiw	r24, 0x02	; 2
    20de:	0e 94 c3 04 	call	0x986	; 0x986 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    20e2:	eb 81       	ldd	r30, Y+3	; 0x03
    20e4:	fc 81       	ldd	r31, Y+4	; 0x04
    20e6:	96 89       	ldd	r25, Z+22	; 0x16
    20e8:	80 91 09 03 	lds	r24, 0x0309
    20ec:	89 17       	cp	r24, r25
    20ee:	28 f4       	brcc	.+10     	; 0x20fa <xTaskResumeAll+0x72>
    20f0:	eb 81       	ldd	r30, Y+3	; 0x03
    20f2:	fc 81       	ldd	r31, Y+4	; 0x04
    20f4:	86 89       	ldd	r24, Z+22	; 0x16
    20f6:	80 93 09 03 	sts	0x0309, r24
    20fa:	eb 81       	ldd	r30, Y+3	; 0x03
    20fc:	fc 81       	ldd	r31, Y+4	; 0x04
    20fe:	86 89       	ldd	r24, Z+22	; 0x16
    2100:	28 2f       	mov	r18, r24
    2102:	30 e0       	ldi	r19, 0x00	; 0
    2104:	c9 01       	movw	r24, r18
    2106:	88 0f       	add	r24, r24
    2108:	99 1f       	adc	r25, r25
    210a:	88 0f       	add	r24, r24
    210c:	99 1f       	adc	r25, r25
    210e:	88 0f       	add	r24, r24
    2110:	99 1f       	adc	r25, r25
    2112:	82 0f       	add	r24, r18
    2114:	93 1f       	adc	r25, r19
    2116:	80 5f       	subi	r24, 0xF0	; 240
    2118:	9c 4f       	sbci	r25, 0xFC	; 252
    211a:	2b 81       	ldd	r18, Y+3	; 0x03
    211c:	3c 81       	ldd	r19, Y+4	; 0x04
    211e:	2e 5f       	subi	r18, 0xFE	; 254
    2120:	3f 4f       	sbci	r19, 0xFF	; 255
    2122:	b9 01       	movw	r22, r18
    2124:	0e 94 0b 04 	call	0x816	; 0x816 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2128:	eb 81       	ldd	r30, Y+3	; 0x03
    212a:	fc 81       	ldd	r31, Y+4	; 0x04
    212c:	96 89       	ldd	r25, Z+22	; 0x16
    212e:	e0 91 02 03 	lds	r30, 0x0302
    2132:	f0 91 03 03 	lds	r31, 0x0303
    2136:	86 89       	ldd	r24, Z+22	; 0x16
    2138:	98 17       	cp	r25, r24
    213a:	10 f0       	brcs	.+4      	; 0x2140 <xTaskResumeAll+0xb8>
					{
						xYieldRequired = pdTRUE;
    213c:	81 e0       	ldi	r24, 0x01	; 1
    213e:	89 83       	std	Y+1, r24	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    2140:	80 91 41 03 	lds	r24, 0x0341
    2144:	88 23       	and	r24, r24
    2146:	09 f0       	breq	.+2      	; 0x214a <xTaskResumeAll+0xc2>
    2148:	ba cf       	rjmp	.-140    	; 0x20be <xTaskResumeAll+0x36>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    214a:	80 91 0c 03 	lds	r24, 0x030C
    214e:	88 23       	and	r24, r24
    2150:	71 f0       	breq	.+28     	; 0x216e <xTaskResumeAll+0xe6>
    2152:	07 c0       	rjmp	.+14     	; 0x2162 <xTaskResumeAll+0xda>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						vTaskIncrementTick();
    2154:	0e 94 03 11 	call	0x2206	; 0x2206 <vTaskIncrementTick>
						--uxMissedTicks;
    2158:	80 91 0c 03 	lds	r24, 0x030C
    215c:	81 50       	subi	r24, 0x01	; 1
    215e:	80 93 0c 03 	sts	0x030C, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    2162:	80 91 0c 03 	lds	r24, 0x030C
    2166:	88 23       	and	r24, r24
    2168:	a9 f7       	brne	.-22     	; 0x2154 <xTaskResumeAll+0xcc>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
    216a:	81 e0       	ldi	r24, 0x01	; 1
    216c:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    216e:	89 81       	ldd	r24, Y+1	; 0x01
    2170:	81 30       	cpi	r24, 0x01	; 1
    2172:	21 f0       	breq	.+8      	; 0x217c <xTaskResumeAll+0xf4>
    2174:	80 91 0d 03 	lds	r24, 0x030D
    2178:	81 30       	cpi	r24, 0x01	; 1
    217a:	31 f4       	brne	.+12     	; 0x2188 <xTaskResumeAll+0x100>
				{
					xAlreadyYielded = pdTRUE;
    217c:	81 e0       	ldi	r24, 0x01	; 1
    217e:	8a 83       	std	Y+2, r24	; 0x02
					xMissedYield = pdFALSE;
    2180:	10 92 0d 03 	sts	0x030D, r1
					portYIELD_WITHIN_API();
    2184:	0e 94 54 07 	call	0xea8	; 0xea8 <vPortYield>
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    2188:	0f 90       	pop	r0
    218a:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    218c:	8a 81       	ldd	r24, Y+2	; 0x02
}
    218e:	0f 90       	pop	r0
    2190:	0f 90       	pop	r0
    2192:	0f 90       	pop	r0
    2194:	0f 90       	pop	r0
    2196:	cf 91       	pop	r28
    2198:	df 91       	pop	r29
    219a:	08 95       	ret

0000219c <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
    219c:	df 93       	push	r29
    219e:	cf 93       	push	r28
    21a0:	00 d0       	rcall	.+0      	; 0x21a2 <xTaskGetTickCount+0x6>
    21a2:	cd b7       	in	r28, 0x3d	; 61
    21a4:	de b7       	in	r29, 0x3e	; 62
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    21a6:	0f b6       	in	r0, 0x3f	; 63
    21a8:	f8 94       	cli
    21aa:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    21ac:	80 91 06 03 	lds	r24, 0x0306
    21b0:	90 91 07 03 	lds	r25, 0x0307
    21b4:	9a 83       	std	Y+2, r25	; 0x02
    21b6:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    21b8:	0f 90       	pop	r0
    21ba:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    21bc:	89 81       	ldd	r24, Y+1	; 0x01
    21be:	9a 81       	ldd	r25, Y+2	; 0x02
}
    21c0:	0f 90       	pop	r0
    21c2:	0f 90       	pop	r0
    21c4:	cf 91       	pop	r28
    21c6:	df 91       	pop	r29
    21c8:	08 95       	ret

000021ca <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
    21ca:	df 93       	push	r29
    21cc:	cf 93       	push	r28
    21ce:	00 d0       	rcall	.+0      	; 0x21d0 <xTaskGetTickCountFromISR+0x6>
    21d0:	0f 92       	push	r0
    21d2:	cd b7       	in	r28, 0x3d	; 61
    21d4:	de b7       	in	r29, 0x3e	; 62
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    21d6:	19 82       	std	Y+1, r1	; 0x01
	xReturn = xTickCount;
    21d8:	80 91 06 03 	lds	r24, 0x0306
    21dc:	90 91 07 03 	lds	r25, 0x0307
    21e0:	9b 83       	std	Y+3, r25	; 0x03
    21e2:	8a 83       	std	Y+2, r24	; 0x02
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    21e4:	8a 81       	ldd	r24, Y+2	; 0x02
    21e6:	9b 81       	ldd	r25, Y+3	; 0x03
}
    21e8:	0f 90       	pop	r0
    21ea:	0f 90       	pop	r0
    21ec:	0f 90       	pop	r0
    21ee:	cf 91       	pop	r28
    21f0:	df 91       	pop	r29
    21f2:	08 95       	ret

000021f4 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
    21f4:	df 93       	push	r29
    21f6:	cf 93       	push	r28
    21f8:	cd b7       	in	r28, 0x3d	; 61
    21fa:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    21fc:	80 91 05 03 	lds	r24, 0x0305
}
    2200:	cf 91       	pop	r28
    2202:	df 91       	pop	r29
    2204:	08 95       	ret

00002206 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    2206:	df 93       	push	r29
    2208:	cf 93       	push	r28
    220a:	00 d0       	rcall	.+0      	; 0x220c <vTaskIncrementTick+0x6>
    220c:	00 d0       	rcall	.+0      	; 0x220e <vTaskIncrementTick+0x8>
    220e:	00 d0       	rcall	.+0      	; 0x2210 <vTaskIncrementTick+0xa>
    2210:	cd b7       	in	r28, 0x3d	; 61
    2212:	de b7       	in	r29, 0x3e	; 62
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2214:	80 91 0b 03 	lds	r24, 0x030B
    2218:	88 23       	and	r24, r24
    221a:	09 f0       	breq	.+2      	; 0x221e <vTaskIncrementTick+0x18>
    221c:	bb c0       	rjmp	.+374    	; 0x2394 <vTaskIncrementTick+0x18e>
	{
		++xTickCount;
    221e:	80 91 06 03 	lds	r24, 0x0306
    2222:	90 91 07 03 	lds	r25, 0x0307
    2226:	01 96       	adiw	r24, 0x01	; 1
    2228:	90 93 07 03 	sts	0x0307, r25
    222c:	80 93 06 03 	sts	0x0306, r24
		if( xTickCount == ( portTickType ) 0U )
    2230:	80 91 06 03 	lds	r24, 0x0306
    2234:	90 91 07 03 	lds	r25, 0x0307
    2238:	00 97       	sbiw	r24, 0x00	; 0
    223a:	d1 f5       	brne	.+116    	; 0x22b0 <vTaskIncrementTick+0xaa>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    223c:	80 91 3d 03 	lds	r24, 0x033D
    2240:	90 91 3e 03 	lds	r25, 0x033E
    2244:	9c 83       	std	Y+4, r25	; 0x04
    2246:	8b 83       	std	Y+3, r24	; 0x03
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    2248:	80 91 3f 03 	lds	r24, 0x033F
    224c:	90 91 40 03 	lds	r25, 0x0340
    2250:	90 93 3e 03 	sts	0x033E, r25
    2254:	80 93 3d 03 	sts	0x033D, r24
			pxOverflowDelayedTaskList = pxTemp;
    2258:	8b 81       	ldd	r24, Y+3	; 0x03
    225a:	9c 81       	ldd	r25, Y+4	; 0x04
    225c:	90 93 40 03 	sts	0x0340, r25
    2260:	80 93 3f 03 	sts	0x033F, r24
			xNumOfOverflows++;
    2264:	80 91 0e 03 	lds	r24, 0x030E
    2268:	8f 5f       	subi	r24, 0xFF	; 255
    226a:	80 93 0e 03 	sts	0x030E, r24
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    226e:	e0 91 3d 03 	lds	r30, 0x033D
    2272:	f0 91 3e 03 	lds	r31, 0x033E
    2276:	80 81       	ld	r24, Z
    2278:	88 23       	and	r24, r24
    227a:	39 f4       	brne	.+14     	; 0x228a <vTaskIncrementTick+0x84>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    227c:	8f ef       	ldi	r24, 0xFF	; 255
    227e:	9f ef       	ldi	r25, 0xFF	; 255
    2280:	90 93 68 00 	sts	0x0068, r25
    2284:	80 93 67 00 	sts	0x0067, r24
    2288:	13 c0       	rjmp	.+38     	; 0x22b0 <vTaskIncrementTick+0xaa>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    228a:	e0 91 3d 03 	lds	r30, 0x033D
    228e:	f0 91 3e 03 	lds	r31, 0x033E
    2292:	05 80       	ldd	r0, Z+5	; 0x05
    2294:	f6 81       	ldd	r31, Z+6	; 0x06
    2296:	e0 2d       	mov	r30, r0
    2298:	86 81       	ldd	r24, Z+6	; 0x06
    229a:	97 81       	ldd	r25, Z+7	; 0x07
    229c:	9e 83       	std	Y+6, r25	; 0x06
    229e:	8d 83       	std	Y+5, r24	; 0x05
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    22a0:	ed 81       	ldd	r30, Y+5	; 0x05
    22a2:	fe 81       	ldd	r31, Y+6	; 0x06
    22a4:	82 81       	ldd	r24, Z+2	; 0x02
    22a6:	93 81       	ldd	r25, Z+3	; 0x03
    22a8:	90 93 68 00 	sts	0x0068, r25
    22ac:	80 93 67 00 	sts	0x0067, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    22b0:	20 91 06 03 	lds	r18, 0x0306
    22b4:	30 91 07 03 	lds	r19, 0x0307
    22b8:	80 91 67 00 	lds	r24, 0x0067
    22bc:	90 91 68 00 	lds	r25, 0x0068
    22c0:	28 17       	cp	r18, r24
    22c2:	39 07       	cpc	r19, r25
    22c4:	08 f4       	brcc	.+2      	; 0x22c8 <vTaskIncrementTick+0xc2>
    22c6:	6b c0       	rjmp	.+214    	; 0x239e <vTaskIncrementTick+0x198>
    22c8:	e0 91 3d 03 	lds	r30, 0x033D
    22cc:	f0 91 3e 03 	lds	r31, 0x033E
    22d0:	80 81       	ld	r24, Z
    22d2:	88 23       	and	r24, r24
    22d4:	39 f4       	brne	.+14     	; 0x22e4 <vTaskIncrementTick+0xde>
    22d6:	8f ef       	ldi	r24, 0xFF	; 255
    22d8:	9f ef       	ldi	r25, 0xFF	; 255
    22da:	90 93 68 00 	sts	0x0068, r25
    22de:	80 93 67 00 	sts	0x0067, r24
    22e2:	5d c0       	rjmp	.+186    	; 0x239e <vTaskIncrementTick+0x198>
    22e4:	e0 91 3d 03 	lds	r30, 0x033D
    22e8:	f0 91 3e 03 	lds	r31, 0x033E
    22ec:	05 80       	ldd	r0, Z+5	; 0x05
    22ee:	f6 81       	ldd	r31, Z+6	; 0x06
    22f0:	e0 2d       	mov	r30, r0
    22f2:	86 81       	ldd	r24, Z+6	; 0x06
    22f4:	97 81       	ldd	r25, Z+7	; 0x07
    22f6:	9e 83       	std	Y+6, r25	; 0x06
    22f8:	8d 83       	std	Y+5, r24	; 0x05
    22fa:	ed 81       	ldd	r30, Y+5	; 0x05
    22fc:	fe 81       	ldd	r31, Y+6	; 0x06
    22fe:	82 81       	ldd	r24, Z+2	; 0x02
    2300:	93 81       	ldd	r25, Z+3	; 0x03
    2302:	9a 83       	std	Y+2, r25	; 0x02
    2304:	89 83       	std	Y+1, r24	; 0x01
    2306:	20 91 06 03 	lds	r18, 0x0306
    230a:	30 91 07 03 	lds	r19, 0x0307
    230e:	89 81       	ldd	r24, Y+1	; 0x01
    2310:	9a 81       	ldd	r25, Y+2	; 0x02
    2312:	28 17       	cp	r18, r24
    2314:	39 07       	cpc	r19, r25
    2316:	38 f4       	brcc	.+14     	; 0x2326 <vTaskIncrementTick+0x120>
    2318:	89 81       	ldd	r24, Y+1	; 0x01
    231a:	9a 81       	ldd	r25, Y+2	; 0x02
    231c:	90 93 68 00 	sts	0x0068, r25
    2320:	80 93 67 00 	sts	0x0067, r24
    2324:	3c c0       	rjmp	.+120    	; 0x239e <vTaskIncrementTick+0x198>
    2326:	8d 81       	ldd	r24, Y+5	; 0x05
    2328:	9e 81       	ldd	r25, Y+6	; 0x06
    232a:	02 96       	adiw	r24, 0x02	; 2
    232c:	0e 94 c3 04 	call	0x986	; 0x986 <vListRemove>
    2330:	ed 81       	ldd	r30, Y+5	; 0x05
    2332:	fe 81       	ldd	r31, Y+6	; 0x06
    2334:	84 89       	ldd	r24, Z+20	; 0x14
    2336:	95 89       	ldd	r25, Z+21	; 0x15
    2338:	00 97       	sbiw	r24, 0x00	; 0
    233a:	29 f0       	breq	.+10     	; 0x2346 <vTaskIncrementTick+0x140>
    233c:	8d 81       	ldd	r24, Y+5	; 0x05
    233e:	9e 81       	ldd	r25, Y+6	; 0x06
    2340:	0c 96       	adiw	r24, 0x0c	; 12
    2342:	0e 94 c3 04 	call	0x986	; 0x986 <vListRemove>
    2346:	ed 81       	ldd	r30, Y+5	; 0x05
    2348:	fe 81       	ldd	r31, Y+6	; 0x06
    234a:	96 89       	ldd	r25, Z+22	; 0x16
    234c:	80 91 09 03 	lds	r24, 0x0309
    2350:	89 17       	cp	r24, r25
    2352:	28 f4       	brcc	.+10     	; 0x235e <vTaskIncrementTick+0x158>
    2354:	ed 81       	ldd	r30, Y+5	; 0x05
    2356:	fe 81       	ldd	r31, Y+6	; 0x06
    2358:	86 89       	ldd	r24, Z+22	; 0x16
    235a:	80 93 09 03 	sts	0x0309, r24
    235e:	ed 81       	ldd	r30, Y+5	; 0x05
    2360:	fe 81       	ldd	r31, Y+6	; 0x06
    2362:	86 89       	ldd	r24, Z+22	; 0x16
    2364:	28 2f       	mov	r18, r24
    2366:	30 e0       	ldi	r19, 0x00	; 0
    2368:	c9 01       	movw	r24, r18
    236a:	88 0f       	add	r24, r24
    236c:	99 1f       	adc	r25, r25
    236e:	88 0f       	add	r24, r24
    2370:	99 1f       	adc	r25, r25
    2372:	88 0f       	add	r24, r24
    2374:	99 1f       	adc	r25, r25
    2376:	82 0f       	add	r24, r18
    2378:	93 1f       	adc	r25, r19
    237a:	ac 01       	movw	r20, r24
    237c:	40 5f       	subi	r20, 0xF0	; 240
    237e:	5c 4f       	sbci	r21, 0xFC	; 252
    2380:	8d 81       	ldd	r24, Y+5	; 0x05
    2382:	9e 81       	ldd	r25, Y+6	; 0x06
    2384:	9c 01       	movw	r18, r24
    2386:	2e 5f       	subi	r18, 0xFE	; 254
    2388:	3f 4f       	sbci	r19, 0xFF	; 255
    238a:	ca 01       	movw	r24, r20
    238c:	b9 01       	movw	r22, r18
    238e:	0e 94 0b 04 	call	0x816	; 0x816 <vListInsertEnd>
    2392:	9a cf       	rjmp	.-204    	; 0x22c8 <vTaskIncrementTick+0xc2>
	}
	else
	{
		++uxMissedTicks;
    2394:	80 91 0c 03 	lds	r24, 0x030C
    2398:	8f 5f       	subi	r24, 0xFF	; 255
    239a:	80 93 0c 03 	sts	0x030C, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    239e:	26 96       	adiw	r28, 0x06	; 6
    23a0:	0f b6       	in	r0, 0x3f	; 63
    23a2:	f8 94       	cli
    23a4:	de bf       	out	0x3e, r29	; 62
    23a6:	0f be       	out	0x3f, r0	; 63
    23a8:	cd bf       	out	0x3d, r28	; 61
    23aa:	cf 91       	pop	r28
    23ac:	df 91       	pop	r29
    23ae:	08 95       	ret

000023b0 <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    23b0:	df 93       	push	r29
    23b2:	cf 93       	push	r28
    23b4:	00 d0       	rcall	.+0      	; 0x23b6 <vTaskSwitchContext+0x6>
    23b6:	cd b7       	in	r28, 0x3d	; 61
    23b8:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    23ba:	80 91 0b 03 	lds	r24, 0x030B
    23be:	88 23       	and	r24, r24
    23c0:	49 f0       	breq	.+18     	; 0x23d4 <vTaskSwitchContext+0x24>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    23c2:	81 e0       	ldi	r24, 0x01	; 1
    23c4:	80 93 0d 03 	sts	0x030D, r24
    23c8:	54 c0       	rjmp	.+168    	; 0x2472 <vTaskSwitchContext+0xc2>
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    23ca:	80 91 09 03 	lds	r24, 0x0309
    23ce:	81 50       	subi	r24, 0x01	; 1
    23d0:	80 93 09 03 	sts	0x0309, r24
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    23d4:	80 91 09 03 	lds	r24, 0x0309
    23d8:	28 2f       	mov	r18, r24
    23da:	30 e0       	ldi	r19, 0x00	; 0
    23dc:	c9 01       	movw	r24, r18
    23de:	88 0f       	add	r24, r24
    23e0:	99 1f       	adc	r25, r25
    23e2:	88 0f       	add	r24, r24
    23e4:	99 1f       	adc	r25, r25
    23e6:	88 0f       	add	r24, r24
    23e8:	99 1f       	adc	r25, r25
    23ea:	82 0f       	add	r24, r18
    23ec:	93 1f       	adc	r25, r19
    23ee:	fc 01       	movw	r30, r24
    23f0:	e0 5f       	subi	r30, 0xF0	; 240
    23f2:	fc 4f       	sbci	r31, 0xFC	; 252
    23f4:	80 81       	ld	r24, Z
    23f6:	88 23       	and	r24, r24
    23f8:	41 f3       	breq	.-48     	; 0x23ca <vTaskSwitchContext+0x1a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    23fa:	80 91 09 03 	lds	r24, 0x0309
    23fe:	28 2f       	mov	r18, r24
    2400:	30 e0       	ldi	r19, 0x00	; 0
    2402:	c9 01       	movw	r24, r18
    2404:	88 0f       	add	r24, r24
    2406:	99 1f       	adc	r25, r25
    2408:	88 0f       	add	r24, r24
    240a:	99 1f       	adc	r25, r25
    240c:	88 0f       	add	r24, r24
    240e:	99 1f       	adc	r25, r25
    2410:	82 0f       	add	r24, r18
    2412:	93 1f       	adc	r25, r19
    2414:	80 5f       	subi	r24, 0xF0	; 240
    2416:	9c 4f       	sbci	r25, 0xFC	; 252
    2418:	9a 83       	std	Y+2, r25	; 0x02
    241a:	89 83       	std	Y+1, r24	; 0x01
    241c:	e9 81       	ldd	r30, Y+1	; 0x01
    241e:	fa 81       	ldd	r31, Y+2	; 0x02
    2420:	01 80       	ldd	r0, Z+1	; 0x01
    2422:	f2 81       	ldd	r31, Z+2	; 0x02
    2424:	e0 2d       	mov	r30, r0
    2426:	82 81       	ldd	r24, Z+2	; 0x02
    2428:	93 81       	ldd	r25, Z+3	; 0x03
    242a:	e9 81       	ldd	r30, Y+1	; 0x01
    242c:	fa 81       	ldd	r31, Y+2	; 0x02
    242e:	92 83       	std	Z+2, r25	; 0x02
    2430:	81 83       	std	Z+1, r24	; 0x01
    2432:	e9 81       	ldd	r30, Y+1	; 0x01
    2434:	fa 81       	ldd	r31, Y+2	; 0x02
    2436:	21 81       	ldd	r18, Z+1	; 0x01
    2438:	32 81       	ldd	r19, Z+2	; 0x02
    243a:	89 81       	ldd	r24, Y+1	; 0x01
    243c:	9a 81       	ldd	r25, Y+2	; 0x02
    243e:	03 96       	adiw	r24, 0x03	; 3
    2440:	28 17       	cp	r18, r24
    2442:	39 07       	cpc	r19, r25
    2444:	59 f4       	brne	.+22     	; 0x245c <vTaskSwitchContext+0xac>
    2446:	e9 81       	ldd	r30, Y+1	; 0x01
    2448:	fa 81       	ldd	r31, Y+2	; 0x02
    244a:	01 80       	ldd	r0, Z+1	; 0x01
    244c:	f2 81       	ldd	r31, Z+2	; 0x02
    244e:	e0 2d       	mov	r30, r0
    2450:	82 81       	ldd	r24, Z+2	; 0x02
    2452:	93 81       	ldd	r25, Z+3	; 0x03
    2454:	e9 81       	ldd	r30, Y+1	; 0x01
    2456:	fa 81       	ldd	r31, Y+2	; 0x02
    2458:	92 83       	std	Z+2, r25	; 0x02
    245a:	81 83       	std	Z+1, r24	; 0x01
    245c:	e9 81       	ldd	r30, Y+1	; 0x01
    245e:	fa 81       	ldd	r31, Y+2	; 0x02
    2460:	01 80       	ldd	r0, Z+1	; 0x01
    2462:	f2 81       	ldd	r31, Z+2	; 0x02
    2464:	e0 2d       	mov	r30, r0
    2466:	86 81       	ldd	r24, Z+6	; 0x06
    2468:	97 81       	ldd	r25, Z+7	; 0x07
    246a:	90 93 03 03 	sts	0x0303, r25
    246e:	80 93 02 03 	sts	0x0302, r24
	
		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
    2472:	0f 90       	pop	r0
    2474:	0f 90       	pop	r0
    2476:	cf 91       	pop	r28
    2478:	df 91       	pop	r29
    247a:	08 95       	ret

0000247c <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    247c:	df 93       	push	r29
    247e:	cf 93       	push	r28
    2480:	00 d0       	rcall	.+0      	; 0x2482 <vTaskPlaceOnEventList+0x6>
    2482:	00 d0       	rcall	.+0      	; 0x2484 <vTaskPlaceOnEventList+0x8>
    2484:	00 d0       	rcall	.+0      	; 0x2486 <vTaskPlaceOnEventList+0xa>
    2486:	cd b7       	in	r28, 0x3d	; 61
    2488:	de b7       	in	r29, 0x3e	; 62
    248a:	9c 83       	std	Y+4, r25	; 0x04
    248c:	8b 83       	std	Y+3, r24	; 0x03
    248e:	7e 83       	std	Y+6, r23	; 0x06
    2490:	6d 83       	std	Y+5, r22	; 0x05
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    2492:	4b 81       	ldd	r20, Y+3	; 0x03
    2494:	5c 81       	ldd	r21, Y+4	; 0x04
    2496:	80 91 02 03 	lds	r24, 0x0302
    249a:	90 91 03 03 	lds	r25, 0x0303
    249e:	9c 01       	movw	r18, r24
    24a0:	24 5f       	subi	r18, 0xF4	; 244
    24a2:	3f 4f       	sbci	r19, 0xFF	; 255
    24a4:	ca 01       	movw	r24, r20
    24a6:	b9 01       	movw	r22, r18
    24a8:	0e 94 57 04 	call	0x8ae	; 0x8ae <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    24ac:	80 91 02 03 	lds	r24, 0x0302
    24b0:	90 91 03 03 	lds	r25, 0x0303
    24b4:	02 96       	adiw	r24, 0x02	; 2
    24b6:	0e 94 c3 04 	call	0x986	; 0x986 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    24ba:	20 91 06 03 	lds	r18, 0x0306
    24be:	30 91 07 03 	lds	r19, 0x0307
    24c2:	8d 81       	ldd	r24, Y+5	; 0x05
    24c4:	9e 81       	ldd	r25, Y+6	; 0x06
    24c6:	82 0f       	add	r24, r18
    24c8:	93 1f       	adc	r25, r19
    24ca:	9a 83       	std	Y+2, r25	; 0x02
    24cc:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    24ce:	89 81       	ldd	r24, Y+1	; 0x01
    24d0:	9a 81       	ldd	r25, Y+2	; 0x02
    24d2:	0e 94 3c 14 	call	0x2878	; 0x2878 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    24d6:	26 96       	adiw	r28, 0x06	; 6
    24d8:	0f b6       	in	r0, 0x3f	; 63
    24da:	f8 94       	cli
    24dc:	de bf       	out	0x3e, r29	; 62
    24de:	0f be       	out	0x3f, r0	; 63
    24e0:	cd bf       	out	0x3d, r28	; 61
    24e2:	cf 91       	pop	r28
    24e4:	df 91       	pop	r29
    24e6:	08 95       	ret

000024e8 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    24e8:	df 93       	push	r29
    24ea:	cf 93       	push	r28
    24ec:	00 d0       	rcall	.+0      	; 0x24ee <xTaskRemoveFromEventList+0x6>
    24ee:	00 d0       	rcall	.+0      	; 0x24f0 <xTaskRemoveFromEventList+0x8>
    24f0:	0f 92       	push	r0
    24f2:	cd b7       	in	r28, 0x3d	; 61
    24f4:	de b7       	in	r29, 0x3e	; 62
    24f6:	9d 83       	std	Y+5, r25	; 0x05
    24f8:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    24fa:	ec 81       	ldd	r30, Y+4	; 0x04
    24fc:	fd 81       	ldd	r31, Y+5	; 0x05
    24fe:	05 80       	ldd	r0, Z+5	; 0x05
    2500:	f6 81       	ldd	r31, Z+6	; 0x06
    2502:	e0 2d       	mov	r30, r0
    2504:	86 81       	ldd	r24, Z+6	; 0x06
    2506:	97 81       	ldd	r25, Z+7	; 0x07
    2508:	9b 83       	std	Y+3, r25	; 0x03
    250a:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    250c:	8a 81       	ldd	r24, Y+2	; 0x02
    250e:	9b 81       	ldd	r25, Y+3	; 0x03
    2510:	0c 96       	adiw	r24, 0x0c	; 12
    2512:	0e 94 c3 04 	call	0x986	; 0x986 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2516:	80 91 0b 03 	lds	r24, 0x030B
    251a:	88 23       	and	r24, r24
    251c:	61 f5       	brne	.+88     	; 0x2576 <xTaskRemoveFromEventList+0x8e>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    251e:	8a 81       	ldd	r24, Y+2	; 0x02
    2520:	9b 81       	ldd	r25, Y+3	; 0x03
    2522:	02 96       	adiw	r24, 0x02	; 2
    2524:	0e 94 c3 04 	call	0x986	; 0x986 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    2528:	ea 81       	ldd	r30, Y+2	; 0x02
    252a:	fb 81       	ldd	r31, Y+3	; 0x03
    252c:	96 89       	ldd	r25, Z+22	; 0x16
    252e:	80 91 09 03 	lds	r24, 0x0309
    2532:	89 17       	cp	r24, r25
    2534:	28 f4       	brcc	.+10     	; 0x2540 <xTaskRemoveFromEventList+0x58>
    2536:	ea 81       	ldd	r30, Y+2	; 0x02
    2538:	fb 81       	ldd	r31, Y+3	; 0x03
    253a:	86 89       	ldd	r24, Z+22	; 0x16
    253c:	80 93 09 03 	sts	0x0309, r24
    2540:	ea 81       	ldd	r30, Y+2	; 0x02
    2542:	fb 81       	ldd	r31, Y+3	; 0x03
    2544:	86 89       	ldd	r24, Z+22	; 0x16
    2546:	28 2f       	mov	r18, r24
    2548:	30 e0       	ldi	r19, 0x00	; 0
    254a:	c9 01       	movw	r24, r18
    254c:	88 0f       	add	r24, r24
    254e:	99 1f       	adc	r25, r25
    2550:	88 0f       	add	r24, r24
    2552:	99 1f       	adc	r25, r25
    2554:	88 0f       	add	r24, r24
    2556:	99 1f       	adc	r25, r25
    2558:	82 0f       	add	r24, r18
    255a:	93 1f       	adc	r25, r19
    255c:	ac 01       	movw	r20, r24
    255e:	40 5f       	subi	r20, 0xF0	; 240
    2560:	5c 4f       	sbci	r21, 0xFC	; 252
    2562:	8a 81       	ldd	r24, Y+2	; 0x02
    2564:	9b 81       	ldd	r25, Y+3	; 0x03
    2566:	9c 01       	movw	r18, r24
    2568:	2e 5f       	subi	r18, 0xFE	; 254
    256a:	3f 4f       	sbci	r19, 0xFF	; 255
    256c:	ca 01       	movw	r24, r20
    256e:	b9 01       	movw	r22, r18
    2570:	0e 94 0b 04 	call	0x816	; 0x816 <vListInsertEnd>
    2574:	0a c0       	rjmp	.+20     	; 0x258a <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    2576:	8a 81       	ldd	r24, Y+2	; 0x02
    2578:	9b 81       	ldd	r25, Y+3	; 0x03
    257a:	9c 01       	movw	r18, r24
    257c:	24 5f       	subi	r18, 0xF4	; 244
    257e:	3f 4f       	sbci	r19, 0xFF	; 255
    2580:	81 e4       	ldi	r24, 0x41	; 65
    2582:	93 e0       	ldi	r25, 0x03	; 3
    2584:	b9 01       	movw	r22, r18
    2586:	0e 94 0b 04 	call	0x816	; 0x816 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    258a:	ea 81       	ldd	r30, Y+2	; 0x02
    258c:	fb 81       	ldd	r31, Y+3	; 0x03
    258e:	96 89       	ldd	r25, Z+22	; 0x16
    2590:	e0 91 02 03 	lds	r30, 0x0302
    2594:	f0 91 03 03 	lds	r31, 0x0303
    2598:	86 89       	ldd	r24, Z+22	; 0x16
    259a:	98 17       	cp	r25, r24
    259c:	18 f0       	brcs	.+6      	; 0x25a4 <xTaskRemoveFromEventList+0xbc>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    259e:	81 e0       	ldi	r24, 0x01	; 1
    25a0:	89 83       	std	Y+1, r24	; 0x01
    25a2:	01 c0       	rjmp	.+2      	; 0x25a6 <xTaskRemoveFromEventList+0xbe>
	}
	else
	{
		xReturn = pdFALSE;
    25a4:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    25a6:	89 81       	ldd	r24, Y+1	; 0x01
}
    25a8:	0f 90       	pop	r0
    25aa:	0f 90       	pop	r0
    25ac:	0f 90       	pop	r0
    25ae:	0f 90       	pop	r0
    25b0:	0f 90       	pop	r0
    25b2:	cf 91       	pop	r28
    25b4:	df 91       	pop	r29
    25b6:	08 95       	ret

000025b8 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    25b8:	df 93       	push	r29
    25ba:	cf 93       	push	r28
    25bc:	00 d0       	rcall	.+0      	; 0x25be <vTaskSetTimeOutState+0x6>
    25be:	cd b7       	in	r28, 0x3d	; 61
    25c0:	de b7       	in	r29, 0x3e	; 62
    25c2:	9a 83       	std	Y+2, r25	; 0x02
    25c4:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    25c6:	80 91 0e 03 	lds	r24, 0x030E
    25ca:	e9 81       	ldd	r30, Y+1	; 0x01
    25cc:	fa 81       	ldd	r31, Y+2	; 0x02
    25ce:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    25d0:	80 91 06 03 	lds	r24, 0x0306
    25d4:	90 91 07 03 	lds	r25, 0x0307
    25d8:	e9 81       	ldd	r30, Y+1	; 0x01
    25da:	fa 81       	ldd	r31, Y+2	; 0x02
    25dc:	92 83       	std	Z+2, r25	; 0x02
    25de:	81 83       	std	Z+1, r24	; 0x01
}
    25e0:	0f 90       	pop	r0
    25e2:	0f 90       	pop	r0
    25e4:	cf 91       	pop	r28
    25e6:	df 91       	pop	r29
    25e8:	08 95       	ret

000025ea <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    25ea:	df 93       	push	r29
    25ec:	cf 93       	push	r28
    25ee:	00 d0       	rcall	.+0      	; 0x25f0 <xTaskCheckForTimeOut+0x6>
    25f0:	00 d0       	rcall	.+0      	; 0x25f2 <xTaskCheckForTimeOut+0x8>
    25f2:	0f 92       	push	r0
    25f4:	cd b7       	in	r28, 0x3d	; 61
    25f6:	de b7       	in	r29, 0x3e	; 62
    25f8:	9b 83       	std	Y+3, r25	; 0x03
    25fa:	8a 83       	std	Y+2, r24	; 0x02
    25fc:	7d 83       	std	Y+5, r23	; 0x05
    25fe:	6c 83       	std	Y+4, r22	; 0x04
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    2600:	0f b6       	in	r0, 0x3f	; 63
    2602:	f8 94       	cli
    2604:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    2606:	ea 81       	ldd	r30, Y+2	; 0x02
    2608:	fb 81       	ldd	r31, Y+3	; 0x03
    260a:	90 81       	ld	r25, Z
    260c:	80 91 0e 03 	lds	r24, 0x030E
    2610:	98 17       	cp	r25, r24
    2612:	71 f0       	breq	.+28     	; 0x2630 <xTaskCheckForTimeOut+0x46>
    2614:	ea 81       	ldd	r30, Y+2	; 0x02
    2616:	fb 81       	ldd	r31, Y+3	; 0x03
    2618:	21 81       	ldd	r18, Z+1	; 0x01
    261a:	32 81       	ldd	r19, Z+2	; 0x02
    261c:	80 91 06 03 	lds	r24, 0x0306
    2620:	90 91 07 03 	lds	r25, 0x0307
    2624:	82 17       	cp	r24, r18
    2626:	93 07       	cpc	r25, r19
    2628:	18 f0       	brcs	.+6      	; 0x2630 <xTaskCheckForTimeOut+0x46>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    262a:	81 e0       	ldi	r24, 0x01	; 1
    262c:	89 83       	std	Y+1, r24	; 0x01
    262e:	2f c0       	rjmp	.+94     	; 0x268e <xTaskCheckForTimeOut+0xa4>
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    2630:	20 91 06 03 	lds	r18, 0x0306
    2634:	30 91 07 03 	lds	r19, 0x0307
    2638:	ea 81       	ldd	r30, Y+2	; 0x02
    263a:	fb 81       	ldd	r31, Y+3	; 0x03
    263c:	81 81       	ldd	r24, Z+1	; 0x01
    263e:	92 81       	ldd	r25, Z+2	; 0x02
    2640:	28 1b       	sub	r18, r24
    2642:	39 0b       	sbc	r19, r25
    2644:	ec 81       	ldd	r30, Y+4	; 0x04
    2646:	fd 81       	ldd	r31, Y+5	; 0x05
    2648:	80 81       	ld	r24, Z
    264a:	91 81       	ldd	r25, Z+1	; 0x01
    264c:	28 17       	cp	r18, r24
    264e:	39 07       	cpc	r19, r25
    2650:	e0 f4       	brcc	.+56     	; 0x268a <xTaskCheckForTimeOut+0xa0>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    2652:	ec 81       	ldd	r30, Y+4	; 0x04
    2654:	fd 81       	ldd	r31, Y+5	; 0x05
    2656:	40 81       	ld	r20, Z
    2658:	51 81       	ldd	r21, Z+1	; 0x01
    265a:	ea 81       	ldd	r30, Y+2	; 0x02
    265c:	fb 81       	ldd	r31, Y+3	; 0x03
    265e:	21 81       	ldd	r18, Z+1	; 0x01
    2660:	32 81       	ldd	r19, Z+2	; 0x02
    2662:	80 91 06 03 	lds	r24, 0x0306
    2666:	90 91 07 03 	lds	r25, 0x0307
    266a:	b9 01       	movw	r22, r18
    266c:	68 1b       	sub	r22, r24
    266e:	79 0b       	sbc	r23, r25
    2670:	cb 01       	movw	r24, r22
    2672:	84 0f       	add	r24, r20
    2674:	95 1f       	adc	r25, r21
    2676:	ec 81       	ldd	r30, Y+4	; 0x04
    2678:	fd 81       	ldd	r31, Y+5	; 0x05
    267a:	91 83       	std	Z+1, r25	; 0x01
    267c:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    267e:	8a 81       	ldd	r24, Y+2	; 0x02
    2680:	9b 81       	ldd	r25, Y+3	; 0x03
    2682:	0e 94 dc 12 	call	0x25b8	; 0x25b8 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    2686:	19 82       	std	Y+1, r1	; 0x01
    2688:	02 c0       	rjmp	.+4      	; 0x268e <xTaskCheckForTimeOut+0xa4>
		}
		else
		{
			xReturn = pdTRUE;
    268a:	81 e0       	ldi	r24, 0x01	; 1
    268c:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    268e:	0f 90       	pop	r0
    2690:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2692:	89 81       	ldd	r24, Y+1	; 0x01
}
    2694:	0f 90       	pop	r0
    2696:	0f 90       	pop	r0
    2698:	0f 90       	pop	r0
    269a:	0f 90       	pop	r0
    269c:	0f 90       	pop	r0
    269e:	cf 91       	pop	r28
    26a0:	df 91       	pop	r29
    26a2:	08 95       	ret

000026a4 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    26a4:	df 93       	push	r29
    26a6:	cf 93       	push	r28
    26a8:	cd b7       	in	r28, 0x3d	; 61
    26aa:	de b7       	in	r29, 0x3e	; 62
	xMissedYield = pdTRUE;
    26ac:	81 e0       	ldi	r24, 0x01	; 1
    26ae:	80 93 0d 03 	sts	0x030D, r24
}
    26b2:	cf 91       	pop	r28
    26b4:	df 91       	pop	r29
    26b6:	08 95       	ret

000026b8 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    26b8:	df 93       	push	r29
    26ba:	cf 93       	push	r28
    26bc:	00 d0       	rcall	.+0      	; 0x26be <prvIdleTask+0x6>
    26be:	cd b7       	in	r28, 0x3d	; 61
    26c0:	de b7       	in	r29, 0x3e	; 62
    26c2:	9a 83       	std	Y+2, r25	; 0x02
    26c4:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    26c6:	0e 94 fe 13 	call	0x27fc	; 0x27fc <prvCheckTasksWaitingTermination>
    26ca:	fd cf       	rjmp	.-6      	; 0x26c6 <prvIdleTask+0xe>

000026cc <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
    26cc:	0f 93       	push	r16
    26ce:	1f 93       	push	r17
    26d0:	df 93       	push	r29
    26d2:	cf 93       	push	r28
    26d4:	cd b7       	in	r28, 0x3d	; 61
    26d6:	de b7       	in	r29, 0x3e	; 62
    26d8:	29 97       	sbiw	r28, 0x09	; 9
    26da:	0f b6       	in	r0, 0x3f	; 63
    26dc:	f8 94       	cli
    26de:	de bf       	out	0x3e, r29	; 62
    26e0:	0f be       	out	0x3f, r0	; 63
    26e2:	cd bf       	out	0x3d, r28	; 61
    26e4:	9a 83       	std	Y+2, r25	; 0x02
    26e6:	89 83       	std	Y+1, r24	; 0x01
    26e8:	7c 83       	std	Y+4, r23	; 0x04
    26ea:	6b 83       	std	Y+3, r22	; 0x03
    26ec:	4d 83       	std	Y+5, r20	; 0x05
    26ee:	3f 83       	std	Y+7, r19	; 0x07
    26f0:	2e 83       	std	Y+6, r18	; 0x06
    26f2:	19 87       	std	Y+9, r17	; 0x09
    26f4:	08 87       	std	Y+8, r16	; 0x08
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    26f6:	89 81       	ldd	r24, Y+1	; 0x01
    26f8:	9a 81       	ldd	r25, Y+2	; 0x02
    26fa:	49 96       	adiw	r24, 0x19	; 25
    26fc:	2b 81       	ldd	r18, Y+3	; 0x03
    26fe:	3c 81       	ldd	r19, Y+4	; 0x04
    2700:	b9 01       	movw	r22, r18
    2702:	48 e0       	ldi	r20, 0x08	; 8
    2704:	50 e0       	ldi	r21, 0x00	; 0
    2706:	0e 94 ec 15 	call	0x2bd8	; 0x2bd8 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    270a:	e9 81       	ldd	r30, Y+1	; 0x01
    270c:	fa 81       	ldd	r31, Y+2	; 0x02
    270e:	10 a2       	std	Z+32, r1	; 0x20

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
    2710:	8d 81       	ldd	r24, Y+5	; 0x05
    2712:	83 30       	cpi	r24, 0x03	; 3
    2714:	10 f0       	brcs	.+4      	; 0x271a <prvInitialiseTCBVariables+0x4e>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
    2716:	82 e0       	ldi	r24, 0x02	; 2
    2718:	8d 83       	std	Y+5, r24	; 0x05
	}

	pxTCB->uxPriority = uxPriority;
    271a:	e9 81       	ldd	r30, Y+1	; 0x01
    271c:	fa 81       	ldd	r31, Y+2	; 0x02
    271e:	8d 81       	ldd	r24, Y+5	; 0x05
    2720:	86 8b       	std	Z+22, r24	; 0x16
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
    2722:	e9 81       	ldd	r30, Y+1	; 0x01
    2724:	fa 81       	ldd	r31, Y+2	; 0x02
    2726:	8d 81       	ldd	r24, Y+5	; 0x05
    2728:	81 a3       	std	Z+33, r24	; 0x21
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    272a:	89 81       	ldd	r24, Y+1	; 0x01
    272c:	9a 81       	ldd	r25, Y+2	; 0x02
    272e:	02 96       	adiw	r24, 0x02	; 2
    2730:	0e 94 fb 03 	call	0x7f6	; 0x7f6 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    2734:	89 81       	ldd	r24, Y+1	; 0x01
    2736:	9a 81       	ldd	r25, Y+2	; 0x02
    2738:	0c 96       	adiw	r24, 0x0c	; 12
    273a:	0e 94 fb 03 	call	0x7f6	; 0x7f6 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    273e:	e9 81       	ldd	r30, Y+1	; 0x01
    2740:	fa 81       	ldd	r31, Y+2	; 0x02
    2742:	89 81       	ldd	r24, Y+1	; 0x01
    2744:	9a 81       	ldd	r25, Y+2	; 0x02
    2746:	91 87       	std	Z+9, r25	; 0x09
    2748:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    274a:	8d 81       	ldd	r24, Y+5	; 0x05
    274c:	28 2f       	mov	r18, r24
    274e:	30 e0       	ldi	r19, 0x00	; 0
    2750:	83 e0       	ldi	r24, 0x03	; 3
    2752:	90 e0       	ldi	r25, 0x00	; 0
    2754:	82 1b       	sub	r24, r18
    2756:	93 0b       	sbc	r25, r19
    2758:	e9 81       	ldd	r30, Y+1	; 0x01
    275a:	fa 81       	ldd	r31, Y+2	; 0x02
    275c:	95 87       	std	Z+13, r25	; 0x0d
    275e:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    2760:	e9 81       	ldd	r30, Y+1	; 0x01
    2762:	fa 81       	ldd	r31, Y+2	; 0x02
    2764:	89 81       	ldd	r24, Y+1	; 0x01
    2766:	9a 81       	ldd	r25, Y+2	; 0x02
    2768:	93 8b       	std	Z+19, r25	; 0x13
    276a:	82 8b       	std	Z+18, r24	; 0x12
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
    276c:	29 96       	adiw	r28, 0x09	; 9
    276e:	0f b6       	in	r0, 0x3f	; 63
    2770:	f8 94       	cli
    2772:	de bf       	out	0x3e, r29	; 62
    2774:	0f be       	out	0x3f, r0	; 63
    2776:	cd bf       	out	0x3d, r28	; 61
    2778:	cf 91       	pop	r28
    277a:	df 91       	pop	r29
    277c:	1f 91       	pop	r17
    277e:	0f 91       	pop	r16
    2780:	08 95       	ret

00002782 <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
    2782:	df 93       	push	r29
    2784:	cf 93       	push	r28
    2786:	0f 92       	push	r0
    2788:	cd b7       	in	r28, 0x3d	; 61
    278a:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    278c:	19 82       	std	Y+1, r1	; 0x01
    278e:	13 c0       	rjmp	.+38     	; 0x27b6 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    2790:	89 81       	ldd	r24, Y+1	; 0x01
    2792:	28 2f       	mov	r18, r24
    2794:	30 e0       	ldi	r19, 0x00	; 0
    2796:	c9 01       	movw	r24, r18
    2798:	88 0f       	add	r24, r24
    279a:	99 1f       	adc	r25, r25
    279c:	88 0f       	add	r24, r24
    279e:	99 1f       	adc	r25, r25
    27a0:	88 0f       	add	r24, r24
    27a2:	99 1f       	adc	r25, r25
    27a4:	82 0f       	add	r24, r18
    27a6:	93 1f       	adc	r25, r19
    27a8:	80 5f       	subi	r24, 0xF0	; 240
    27aa:	9c 4f       	sbci	r25, 0xFC	; 252
    27ac:	0e 94 d1 03 	call	0x7a2	; 0x7a2 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    27b0:	89 81       	ldd	r24, Y+1	; 0x01
    27b2:	8f 5f       	subi	r24, 0xFF	; 255
    27b4:	89 83       	std	Y+1, r24	; 0x01
    27b6:	89 81       	ldd	r24, Y+1	; 0x01
    27b8:	83 30       	cpi	r24, 0x03	; 3
    27ba:	50 f3       	brcs	.-44     	; 0x2790 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    27bc:	8b e2       	ldi	r24, 0x2B	; 43
    27be:	93 e0       	ldi	r25, 0x03	; 3
    27c0:	0e 94 d1 03 	call	0x7a2	; 0x7a2 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    27c4:	84 e3       	ldi	r24, 0x34	; 52
    27c6:	93 e0       	ldi	r25, 0x03	; 3
    27c8:	0e 94 d1 03 	call	0x7a2	; 0x7a2 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    27cc:	81 e4       	ldi	r24, 0x41	; 65
    27ce:	93 e0       	ldi	r25, 0x03	; 3
    27d0:	0e 94 d1 03 	call	0x7a2	; 0x7a2 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    27d4:	8a e4       	ldi	r24, 0x4A	; 74
    27d6:	93 e0       	ldi	r25, 0x03	; 3
    27d8:	0e 94 d1 03 	call	0x7a2	; 0x7a2 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    27dc:	8b e2       	ldi	r24, 0x2B	; 43
    27de:	93 e0       	ldi	r25, 0x03	; 3
    27e0:	90 93 3e 03 	sts	0x033E, r25
    27e4:	80 93 3d 03 	sts	0x033D, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    27e8:	84 e3       	ldi	r24, 0x34	; 52
    27ea:	93 e0       	ldi	r25, 0x03	; 3
    27ec:	90 93 40 03 	sts	0x0340, r25
    27f0:	80 93 3f 03 	sts	0x033F, r24
}
    27f4:	0f 90       	pop	r0
    27f6:	cf 91       	pop	r28
    27f8:	df 91       	pop	r29
    27fa:	08 95       	ret

000027fc <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    27fc:	df 93       	push	r29
    27fe:	cf 93       	push	r28
    2800:	00 d0       	rcall	.+0      	; 0x2802 <prvCheckTasksWaitingTermination+0x6>
    2802:	0f 92       	push	r0
    2804:	cd b7       	in	r28, 0x3d	; 61
    2806:	de b7       	in	r29, 0x3e	; 62
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    2808:	80 91 04 03 	lds	r24, 0x0304
    280c:	88 23       	and	r24, r24
    280e:	71 f1       	breq	.+92     	; 0x286c <prvCheckTasksWaitingTermination+0x70>
		{
			vTaskSuspendAll();
    2810:	0e 94 38 10 	call	0x2070	; 0x2070 <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    2814:	80 91 4a 03 	lds	r24, 0x034A
    2818:	1b 82       	std	Y+3, r1	; 0x03
    281a:	88 23       	and	r24, r24
    281c:	11 f4       	brne	.+4      	; 0x2822 <prvCheckTasksWaitingTermination+0x26>
    281e:	81 e0       	ldi	r24, 0x01	; 1
    2820:	8b 83       	std	Y+3, r24	; 0x03
			xTaskResumeAll();
    2822:	0e 94 44 10 	call	0x2088	; 0x2088 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    2826:	8b 81       	ldd	r24, Y+3	; 0x03
    2828:	88 23       	and	r24, r24
    282a:	01 f5       	brne	.+64     	; 0x286c <prvCheckTasksWaitingTermination+0x70>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    282c:	0f b6       	in	r0, 0x3f	; 63
    282e:	f8 94       	cli
    2830:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    2832:	e0 91 4f 03 	lds	r30, 0x034F
    2836:	f0 91 50 03 	lds	r31, 0x0350
    283a:	86 81       	ldd	r24, Z+6	; 0x06
    283c:	97 81       	ldd	r25, Z+7	; 0x07
    283e:	9a 83       	std	Y+2, r25	; 0x02
    2840:	89 83       	std	Y+1, r24	; 0x01
					vListRemove( &( pxTCB->xGenericListItem ) );
    2842:	89 81       	ldd	r24, Y+1	; 0x01
    2844:	9a 81       	ldd	r25, Y+2	; 0x02
    2846:	02 96       	adiw	r24, 0x02	; 2
    2848:	0e 94 c3 04 	call	0x986	; 0x986 <vListRemove>
					--uxCurrentNumberOfTasks;
    284c:	80 91 05 03 	lds	r24, 0x0305
    2850:	81 50       	subi	r24, 0x01	; 1
    2852:	80 93 05 03 	sts	0x0305, r24
					--uxTasksDeleted;
    2856:	80 91 04 03 	lds	r24, 0x0304
    285a:	81 50       	subi	r24, 0x01	; 1
    285c:	80 93 04 03 	sts	0x0304, r24
				}
				taskEXIT_CRITICAL();
    2860:	0f 90       	pop	r0
    2862:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    2864:	89 81       	ldd	r24, Y+1	; 0x01
    2866:	9a 81       	ldd	r25, Y+2	; 0x02
    2868:	0e 94 d5 14 	call	0x29aa	; 0x29aa <prvDeleteTCB>
			}
		}
	}
	#endif
}
    286c:	0f 90       	pop	r0
    286e:	0f 90       	pop	r0
    2870:	0f 90       	pop	r0
    2872:	cf 91       	pop	r28
    2874:	df 91       	pop	r29
    2876:	08 95       	ret

00002878 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    2878:	df 93       	push	r29
    287a:	cf 93       	push	r28
    287c:	00 d0       	rcall	.+0      	; 0x287e <prvAddCurrentTaskToDelayedList+0x6>
    287e:	cd b7       	in	r28, 0x3d	; 61
    2880:	de b7       	in	r29, 0x3e	; 62
    2882:	9a 83       	std	Y+2, r25	; 0x02
    2884:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    2886:	e0 91 02 03 	lds	r30, 0x0302
    288a:	f0 91 03 03 	lds	r31, 0x0303
    288e:	89 81       	ldd	r24, Y+1	; 0x01
    2890:	9a 81       	ldd	r25, Y+2	; 0x02
    2892:	93 83       	std	Z+3, r25	; 0x03
    2894:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    2896:	20 91 06 03 	lds	r18, 0x0306
    289a:	30 91 07 03 	lds	r19, 0x0307
    289e:	89 81       	ldd	r24, Y+1	; 0x01
    28a0:	9a 81       	ldd	r25, Y+2	; 0x02
    28a2:	82 17       	cp	r24, r18
    28a4:	93 07       	cpc	r25, r19
    28a6:	70 f4       	brcc	.+28     	; 0x28c4 <prvAddCurrentTaskToDelayedList+0x4c>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    28a8:	80 91 3f 03 	lds	r24, 0x033F
    28ac:	90 91 40 03 	lds	r25, 0x0340
    28b0:	20 91 02 03 	lds	r18, 0x0302
    28b4:	30 91 03 03 	lds	r19, 0x0303
    28b8:	2e 5f       	subi	r18, 0xFE	; 254
    28ba:	3f 4f       	sbci	r19, 0xFF	; 255
    28bc:	b9 01       	movw	r22, r18
    28be:	0e 94 57 04 	call	0x8ae	; 0x8ae <vListInsert>
    28c2:	1e c0       	rjmp	.+60     	; 0x2900 <prvAddCurrentTaskToDelayedList+0x88>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    28c4:	40 91 3d 03 	lds	r20, 0x033D
    28c8:	50 91 3e 03 	lds	r21, 0x033E
    28cc:	80 91 02 03 	lds	r24, 0x0302
    28d0:	90 91 03 03 	lds	r25, 0x0303
    28d4:	9c 01       	movw	r18, r24
    28d6:	2e 5f       	subi	r18, 0xFE	; 254
    28d8:	3f 4f       	sbci	r19, 0xFF	; 255
    28da:	ca 01       	movw	r24, r20
    28dc:	b9 01       	movw	r22, r18
    28de:	0e 94 57 04 	call	0x8ae	; 0x8ae <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    28e2:	20 91 67 00 	lds	r18, 0x0067
    28e6:	30 91 68 00 	lds	r19, 0x0068
    28ea:	89 81       	ldd	r24, Y+1	; 0x01
    28ec:	9a 81       	ldd	r25, Y+2	; 0x02
    28ee:	82 17       	cp	r24, r18
    28f0:	93 07       	cpc	r25, r19
    28f2:	30 f4       	brcc	.+12     	; 0x2900 <prvAddCurrentTaskToDelayedList+0x88>
		{
			xNextTaskUnblockTime = xTimeToWake;
    28f4:	89 81       	ldd	r24, Y+1	; 0x01
    28f6:	9a 81       	ldd	r25, Y+2	; 0x02
    28f8:	90 93 68 00 	sts	0x0068, r25
    28fc:	80 93 67 00 	sts	0x0067, r24
		}
	}
}
    2900:	0f 90       	pop	r0
    2902:	0f 90       	pop	r0
    2904:	cf 91       	pop	r28
    2906:	df 91       	pop	r29
    2908:	08 95       	ret

0000290a <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
    290a:	df 93       	push	r29
    290c:	cf 93       	push	r28
    290e:	cd b7       	in	r28, 0x3d	; 61
    2910:	de b7       	in	r29, 0x3e	; 62
    2912:	28 97       	sbiw	r28, 0x08	; 8
    2914:	0f b6       	in	r0, 0x3f	; 63
    2916:	f8 94       	cli
    2918:	de bf       	out	0x3e, r29	; 62
    291a:	0f be       	out	0x3f, r0	; 63
    291c:	cd bf       	out	0x3d, r28	; 61
    291e:	9c 83       	std	Y+4, r25	; 0x04
    2920:	8b 83       	std	Y+3, r24	; 0x03
    2922:	7e 83       	std	Y+6, r23	; 0x06
    2924:	6d 83       	std	Y+5, r22	; 0x05
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    2926:	82 e2       	ldi	r24, 0x22	; 34
    2928:	90 e0       	ldi	r25, 0x00	; 0
    292a:	0e 94 21 03 	call	0x642	; 0x642 <pvPortMalloc>
    292e:	9a 83       	std	Y+2, r25	; 0x02
    2930:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    2932:	89 81       	ldd	r24, Y+1	; 0x01
    2934:	9a 81       	ldd	r25, Y+2	; 0x02
    2936:	00 97       	sbiw	r24, 0x00	; 0
    2938:	69 f1       	breq	.+90     	; 0x2994 <prvAllocateTCBAndStack+0x8a>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    293a:	8d 81       	ldd	r24, Y+5	; 0x05
    293c:	9e 81       	ldd	r25, Y+6	; 0x06
    293e:	00 97       	sbiw	r24, 0x00	; 0
    2940:	39 f4       	brne	.+14     	; 0x2950 <prvAllocateTCBAndStack+0x46>
    2942:	8b 81       	ldd	r24, Y+3	; 0x03
    2944:	9c 81       	ldd	r25, Y+4	; 0x04
    2946:	0e 94 21 03 	call	0x642	; 0x642 <pvPortMalloc>
    294a:	98 87       	std	Y+8, r25	; 0x08
    294c:	8f 83       	std	Y+7, r24	; 0x07
    294e:	04 c0       	rjmp	.+8      	; 0x2958 <prvAllocateTCBAndStack+0x4e>
    2950:	8d 81       	ldd	r24, Y+5	; 0x05
    2952:	9e 81       	ldd	r25, Y+6	; 0x06
    2954:	98 87       	std	Y+8, r25	; 0x08
    2956:	8f 83       	std	Y+7, r24	; 0x07
    2958:	e9 81       	ldd	r30, Y+1	; 0x01
    295a:	fa 81       	ldd	r31, Y+2	; 0x02
    295c:	8f 81       	ldd	r24, Y+7	; 0x07
    295e:	98 85       	ldd	r25, Y+8	; 0x08
    2960:	90 8f       	std	Z+24, r25	; 0x18
    2962:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    2964:	e9 81       	ldd	r30, Y+1	; 0x01
    2966:	fa 81       	ldd	r31, Y+2	; 0x02
    2968:	87 89       	ldd	r24, Z+23	; 0x17
    296a:	90 8d       	ldd	r25, Z+24	; 0x18
    296c:	00 97       	sbiw	r24, 0x00	; 0
    296e:	39 f4       	brne	.+14     	; 0x297e <prvAllocateTCBAndStack+0x74>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    2970:	89 81       	ldd	r24, Y+1	; 0x01
    2972:	9a 81       	ldd	r25, Y+2	; 0x02
    2974:	0e 94 67 03 	call	0x6ce	; 0x6ce <vPortFree>
			pxNewTCB = NULL;
    2978:	1a 82       	std	Y+2, r1	; 0x02
    297a:	19 82       	std	Y+1, r1	; 0x01
    297c:	0b c0       	rjmp	.+22     	; 0x2994 <prvAllocateTCBAndStack+0x8a>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    297e:	e9 81       	ldd	r30, Y+1	; 0x01
    2980:	fa 81       	ldd	r31, Y+2	; 0x02
    2982:	87 89       	ldd	r24, Z+23	; 0x17
    2984:	90 8d       	ldd	r25, Z+24	; 0x18
    2986:	2b 81       	ldd	r18, Y+3	; 0x03
    2988:	3c 81       	ldd	r19, Y+4	; 0x04
    298a:	65 ea       	ldi	r22, 0xA5	; 165
    298c:	70 e0       	ldi	r23, 0x00	; 0
    298e:	a9 01       	movw	r20, r18
    2990:	0e 94 e5 15 	call	0x2bca	; 0x2bca <memset>
		}
	}

	return pxNewTCB;
    2994:	89 81       	ldd	r24, Y+1	; 0x01
    2996:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2998:	28 96       	adiw	r28, 0x08	; 8
    299a:	0f b6       	in	r0, 0x3f	; 63
    299c:	f8 94       	cli
    299e:	de bf       	out	0x3e, r29	; 62
    29a0:	0f be       	out	0x3f, r0	; 63
    29a2:	cd bf       	out	0x3d, r28	; 61
    29a4:	cf 91       	pop	r28
    29a6:	df 91       	pop	r29
    29a8:	08 95       	ret

000029aa <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
    29aa:	df 93       	push	r29
    29ac:	cf 93       	push	r28
    29ae:	00 d0       	rcall	.+0      	; 0x29b0 <prvDeleteTCB+0x6>
    29b0:	cd b7       	in	r28, 0x3d	; 61
    29b2:	de b7       	in	r29, 0x3e	; 62
    29b4:	9a 83       	std	Y+2, r25	; 0x02
    29b6:	89 83       	std	Y+1, r24	; 0x01
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    29b8:	e9 81       	ldd	r30, Y+1	; 0x01
    29ba:	fa 81       	ldd	r31, Y+2	; 0x02
    29bc:	87 89       	ldd	r24, Z+23	; 0x17
    29be:	90 8d       	ldd	r25, Z+24	; 0x18
    29c0:	0e 94 67 03 	call	0x6ce	; 0x6ce <vPortFree>
		vPortFree( pxTCB );
    29c4:	89 81       	ldd	r24, Y+1	; 0x01
    29c6:	9a 81       	ldd	r25, Y+2	; 0x02
    29c8:	0e 94 67 03 	call	0x6ce	; 0x6ce <vPortFree>
	}
    29cc:	0f 90       	pop	r0
    29ce:	0f 90       	pop	r0
    29d0:	cf 91       	pop	r28
    29d2:	df 91       	pop	r29
    29d4:	08 95       	ret

000029d6 <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	xTaskHandle xTaskGetCurrentTaskHandle( void )
	{
    29d6:	df 93       	push	r29
    29d8:	cf 93       	push	r28
    29da:	00 d0       	rcall	.+0      	; 0x29dc <xTaskGetCurrentTaskHandle+0x6>
    29dc:	cd b7       	in	r28, 0x3d	; 61
    29de:	de b7       	in	r29, 0x3e	; 62
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    29e0:	80 91 02 03 	lds	r24, 0x0302
    29e4:	90 91 03 03 	lds	r25, 0x0303
    29e8:	9a 83       	std	Y+2, r25	; 0x02
    29ea:	89 83       	std	Y+1, r24	; 0x01

		return xReturn;
    29ec:	89 81       	ldd	r24, Y+1	; 0x01
    29ee:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    29f0:	0f 90       	pop	r0
    29f2:	0f 90       	pop	r0
    29f4:	cf 91       	pop	r28
    29f6:	df 91       	pop	r29
    29f8:	08 95       	ret

000029fa <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    29fa:	df 93       	push	r29
    29fc:	cf 93       	push	r28
    29fe:	00 d0       	rcall	.+0      	; 0x2a00 <vTaskPriorityInherit+0x6>
    2a00:	00 d0       	rcall	.+0      	; 0x2a02 <vTaskPriorityInherit+0x8>
    2a02:	cd b7       	in	r28, 0x3d	; 61
    2a04:	de b7       	in	r29, 0x3e	; 62
    2a06:	9c 83       	std	Y+4, r25	; 0x04
    2a08:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
    2a0a:	8b 81       	ldd	r24, Y+3	; 0x03
    2a0c:	9c 81       	ldd	r25, Y+4	; 0x04
    2a0e:	9a 83       	std	Y+2, r25	; 0x02
    2a10:	89 83       	std	Y+1, r24	; 0x01

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    2a12:	e9 81       	ldd	r30, Y+1	; 0x01
    2a14:	fa 81       	ldd	r31, Y+2	; 0x02
    2a16:	96 89       	ldd	r25, Z+22	; 0x16
    2a18:	e0 91 02 03 	lds	r30, 0x0302
    2a1c:	f0 91 03 03 	lds	r31, 0x0303
    2a20:	86 89       	ldd	r24, Z+22	; 0x16
    2a22:	98 17       	cp	r25, r24
    2a24:	08 f0       	brcs	.+2      	; 0x2a28 <vTaskPriorityInherit+0x2e>
    2a26:	62 c0       	rjmp	.+196    	; 0x2aec <vTaskPriorityInherit+0xf2>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    2a28:	e0 91 02 03 	lds	r30, 0x0302
    2a2c:	f0 91 03 03 	lds	r31, 0x0303
    2a30:	86 89       	ldd	r24, Z+22	; 0x16
    2a32:	28 2f       	mov	r18, r24
    2a34:	30 e0       	ldi	r19, 0x00	; 0
    2a36:	83 e0       	ldi	r24, 0x03	; 3
    2a38:	90 e0       	ldi	r25, 0x00	; 0
    2a3a:	82 1b       	sub	r24, r18
    2a3c:	93 0b       	sbc	r25, r19
    2a3e:	e9 81       	ldd	r30, Y+1	; 0x01
    2a40:	fa 81       	ldd	r31, Y+2	; 0x02
    2a42:	95 87       	std	Z+13, r25	; 0x0d
    2a44:	84 87       	std	Z+12, r24	; 0x0c

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    2a46:	e9 81       	ldd	r30, Y+1	; 0x01
    2a48:	fa 81       	ldd	r31, Y+2	; 0x02
    2a4a:	42 85       	ldd	r20, Z+10	; 0x0a
    2a4c:	53 85       	ldd	r21, Z+11	; 0x0b
    2a4e:	e9 81       	ldd	r30, Y+1	; 0x01
    2a50:	fa 81       	ldd	r31, Y+2	; 0x02
    2a52:	86 89       	ldd	r24, Z+22	; 0x16
    2a54:	28 2f       	mov	r18, r24
    2a56:	30 e0       	ldi	r19, 0x00	; 0
    2a58:	c9 01       	movw	r24, r18
    2a5a:	88 0f       	add	r24, r24
    2a5c:	99 1f       	adc	r25, r25
    2a5e:	88 0f       	add	r24, r24
    2a60:	99 1f       	adc	r25, r25
    2a62:	88 0f       	add	r24, r24
    2a64:	99 1f       	adc	r25, r25
    2a66:	82 0f       	add	r24, r18
    2a68:	93 1f       	adc	r25, r19
    2a6a:	80 5f       	subi	r24, 0xF0	; 240
    2a6c:	9c 4f       	sbci	r25, 0xFC	; 252
    2a6e:	48 17       	cp	r20, r24
    2a70:	59 07       	cpc	r21, r25
    2a72:	a1 f5       	brne	.+104    	; 0x2adc <vTaskPriorityInherit+0xe2>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
    2a74:	89 81       	ldd	r24, Y+1	; 0x01
    2a76:	9a 81       	ldd	r25, Y+2	; 0x02
    2a78:	02 96       	adiw	r24, 0x02	; 2
    2a7a:	0e 94 c3 04 	call	0x986	; 0x986 <vListRemove>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    2a7e:	e0 91 02 03 	lds	r30, 0x0302
    2a82:	f0 91 03 03 	lds	r31, 0x0303
    2a86:	86 89       	ldd	r24, Z+22	; 0x16
    2a88:	e9 81       	ldd	r30, Y+1	; 0x01
    2a8a:	fa 81       	ldd	r31, Y+2	; 0x02
    2a8c:	86 8b       	std	Z+22, r24	; 0x16
				prvAddTaskToReadyQueue( pxTCB );
    2a8e:	e9 81       	ldd	r30, Y+1	; 0x01
    2a90:	fa 81       	ldd	r31, Y+2	; 0x02
    2a92:	96 89       	ldd	r25, Z+22	; 0x16
    2a94:	80 91 09 03 	lds	r24, 0x0309
    2a98:	89 17       	cp	r24, r25
    2a9a:	28 f4       	brcc	.+10     	; 0x2aa6 <vTaskPriorityInherit+0xac>
    2a9c:	e9 81       	ldd	r30, Y+1	; 0x01
    2a9e:	fa 81       	ldd	r31, Y+2	; 0x02
    2aa0:	86 89       	ldd	r24, Z+22	; 0x16
    2aa2:	80 93 09 03 	sts	0x0309, r24
    2aa6:	e9 81       	ldd	r30, Y+1	; 0x01
    2aa8:	fa 81       	ldd	r31, Y+2	; 0x02
    2aaa:	86 89       	ldd	r24, Z+22	; 0x16
    2aac:	28 2f       	mov	r18, r24
    2aae:	30 e0       	ldi	r19, 0x00	; 0
    2ab0:	c9 01       	movw	r24, r18
    2ab2:	88 0f       	add	r24, r24
    2ab4:	99 1f       	adc	r25, r25
    2ab6:	88 0f       	add	r24, r24
    2ab8:	99 1f       	adc	r25, r25
    2aba:	88 0f       	add	r24, r24
    2abc:	99 1f       	adc	r25, r25
    2abe:	82 0f       	add	r24, r18
    2ac0:	93 1f       	adc	r25, r19
    2ac2:	ac 01       	movw	r20, r24
    2ac4:	40 5f       	subi	r20, 0xF0	; 240
    2ac6:	5c 4f       	sbci	r21, 0xFC	; 252
    2ac8:	89 81       	ldd	r24, Y+1	; 0x01
    2aca:	9a 81       	ldd	r25, Y+2	; 0x02
    2acc:	9c 01       	movw	r18, r24
    2ace:	2e 5f       	subi	r18, 0xFE	; 254
    2ad0:	3f 4f       	sbci	r19, 0xFF	; 255
    2ad2:	ca 01       	movw	r24, r20
    2ad4:	b9 01       	movw	r22, r18
    2ad6:	0e 94 0b 04 	call	0x816	; 0x816 <vListInsertEnd>
    2ada:	08 c0       	rjmp	.+16     	; 0x2aec <vTaskPriorityInherit+0xf2>
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    2adc:	e0 91 02 03 	lds	r30, 0x0302
    2ae0:	f0 91 03 03 	lds	r31, 0x0303
    2ae4:	86 89       	ldd	r24, Z+22	; 0x16
    2ae6:	e9 81       	ldd	r30, Y+1	; 0x01
    2ae8:	fa 81       	ldd	r31, Y+2	; 0x02
    2aea:	86 8b       	std	Z+22, r24	; 0x16
			}
		}
	}
    2aec:	0f 90       	pop	r0
    2aee:	0f 90       	pop	r0
    2af0:	0f 90       	pop	r0
    2af2:	0f 90       	pop	r0
    2af4:	cf 91       	pop	r28
    2af6:	df 91       	pop	r29
    2af8:	08 95       	ret

00002afa <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    2afa:	df 93       	push	r29
    2afc:	cf 93       	push	r28
    2afe:	00 d0       	rcall	.+0      	; 0x2b00 <vTaskPriorityDisinherit+0x6>
    2b00:	00 d0       	rcall	.+0      	; 0x2b02 <vTaskPriorityDisinherit+0x8>
    2b02:	cd b7       	in	r28, 0x3d	; 61
    2b04:	de b7       	in	r29, 0x3e	; 62
    2b06:	9c 83       	std	Y+4, r25	; 0x04
    2b08:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
    2b0a:	8b 81       	ldd	r24, Y+3	; 0x03
    2b0c:	9c 81       	ldd	r25, Y+4	; 0x04
    2b0e:	9a 83       	std	Y+2, r25	; 0x02
    2b10:	89 83       	std	Y+1, r24	; 0x01

		if( pxMutexHolder != NULL )
    2b12:	8b 81       	ldd	r24, Y+3	; 0x03
    2b14:	9c 81       	ldd	r25, Y+4	; 0x04
    2b16:	00 97       	sbiw	r24, 0x00	; 0
    2b18:	09 f4       	brne	.+2      	; 0x2b1c <vTaskPriorityDisinherit+0x22>
    2b1a:	47 c0       	rjmp	.+142    	; 0x2baa <vTaskPriorityDisinherit+0xb0>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    2b1c:	e9 81       	ldd	r30, Y+1	; 0x01
    2b1e:	fa 81       	ldd	r31, Y+2	; 0x02
    2b20:	96 89       	ldd	r25, Z+22	; 0x16
    2b22:	e9 81       	ldd	r30, Y+1	; 0x01
    2b24:	fa 81       	ldd	r31, Y+2	; 0x02
    2b26:	81 a1       	ldd	r24, Z+33	; 0x21
    2b28:	98 17       	cp	r25, r24
    2b2a:	09 f4       	brne	.+2      	; 0x2b2e <vTaskPriorityDisinherit+0x34>
    2b2c:	3e c0       	rjmp	.+124    	; 0x2baa <vTaskPriorityDisinherit+0xb0>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
    2b2e:	89 81       	ldd	r24, Y+1	; 0x01
    2b30:	9a 81       	ldd	r25, Y+2	; 0x02
    2b32:	02 96       	adiw	r24, 0x02	; 2
    2b34:	0e 94 c3 04 	call	0x986	; 0x986 <vListRemove>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    2b38:	e9 81       	ldd	r30, Y+1	; 0x01
    2b3a:	fa 81       	ldd	r31, Y+2	; 0x02
    2b3c:	81 a1       	ldd	r24, Z+33	; 0x21
    2b3e:	e9 81       	ldd	r30, Y+1	; 0x01
    2b40:	fa 81       	ldd	r31, Y+2	; 0x02
    2b42:	86 8b       	std	Z+22, r24	; 0x16
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    2b44:	e9 81       	ldd	r30, Y+1	; 0x01
    2b46:	fa 81       	ldd	r31, Y+2	; 0x02
    2b48:	86 89       	ldd	r24, Z+22	; 0x16
    2b4a:	28 2f       	mov	r18, r24
    2b4c:	30 e0       	ldi	r19, 0x00	; 0
    2b4e:	83 e0       	ldi	r24, 0x03	; 3
    2b50:	90 e0       	ldi	r25, 0x00	; 0
    2b52:	82 1b       	sub	r24, r18
    2b54:	93 0b       	sbc	r25, r19
    2b56:	e9 81       	ldd	r30, Y+1	; 0x01
    2b58:	fa 81       	ldd	r31, Y+2	; 0x02
    2b5a:	95 87       	std	Z+13, r25	; 0x0d
    2b5c:	84 87       	std	Z+12, r24	; 0x0c
				prvAddTaskToReadyQueue( pxTCB );
    2b5e:	e9 81       	ldd	r30, Y+1	; 0x01
    2b60:	fa 81       	ldd	r31, Y+2	; 0x02
    2b62:	96 89       	ldd	r25, Z+22	; 0x16
    2b64:	80 91 09 03 	lds	r24, 0x0309
    2b68:	89 17       	cp	r24, r25
    2b6a:	28 f4       	brcc	.+10     	; 0x2b76 <vTaskPriorityDisinherit+0x7c>
    2b6c:	e9 81       	ldd	r30, Y+1	; 0x01
    2b6e:	fa 81       	ldd	r31, Y+2	; 0x02
    2b70:	86 89       	ldd	r24, Z+22	; 0x16
    2b72:	80 93 09 03 	sts	0x0309, r24
    2b76:	e9 81       	ldd	r30, Y+1	; 0x01
    2b78:	fa 81       	ldd	r31, Y+2	; 0x02
    2b7a:	86 89       	ldd	r24, Z+22	; 0x16
    2b7c:	28 2f       	mov	r18, r24
    2b7e:	30 e0       	ldi	r19, 0x00	; 0
    2b80:	c9 01       	movw	r24, r18
    2b82:	88 0f       	add	r24, r24
    2b84:	99 1f       	adc	r25, r25
    2b86:	88 0f       	add	r24, r24
    2b88:	99 1f       	adc	r25, r25
    2b8a:	88 0f       	add	r24, r24
    2b8c:	99 1f       	adc	r25, r25
    2b8e:	82 0f       	add	r24, r18
    2b90:	93 1f       	adc	r25, r19
    2b92:	ac 01       	movw	r20, r24
    2b94:	40 5f       	subi	r20, 0xF0	; 240
    2b96:	5c 4f       	sbci	r21, 0xFC	; 252
    2b98:	89 81       	ldd	r24, Y+1	; 0x01
    2b9a:	9a 81       	ldd	r25, Y+2	; 0x02
    2b9c:	9c 01       	movw	r18, r24
    2b9e:	2e 5f       	subi	r18, 0xFE	; 254
    2ba0:	3f 4f       	sbci	r19, 0xFF	; 255
    2ba2:	ca 01       	movw	r24, r20
    2ba4:	b9 01       	movw	r22, r18
    2ba6:	0e 94 0b 04 	call	0x816	; 0x816 <vListInsertEnd>
			}
		}
	}
    2baa:	0f 90       	pop	r0
    2bac:	0f 90       	pop	r0
    2bae:	0f 90       	pop	r0
    2bb0:	0f 90       	pop	r0
    2bb2:	cf 91       	pop	r28
    2bb4:	df 91       	pop	r29
    2bb6:	08 95       	ret

00002bb8 <memcpy>:
    2bb8:	fb 01       	movw	r30, r22
    2bba:	dc 01       	movw	r26, r24
    2bbc:	02 c0       	rjmp	.+4      	; 0x2bc2 <memcpy+0xa>
    2bbe:	01 90       	ld	r0, Z+
    2bc0:	0d 92       	st	X+, r0
    2bc2:	41 50       	subi	r20, 0x01	; 1
    2bc4:	50 40       	sbci	r21, 0x00	; 0
    2bc6:	d8 f7       	brcc	.-10     	; 0x2bbe <memcpy+0x6>
    2bc8:	08 95       	ret

00002bca <memset>:
    2bca:	dc 01       	movw	r26, r24
    2bcc:	01 c0       	rjmp	.+2      	; 0x2bd0 <memset+0x6>
    2bce:	6d 93       	st	X+, r22
    2bd0:	41 50       	subi	r20, 0x01	; 1
    2bd2:	50 40       	sbci	r21, 0x00	; 0
    2bd4:	e0 f7       	brcc	.-8      	; 0x2bce <memset+0x4>
    2bd6:	08 95       	ret

00002bd8 <strncpy>:
    2bd8:	fb 01       	movw	r30, r22
    2bda:	dc 01       	movw	r26, r24
    2bdc:	41 50       	subi	r20, 0x01	; 1
    2bde:	50 40       	sbci	r21, 0x00	; 0
    2be0:	48 f0       	brcs	.+18     	; 0x2bf4 <strncpy+0x1c>
    2be2:	01 90       	ld	r0, Z+
    2be4:	0d 92       	st	X+, r0
    2be6:	00 20       	and	r0, r0
    2be8:	c9 f7       	brne	.-14     	; 0x2bdc <strncpy+0x4>
    2bea:	01 c0       	rjmp	.+2      	; 0x2bee <strncpy+0x16>
    2bec:	1d 92       	st	X+, r1
    2bee:	41 50       	subi	r20, 0x01	; 1
    2bf0:	50 40       	sbci	r21, 0x00	; 0
    2bf2:	e0 f7       	brcc	.-8      	; 0x2bec <strncpy+0x14>
    2bf4:	08 95       	ret

00002bf6 <_exit>:
    2bf6:	f8 94       	cli

00002bf8 <__stop_program>:
    2bf8:	ff cf       	rjmp	.-2      	; 0x2bf8 <__stop_program>
